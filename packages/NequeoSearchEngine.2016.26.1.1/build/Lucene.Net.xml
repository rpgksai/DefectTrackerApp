<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Analyzer" -->
        <member name="M:Lucene.Net.Analysis.Analyzer.#ctor">
            <summary>
            Create a new Analyzer, reusing the same set of components per-thread
            across calls to <seealso cref="!:#tokenStream(String, Reader)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Analyzer.#ctor(Lucene.Net.Analysis.Analyzer.ReuseStrategy)" -->
        <member name="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents"/> instance for this analyzer.
            </summary>
            <param name="fieldName">
                     the name of the fields content passed to the
                     <seealso cref="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents"/> sink as a reader </param>
            <param name="reader">
                     the reader passed to the <seealso cref="T:Lucene.Net.Analysis.Tokenizer"/> constructor </param>
            <returns> the <seealso cref="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents"/> for this analyzer. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Analyzer.TokenStream(System.String,System.IO.TextReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)" -->
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)">
            <summary>
            Invoked before indexing a IndexableField instance if
            terms have already been added to that field.  this allows custom
            analyzers to place an automatic position increment gap between
            IndexbleField instances using the same field name.  The default value
            position increment gap is 0.  With a 0 position increment gap and
            the typical default token position increment of 1, all terms in a field,
            including across IndexableField instances, are in successive positions, allowing
            exact PhraseQuery matches, for instance, across IndexableField instance boundaries.
            </summary>
            <param name="fieldName"> IndexableField name being indexed. </param>
            <returns> position increment gap, added to the next token emitted from <seealso cref="!:#tokenStream(String,Reader)"/>.
                    this value must be {@code &gt;= 0}. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetOffsetGap(System.String)">
            <summary>
            Just like <seealso cref="!:#getPositionIncrementGap"/>, except for
            Token offsets instead.  By default this returns 1.
            this method is only called if the field
            produced at least one token for indexing.
            </summary>
            <param name="fieldName"> the field just indexed </param>
            <returns> offset gap, added to the next token emitted from <seealso cref="!:#tokenStream(String,Reader)"/>.
                    this value must be {@code &gt;= 0}. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.Dispose">
            <summary>
            Frees persistent resources used by this Analyzer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.GLOBAL_REUSE_STRATEGY">
            <summary>
            A predefined <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/>  that reuses the same components for
            every field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY">
            <summary>
            A predefined <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of TokenStreamComponent per field name.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.Strategy">
            <summary>
            Returns the used <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents">
            <summary>
            this class encapsulates the outer components of a token stream. It provides
            access to the source (<seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Tokenizer"/>) and the outer end (sink), an
            instance of <seealso cref="T:Lucene.Net.Analysis.TokenFilter"/> which also serves as the
            <seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.TokenStream"/> returned by
            <seealso cref="!:Analyzer#tokenStream(String, Reader)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Source">
            <summary>
            Original source of the tokens.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Sink">
            <summary>
            Sink tokenstream, such as the outer tokenfilter decorating
            the chain. this can be the source if there are no filters.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.ReusableStringReader">
            <summary>
            Internal cache only used by <seealso cref="!:Analyzer#tokenStream(String, String)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
            <param name="result">
                     the analyzer's resulting token stream </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Analysis.Analyzer.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Reader">
            <summary>
            Resets the encapsulated components with the given reader. If the components
            cannot be reset, an Exception should be thrown.
            </summary>
            <param name="reader">
                     a reader to reset the source component </param>
            <exception cref="T:System.IO.IOException">
                      if the component's reset method throws an <seealso cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.TokenStream">
            <summary>
            Returns the sink <seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.TokenStream"/>
            </summary>
            <returns> the sink <seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.TokenStream"/> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Tokenizer">
            <summary>
            Returns the component's <seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Tokenizer"/>
            </summary>
            <returns> Component's <seealso cref="P:Lucene.Net.Analysis.Analyzer.TokenStreamComponents.Tokenizer"/> </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy">
            <summary>
            Strategy defining how TokenStreamComponents are reused per call to
            <seealso cref="!:Analyzer#tokenStream(String, java.io.Reader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReuseStrategy.GetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String)">
            <summary>
            Gets the reusable TokenStreamComponents for the field with the given name.
            </summary>
            <param name="analyzer"> Analyzer from which to get the reused components. Use
                   <seealso cref="!:#getStoredValue(Analyzer)"/> and <seealso cref="!:#setStoredValue(Analyzer, Object)"/>
                   to access the data on the Analyzer. </param>
            <param name="fieldName"> Name of the field whose reusable TokenStreamComponents
                   are to be retrieved </param>
            <returns> Reusable TokenStreamComponents for the field, or {@code null}
                    if there was no previous components for the field </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReuseStrategy.SetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String,Lucene.Net.Analysis.Analyzer.TokenStreamComponents)">
            <summary>
            Stores the given TokenStreamComponents as the reusable components for the
            field with the give name.
            </summary>
            <param name="fieldName"> Name of the field whose TokenStreamComponents are being set </param>
            <param name="components"> TokenStreamComponents which are to be reused for the field </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReuseStrategy.GetStoredValue(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Returns the currently stored value.
            </summary>
            <returns> Currently stored value or {@code null} if no value is stored </returns>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the Analyzer is closed. </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReuseStrategy.SetStoredValue(Lucene.Net.Analysis.Analyzer,System.Object)">
            <summary>
            Sets the stored value.
            </summary>
            <param name="storedValue"> Value to store </param>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the Analyzer is closed. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.GlobalReuseStrategy">
            <summary>
            Implementation of <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/> that reuses the same components for
            every field. </summary>
            @deprecated this implementation class will be hidden in Lucene 5.0.
              Use <seealso cref="!:Analyzer#GLOBAL_REUSE_STRATEGY"/> instead!
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.PerFieldReuseStrategy">
            <summary>
            Implementation of <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of TokenStreamComponent per field name. </summary>
            @deprecated this implementation class will be hidden in Lucene 5.0.
              Use <seealso cref="!:Analyzer#PER_FIELD_REUSE_STRATEGY"/> instead!
        </member>
        <member name="T:Lucene.Net.Analysis.AnalyzerWrapper">
            <summary>
            Extension to <seealso cref="T:Lucene.Net.Analysis.Analyzer"/> suitable for Analyzers which wrap
            other Analyzers.
            <p/>
            <seealso cref="!:#getWrappedAnalyzer(String)"/> allows the Analyzer
            to wrap multiple Analyzers which are selected on a per field basis.
            <p/>
            <seealso cref="!:#wrapComponents(String, Analyzer.TokenStreamComponents)"/> allows the
            TokenStreamComponents of the wrapped Analyzer to then be wrapped
            (such as adding a new <seealso cref="T:Lucene.Net.Analysis.TokenFilter"/> to form new TokenStreamComponents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor">
            <summary>
            Creates a new AnalyzerWrapper.  Since the <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/> of
            the wrapped Analyzers are unknown, <seealso cref="!:#PER_FIELD_REUSE_STRATEGY"/> is assumed. </summary>
            @deprecated Use <seealso cref="!:#AnalyzerWrapper(Analyzer.ReuseStrategy)"/>
            and specify a valid <seealso cref="T:Lucene.Net.Analysis.Analyzer.ReuseStrategy"/>, probably retrieved from the
            wrapped analyzer using <seealso cref="!:#getReuseStrategy()"/>.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor(Lucene.Net.Analysis.Analyzer.ReuseStrategy)" -->
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.GetWrappedAnalyzer(System.String)">
            <summary>
            Retrieves the wrapped Analyzer appropriate for analyzing the field with
            the given name
            </summary>
            <param name="fieldName"> Name of the field which is to be analyzed </param>
            <returns> Analyzer for the field with the given name.  Assumed to be non-null </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapComponents(System.String,Lucene.Net.Analysis.Analyzer.TokenStreamComponents)">
            <summary>
            Wraps / alters the given TokenStreamComponents, taken from the wrapped
            Analyzer, to form new components. It is through this method that new
            TokenFilters can be added by AnalyzerWrappers. By default, the given
            components are returned.
            </summary>
            <param name="fieldName">
                     Name of the field which is to be analyzed </param>
            <param name="components">
                     TokenStreamComponents taken from the wrapped Analyzer </param>
            <returns> Wrapped / altered TokenStreamComponents. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapReader(System.String,System.IO.TextReader)">
            <summary>
            Wraps / alters the given Reader. Through this method AnalyzerWrappers can
            implement <seealso cref="!:#initReader(String, Reader)"/>. By default, the given reader
            is returned.
            </summary>
            <param name="fieldName">
                     name of the field which is to be analyzed </param>
            <param name="reader">
                     the reader to wrap </param>
            <returns> the wrapped reader </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.CachingTokenFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenFilter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenStream" -->
        <member name="T:Lucene.Net.Util.AttributeSource">
            <summary>
            An AttributeSource contains a list of different <seealso cref="T:Lucene.Net.Util.Attribute"/>s,
            and methods to add and get them. There can only be a single instance
            of an attribute in the same AttributeSource instance. this is ensured
            by passing in the actual type of the Attribute (Class&lt;Attribute&gt;) to
            the <seealso cref="!:#addAttribute(Class)"/>, which then checks if an instance of
            that type is already present. If yes, it returns the instance, otherwise
            it creates a new instance and returns it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor">
            <summary>
            An AttributeSource using the default attribute factory <seealso cref="!:AttributeSource.AttributeFactory#DEFAULT_ATTRIBUTE_FACTORY"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            An AttributeSource that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            An AttributeSource using the supplied <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> for creating new <seealso cref="T:Lucene.Net.Util.Attribute"/> instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.KnownImplClasses">
            <summary>
            a cache that stores all interfaces for known implementation classes for performance (slow reflection) </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute)">
            <summary>
            <b>Expert:</b> Adds a custom Attribute instance with one or more Attribute interfaces.
            <p><font color="red"><b>Please note:</b> It is not guaranteed, that <code>att</code> is added to
            the <code>AttributeSource</code>, because the provided attributes may already exist.
            You should always retrieve the wanted attributes using <seealso cref="!:#getAttribute"/> after adding
            with this method and cast to your class.
            The recommended way to use custom implementations is using an <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </font></p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.HasAttributes">
            <summary>
            Returns true, iff this AttributeSource has any attributes </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.HasAttribute``1">
            <summary>
            The caller must pass in a Class&lt;? extends Attribute&gt; value.
            Returns true, iff this AttributeSource contains the passed-in Attribute.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttribute``1">
            <summary>
            The caller must pass in a Class&lt;? extends Attribute&gt; value.
            Returns the instance of the passed in Attribute contained in this AttributeSource
            </summary>
            <exception cref="!:IllegalArgumentException"> if this AttributeSource does not contain the
                    Attribute. It is recommended to always use <seealso cref="!:#addAttribute"/> even in consumers
                    of TokenStreams, because you cannot know if a specific TokenStream really uses
                    a specific Attribute. <seealso cref="!:#addAttribute"/> will automatically make the attribute
                    available. If you want to only use the attribute, if it is available (to optimize
                    consuming), use <seealso cref="!:#HasAttribute"/>. </exception>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ClearAttributes">
            <summary>
            Resets all Attributes in this AttributeSource by calling
            <seealso cref="!:Attribute#clear()"/> on each Attribute implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CaptureState">
            <summary>
            Captures the state of all Attributes. The return value can be passed to
            <seealso cref="!:#restoreState"/> to restore the state of this or another AttributeSource.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ReflectAsString(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector)" -->
        <member name="M:Lucene.Net.Util.AttributeSource.CloneAttributes">
            <summary>
            Performs a clone of all <seealso cref="T:Lucene.Net.Util.Attribute"/> instances returned in a new
            {@code AttributeSource} instance. this method can be used to e.g. create another TokenStream
            with exactly the same attributes (using <seealso cref="!:#AttributeSource(AttributeSource)"/>).
            You can also use it as a (non-performant) replacement for <seealso cref="!:#captureState"/>, if you need to look
            into / modify the captured state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource)">
            <summary>
            Copies the contents of this {@code AttributeSource} to the given target {@code AttributeSource}.
            The given instance has to provide all <seealso cref="T:Lucene.Net.Util.Attribute"/>s this instance contains.
            The actual attribute implementations must be identical in both {@code AttributeSource} instances;
            ideally both AttributeSource instances should use the same <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            You can use this method as a replacement for <seealso cref="!:#restoreState"/>, if you use
            <seealso cref="!:#cloneAttributes"/> instead of <seealso cref="!:#captureState"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ToString" -->
        <member name="P:Lucene.Net.Util.AttributeSource.attributeFactory">
            <summary>
            returns the used AttributeFactory.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.AttributeSource.AttributeClassesIterator">
            <summary>
            Returns a new iterator that iterates the attribute classes
            in the same order they were added in.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.AttributeSource.AttributeImplsIterator">
            <summary>
            Returns a new iterator that iterates all unique Attribute implementations.
            this iterator may contain less entries that <seealso cref="!:#getAttributeClassesIterator"/>,
            if one instance implements more than one Attribute interface.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource.AttributeFactory">
            <summary>
            An AttributeFactory creates instances of <seealso cref="T:Lucene.Net.Util.Attribute"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AttributeFactory.CreateAttributeInstance``1">
            <summary>
            returns an <seealso cref="T:Lucene.Net.Util.Attribute"/> for the supplied <seealso cref="T:Lucene.Net.Util.Attribute"/> interface class.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY">
            <summary>
            this is the default factory that creates <seealso cref="T:Lucene.Net.Util.Attribute"/>s using the
            class name of the supplied <seealso cref="T:Lucene.Net.Util.Attribute"/> interface class by appending <code>Impl</code> to it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.AttributeSource.State" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor">
            <summary>
            A TokenStream using the default attribute factory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            A TokenStream that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            A TokenStream using the supplied AttributeFactory for creating new <seealso cref="T:Lucene.Net.Util.Attribute"/> instances.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.IncrementToken" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.End" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.Reset" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.Dispose" -->
        <member name="F:Lucene.Net.Analysis.TokenFilter.input">
            <summary>
            The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Construct a token stream filtering the given input. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenFilter.End" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenFilter.Dispose" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenFilter.Reset" -->
        <member name="M:Lucene.Net.Analysis.CachingTokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Create a new CachingTokenFilter around <code>input</code>,
            caching its token attributes, which can be replayed again
            after a call to <seealso cref="!:#reset()"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.CachingTokenFilter.Reset" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.CharFilter" -->
        <member name="F:Lucene.Net.Analysis.CharFilter.input">
            <summary>
            The underlying character-input stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.#ctor(System.IO.TextReader)">
            <summary>
            Create a new CharFilter wrapping the provided reader. </summary>
            <param name="input"> a Reader, can also be a CharFilter for chaining. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.CharFilter.Close" -->
        <member name="M:Lucene.Net.Analysis.CharFilter.Correct(System.Int32)">
            <summary>
            Subclasses override to correct the current offset.
            </summary>
            <param name="currentOff"> current offset </param>
            <returns> corrected offset </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)">
            <summary>
            Chains the corrected offset through the input
            CharFilter(s).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.NumericTokenStream" -->
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_FULL_PREC">
            <summary>
            The full precision token gets this token type assigned. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_LOWER_PREC">
            <summary>
            The lower precision tokens gets this token type assigned. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor">
            <summary>
            Creates a token stream for numeric values using the default <code>precisionStep</code>
            <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4). The stream is not yet initialized,
            before using set a value using the various set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(System.Int32)">
            <summary>
            Creates a token stream for numeric values with the specified
            <code>precisionStep</code>. The stream is not yet initialized,
            before using set a value using the various set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.Int32)">
            <summary>
            Expert: Creates a token stream for numeric values with the specified
            <code>precisionStep</code> using the given
            <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            The stream is not yet initialized,
            before using set a value using the various set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetLongValue(System.Int64)">
            <summary>
            Initializes the token stream with the supplied <code>long</code> value. </summary>
            <param name="value"> the value, for which this TokenStream should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).setLongValue(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetIntValue(System.Int32)">
            <summary>
            Initializes the token stream with the supplied <code>int</code> value. </summary>
            <param name="value"> the value, for which this TokenStream should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).setIntValue(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetDoubleValue(System.Double)">
            <summary>
            Initializes the token stream with the supplied <code>double</code> value. </summary>
            <param name="value"> the value, for which this TokenStream should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).setDoubleValue(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetFloatValue(System.Single)">
            <summary>
            Initializes the token stream with the supplied <code>float</code> value. </summary>
            <param name="value"> the value, for which this TokenStream should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).setFloatValue(value))</code> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute">
            <summary>
            <b>Expert:</b> Use this attribute to get the details of the currently generated token.
            @lucene.experimental
            @since 4.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IAttribute">
            <summary> Base interface for attributes.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Init(System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.IncShift">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Shift">
            <summary>
            Returns current shift value, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.RawValue">
            <summary>
            Returns current token's raw value as {@code long} with all <seealso cref="!:#getShift"/> applied, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.ValueSize">
            <summary>
            Returns value size in bits (32 for {@code float}, {@code int}; 64 for {@code double}, {@code long}) </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute">
            <summary>
            Implementation of <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute"/>.
            @lucene.internal
            @since 4.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute">
            <summary> Base class for Attributes that can be added to a
            <see cref="T:Lucene.Net.Util.AttributeSource"/>.
            <p/>
            Attributes are used to add data in a dynamic, yet type-safe way to a source
            of usually streamed objects, e. g. a <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clear">
            <summary> Clears the values in this Attribute and resets it to its
            default value. If this implementation implements more than one Attribute interface
            it clears all.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.ToString">
             <summary> The default implementation of this method accesses all declared
             fields of this object and prints the values in the following syntax:
            
             <code>
             public String toString() {
             return "start=" + startOffset + ",end=" + endOffset;
             }
             </code>
            
             This method may be overridden by subclasses.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.CopyTo(Lucene.Net.Util.Attribute)">
            <summary> Copies the values from this Attribute into the passed-in
            target attribute. The target implementation must support all the
            Attributes this implementation supports.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clone">
            <summary> Shallow clone. Subclasses must override this if they
            need to clone any members deeply,
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute.StringBuilderAttributeReflector">
            <summary>
            This is equivalent to the anonymous class in the java version of ReflectWithString
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenattributes.ITermToBytesRefAttribute" -->
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermToBytesRefAttribute.FillBytesRef">
            <summary>
            Updates the bytes <seealso cref="!:#getBytesRef()"/> to contain this term's
            final encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Tokenattributes.ITermToBytesRefAttribute.BytesRef">
            <summary>
            Retrieve this attribute's BytesRef. The bytes are updated
            from the current term when the consumer calls <seealso cref="!:#fillBytesRef()"/>. </summary>
            <returns> this Attributes internal BytesRef. </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.ReusableStringReader">
            <summary>
            Internal class to enable reuse of the string reader by <seealso cref="!:Analyzer#tokenStream(String,String)"/> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Token" -->
        <member name="T:Lucene.Net.Analysis.Tokenattributes.CharTermAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.CharTermAttribute"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute">
            <summary>
            The term text of a Token.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of buffer, starting at offset for
             length characters, into the termBuffer array. </summary>
             <param name="buffer"> the buffer to copy </param>
             <param name="offset"> the index in the buffer of the first character to copy </param>
             <param name="length"> the number of characters to copy </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer" -->
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.ResizeBuffer(System.Int32)">
            <summary>
            Grows the termBuffer to at least size newSize, preserving the
             existing content. </summary>
             <param name="newSize"> minimum size of the new termBuffer </param>
             <returns> newly created termBuffer with length >= newSize </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.SetLength(System.Int32)">
            <summary>
            Set number of valid characters (length of the term) in
             the termBuffer array. Use this to truncate the termBuffer
             or to synchronize with external manipulation of the termBuffer.
             Note: to grow the size of the array,
             use <seealso cref="!:#resizeBuffer(int)"/> first. </summary>
             <param name="length"> the truncated length </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.SetEmpty">
            <summary>
            Sets the length of the termBuffer to zero.
            Use this method before appending contents
            using the <seealso cref="!:Appendable"/> interface.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Append(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Append(System.Text.StringBuilder)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Append(Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute)" -->
        <member name="M:Lucene.Net.Analysis.Tokenattributes.CharTermAttribute.#ctor">
            <summary>
            Initialize this attribute with empty term text </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.CharTermAttribute.ToString" -->
        <member name="T:Lucene.Net.Analysis.Tokenattributes.ITypeAttribute">
            <summary>
            A Token's lexical type. The Default value is "word".
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Tokenattributes.ITypeAttribute.Type" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenattributes.IPositionIncrementAttribute" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Tokenattributes.IPositionIncrementAttribute.PositionIncrement" -->
        <member name="T:Lucene.Net.Analysis.Tokenattributes.IFlagsAttribute">
            <summary> This attribute can be used to pass different flags down the <see cref="T:Lucene.Net.Analysis.Tokenizer"/> chain,
            eg from one TokenFilter to another one.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Tokenattributes.IFlagsAttribute.Flags">
             <summary> EXPERIMENTAL:  While we think this is here to stay, we may want to change it to be a long.
             <p/>
            
             Get the bitset for any bits that have been set.  This is completely distinct from <see cref="P:Lucene.Net.Analysis.Tokenattributes.ITypeAttribute.Type"/>, although they do share similar purposes.
             The flags can be used to encode information about the token for use by other <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s.
            
            
             </summary>
             <value> The bits </value>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute">
            <summary>
            The start and end character offset of a Token.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.StartOffset" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenattributes.IPayloadAttribute" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Tokenattributes.IPayloadAttribute.Payload" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenattributes.IPositionLengthAttribute" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Tokenattributes.IPositionLengthAttribute.PositionLength" -->
        <member name="M:Lucene.Net.Analysis.Token.#ctor">
            <summary>
            Constructs a Token will null text. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.StartOffset" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.EndOffset" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.Clear">
            <summary>
            Resets the term text, payload, flags, and positionIncrement,
            startOffset, endOffset and token type to default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.Clone(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#copyBuffer(char[], int, int)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#copyBuffer(char[], int, int)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> on Token.DEFAULT_TYPE </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#append(CharSequence)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#append(CharSequence, int, int)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#append(CharSequence)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> on Token.DEFAULT_TYPE </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <seealso cref="!:#clear"/>,
             <seealso cref="!:#append(CharSequence, int, int)"/>,
             <seealso cref="!:#setOffset"/>,
             <seealso cref="!:#setType"/> on Token.DEFAULT_TYPE </summary>
             <returns> this Token instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token)">
            <summary>
            Copy the prototype token's fields into this one. Note: Payloads are shared. </summary>
            <param name="prototype"> source Token to copy fields from </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.String)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing Token </param>
            <param name="newTerm"> new term text </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing Token </param>
            <param name="newTermBuffer"> buffer containing new term text </param>
            <param name="offset"> the index in the buffer of the first character </param>
            <param name="length"> number of valid characters in the buffer </param>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.TOKEN_ATTRIBUTE_FACTORY">
            <summary>
            Convenience factory that returns <code>Token</code> as implementation for the basic
            attributes and return the default impl (with &quot;Impl&quot; appended) for all other
            attributes.
            @since 3.0
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Token.PositionIncrement" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Token.PositionLength" -->
        <member name="P:Lucene.Net.Analysis.Token.Type">
            <summary>Returns this Token's lexical type.  Defaults to "word". </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Token.Flags" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Token.Payload" -->
        <member name="T:Lucene.Net.Analysis.Token.TokenAttributeFactory">
            <summary>
            <b>Expert:</b> Creates a TokenAttributeFactory returning <seealso cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            @since 3.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TokenAttributeFactory.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            <b>Expert</b>: Creates an AttributeFactory returning <seealso cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.FlagsAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.FlagsAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.FlagsAttribute.#ctor">
            <summary>
            Initialize this attribute with no bits set </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.ITermAttribute">
            <summary> The term text of a Token.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array.
            </summary>
            <param name="buffer">the buffer to copy
            </param>
            <param name="offset">the index in the buffer of the first character to copy
            </param>
            <param name="length">the number of characters to copy
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.String)">
            <summary>Copies the contents of buffer into the termBuffer array.</summary>
            <param name="buffer">the buffer to copy
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.String,System.Int32,System.Int32)">
            <summary>Copies the contents of buffer, starting at offset and continuing
            for length characters, into the termBuffer array.
            </summary>
            <param name="buffer">the buffer to copy
            </param>
            <param name="offset">the index in the buffer of the first character to copy
            </param>
            <param name="length">the number of characters to copy
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.TermBuffer">
            <summary>Returns the internal termBuffer character array which
            you can then directly alter.  If the array is too
            small for your token, use <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.ResizeTermBuffer(System.Int32)"/>
            to increase it.  After
            altering the buffer be sure to call <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermLength(System.Int32)"/>
            to record the number of valid
            characters that were placed into the termBuffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.ResizeTermBuffer(System.Int32)">
            <summary>Grows the termBuffer to at least size newSize, preserving the
            existing content. Note: If the next operation is to change
            the contents of the term buffer use
            <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.Char[],System.Int32,System.Int32)"/>,
            <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.String)"/>, or
            <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermBuffer(System.String,System.Int32,System.Int32)"/>
            to optimally combine the resize with the setting of the termBuffer.
            </summary>
            <param name="newSize">minimum size of the new termBuffer
            </param>
            <returns> newly created termBuffer with length &gt;= newSize
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.TermLength">
            <summary>Return number of valid characters (length of the term)
            in the termBuffer array.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.SetTermLength(System.Int32)">
            <summary>Set number of valid characters (length of the term) in
            the termBuffer array. Use this to truncate the termBuffer
            or to synchronize with external manipulation of the termBuffer.
            Note: to grow the size of the array,
            use <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.ResizeTermBuffer(System.Int32)"/> first.
            </summary>
            <param name="length">the truncated length
            </param>
        </member>
        <member name="P:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.Term">
             <summary>Returns the Token's term text.
            
             This method has a performance penalty
             because the text is stored internally in a char[].  If
             possible, use <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.TermBuffer"/> and <see cref="M:Lucene.Net.Analysis.Tokenattributes.ITermAttribute.TermLength"/>
             directly instead.  If you really need a
             String, use this method, which is nothing more than
             a convenience call to <b>new String(token.termBuffer(), 0, token.termLength())</b>
             </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.IKeywordAttribute">
            <summary>
            this attribute can be used to mark a token as a keyword. Keyword aware
            <seealso cref="T:Lucene.Net.Analysis.TokenStream"/>s can decide to modify a token based on the return value
            of <seealso cref="!:#isKeyword()"/> if the token is modified. Stemming filters for
            instance can use this attribute to conditionally skip a term if
            <seealso cref="!:#isKeyword()"/> returns <code>true</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.Tokenattributes.IKeywordAttribute.Keyword" -->
        <member name="T:Lucene.Net.Analysis.Tokenattributes.KeywordAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.KeywordAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.KeywordAttribute.#ctor">
            <summary>
            Initialize this attribute with the keyword value as false. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.OffsetAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.OffsetAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.OffsetAttribute.#ctor">
            <summary>
            Initialize this attribute with startOffset and endOffset of 0. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.PayloadAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.PayloadAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.PayloadAttribute.#ctor">
            <summary>
            Initialize this attribute with no payload.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.PayloadAttribute.#ctor(Lucene.Net.Util.BytesRef)">
            <summary>
            Initialize this attribute with the given payload.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.PositionIncrementAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.PositionIncrementAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.PositionIncrementAttribute.#ctor">
            <summary>
            Initialize this attribute with position increment of 1 </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.PositionLengthAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.PositionLengthAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.PositionLengthAttribute.#ctor">
            <summary>
            Initializes this attribute with position length of 1. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenattributes.TypeAttribute">
            <summary>
            Default implementation of <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.TypeAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.TypeAttribute.#ctor">
            <summary>
            Initialize this attribute with <seealso cref="!:TypeAttribute#DEFAULT_TYPE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenattributes.TypeAttribute.#ctor(System.String)">
            <summary>
            Initialize this attribute with <code>type</code> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenizer" -->
        <member name="F:Lucene.Net.Analysis.Tokenizer.input">
            <summary>
            The text source for this Tokenizer. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.InputPending">
            <summary>
            Pending reader: not actually assigned to input until reset() </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input using the given AttributeFactory. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Tokenizer.Dispose" -->
        <member name="M:Lucene.Net.Analysis.Tokenizer.CorrectOffset(System.Int32)">
            <summary>
            Return the corrected offset. If <seealso cref="!:#input"/> is a <seealso cref="T:Lucene.Net.Analysis.CharFilter"/> subclass
            this method calls <seealso cref="!:CharFilter#correctOffset"/>, else returns <code>currentOff</code>. </summary>
            <param name="currentOff"> offset as seen in the output </param>
            <returns> corrected offset based on the input </returns>
            <seealso> cref= CharFilter#correctOffset </seealso>
        </member>
        <member name="P:Lucene.Net.Analysis.Tokenizer.Reader">
            <summary>
            Expert: Set a new reader on the Tokenizer.  Typically, an
             analyzer (in its tokenStream method) will use
             this to re-use a previously created tokenizer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStreamToAutomaton">
             <summary>
             Consumes a TokenStream and creates an <seealso cref="T:Lucene.Net.Util.Automaton.Automaton"/>
              where the transition labels are UTF8 bytes (or Unicode
              code points if unicodeArcs is true) from the {@link
              TermToBytesRefAttribute}.  Between tokens we insert
              POS_SEP and for holes we insert HOLE.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.POS_SEP">
            <summary>
            We create transition between two adjacent tokens. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.HOLE">
            <summary>
            We add this arc to represent a hole. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStreamToAutomaton.ChangeToken(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.ToAutomaton(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Pulls the graph (including {@link
             PositionLengthAttribute}) from the provided {@link
             TokenStream}, and creates the corresponding
             automaton where arcs are bytes (or Unicode code points
             if unicodeArcs = true) from each term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.PreservePositionIncrements">
            <summary>
            Whether to generate holes in the automaton for missing positions, <code>true</code> by default. </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.UnicodeArcs">
            <summary>
            Whether to make transition labels Unicode code points instead of UTF8 bytes,
             <code>false</code> by default
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RollingBuffer`1">
             <summary>
             Acts like forever growing T[], but internally uses a
              circular buffer to reuse instances of T.
            
              @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RollingBuffer`1.Get(System.Int32)">
            <summary>
            Get T instance for this absolute position;
             this is allowed to be arbitrarily far "in the
             future" but cannot be before the last freeBefore.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RollingBuffer`1.MaxPos">
            <summary>
            Returns the maximum position looked up, or -1 if no
             position has been looked up sinc reset/init.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTermState">
            <summary>
            Holds all state required for <seealso cref="T:Lucene.Net.Codecs.PostingsReaderBase"/>
            to produce a <seealso cref="T:Lucene.Net.Index.DocsEnum"/> without re-seeking the
            terms dict.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.OrdTermState">
             <summary>
             An ordinal based <seealso cref="T:Lucene.Net.Index.TermState"/>
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermState" -->
        <member name="M:Lucene.Net.Index.TermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermState.CopyFrom(Lucene.Net.Index.TermState)">
            <summary>
            Copies the content of the given <seealso cref="T:Lucene.Net.Index.TermState"/> to this instance
            </summary>
            <param name="other">
                     the TermState to copy </param>
        </member>
        <member name="F:Lucene.Net.Index.OrdTermState.Ord">
            <summary>
            Term ordinal, i.e. it's position in the full list of
             sorted terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.OrdTermState.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTermState.DocFreq">
            <summary>
            how many docs have this term </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTermState.TotalTermFreq">
            <summary>
            total number of occurrences of this term </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTermState.TermBlockOrd">
            <summary>
            the term's ord in the current block </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTermState.BlockFilePointer">
            <summary>
            fp into the terms dict primary file (_X.tim) that holds this term </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.BlockTreeTermsReader" -->
        <member name="T:Lucene.Net.Codecs.FieldsProducer">
             <summary>
             Abstract API that produces terms, doc, freq, prox, offset and
              payloads postings.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.Fields">
            <summary>
            Flex API for access to fields and terms
             @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.GetEnumerator">
            <summary>
            Returns an iterator that will step through all fields
             names.  this will not return null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.Terms(System.String)">
            <summary>
            Get the <seealso cref="M:Lucene.Net.Index.Fields.Terms(System.String)"/> for this field.  this will return
             null if the field does not exist.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.Fields.EMPTY_ARRAY">
            <summary>
            Zero-length {@code Fields} array.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Fields.Size">
            <summary>
            Gets the number of fields or -1 if the number of
            distinct field names is unknown. If &gt;= 0,
            <seealso cref="!:#iterator"/> will return as many field names.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.Fields.UniqueTermCount" -->
        <member name="M:Lucene.Net.Codecs.FieldsProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.FieldsProducer.CheckIntegrity" -->
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.DirOffset">
            <summary>
            File offset where the directory starts in the terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.IndexDirOffset">
            <summary>
            File offset where the directory starts in the index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Codecs.PostingsReaderBase,Lucene.Net.Store.IOContext,System.String,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadIndexHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.SeekDir(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Seek {@code input} to the directory offset. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.Stats">
            <summary>
            BlockTree statistics for a single field
            returned by <seealso cref="!:FieldReader#computeStats()"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNodeCount">
            <summary>
            How many nodes in the index FST. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexArcCount">
            <summary>
            How many arcs in the index FST. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNumBytes">
            <summary>
            Byte size of the index. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermCount">
            <summary>
            Total number of terms in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermBytes">
            <summary>
            Total number of bytes (sum of term lengths) across all terms in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.NonFloorBlockCount">
            <summary>
            The number of normal (non-floor) blocks in the terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorBlockCount">
            <summary>
            The number of floor blocks (meta-blocks larger than the
             allowed {@code maxItemsPerBlock}) in the terms file.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorSubBlockCount">
            <summary>
            The number of sub-blocks within the floor blocks. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.MixedBlockCount">
            <summary>
            The number of "internal" blocks (that have both
             terms and sub-blocks).
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TermsOnlyBlockCount">
            <summary>
            The number of "leaf" blocks (blocks that have only
             terms).
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.SubBlocksOnlyBlockCount">
            <summary>
            The number of "internal" blocks that do not contain
             terms (have only sub-blocks).
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockCount">
            <summary>
            Total number of blocks. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.BlockCountByPrefixLen">
            <summary>
            Number of blocks at each prefix depth. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockSuffixBytes">
            <summary>
            Total number of bytes used to store term suffixes. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockStatsBytes">
            <summary>
            Total number of bytes used to store term stats (not
             including what the <seealso cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>
             stores.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockOtherBytes">
            <summary>
            Total bytes stored by the <seealso cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>,
             plus the other few vInts stored in the frame.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Segment">
            <summary>
            Segment name. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Field">
            <summary>
            Field name. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader">
            <summary>
            BlockTree's implementation of <seealso cref="M:Lucene.Net.Codecs.BlockTreeTermsReader.Terms(System.String)"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Index.Terms">
            <summary>
            Access to the terms in a specific field.  See <seealso cref="T:Lucene.Net.Index.Fields"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.Iterator(Lucene.Net.Index.TermsEnum)">
            <summary>
            Returns an iterator that will step through all
             terms. this method will not return null.  If you have
             a previous TermsEnum, for example from a different
             field, you can pass it for possible reuse if the
             implementation can do so.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)">
             <summary>
             Returns a TermsEnum that iterates over all terms that
              are accepted by the provided {@link
              CompiledAutomaton}.  If the <code>startTerm</code> is
              provided then the returned enum will only accept terms
              > <code>startTerm</code>, but you still must call
              next() first to get to the first term.  Note that the
              provided <code>startTerm</code> must be accepted by
              the automaton.
            
             <p><b>NOTE</b>: the returned TermsEnum cannot
             seek</p>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.Size">
            <summary>
            Returns the number of terms for this field, or -1 if this
             measure isn't stored by the codec. Note that, just like
             other term measures, this measure does not take deleted
             documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.HasFreqs">
            <summary>
            Returns true if documents in this field store
             per-document term frequency (<seealso cref="!:DocsEnum#freq"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.HasOffsets">
            <summary>
            Returns true if documents in this field store offsets. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.HasPositions">
            <summary>
            Returns true if documents in this field store positions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.HasPayloads">
            <summary>
            Returns true if documents in this field store payloads. </summary>
        </member>
        <member name="F:Lucene.Net.Index.Terms.EMPTY_ARRAY">
            <summary>
            Zero-length array of <seealso cref="T:Lucene.Net.Index.Terms"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.Terms.Comparator" -->
        <member name="P:Lucene.Net.Index.Terms.SumTotalTermFreq">
            <summary>
            Returns the sum of <seealso cref="!:TermsEnum#totalTermFreq"/> for
             all terms in this field, or -1 if this measure isn't
             stored by the codec (or if this fields omits term freq
             and positions).  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.SumDocFreq">
            <summary>
            Returns the sum of <seealso cref="!:TermsEnum#docFreq()"/> for
             all terms in this field, or -1 if this measure isn't
             stored by the codec.  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.DocCount">
            <summary>
            Returns the number of documents that have at least one
             term for this field, or -1 if this measure isn't
             stored by the codec.  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.AutomatonTermsEnum" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FilteredTermsEnum" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermsEnum" -->
        <member name="T:Lucene.Net.Util.BytesRefIterator">
            <summary>
            A simple iterator interface for <seealso cref="T:Lucene.Net.Util.BytesRef"/> iteration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefIterator.Next">
            <summary>
            Increments the iteration to the next <seealso cref="T:Lucene.Net.Util.BytesRef"/> in the iterator.
            Returns the resulting <seealso cref="T:Lucene.Net.Util.BytesRef"/> or <code>null</code> if the end of
            the iterator is reached. The returned BytesRef may be re-used across calls
            to next. After this method returns null, do not call it again: the results
            are undefined.
            </summary>
            <returns> the next <seealso cref="T:Lucene.Net.Util.BytesRef"/> in the iterator or <code>null</code> if
                    the end of the iterator is reached. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.BytesRefIterator.Comparator" -->
        <member name="M:Lucene.Net.Index.TermsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Attempts to seek to the exact term, returning
             true if the term is found.  If this returns false, the
             enum is unpositioned.  For some codecs, seekExact may
             be substantially faster than <seealso cref="!:#seekCeil"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to the specified term, if it exists, or to the
             next (ceiling) term.  Returns SeekStatus to
             indicate whether exact term was found, a different
             term was found, or EOF was hit.  The target term may
             be before or after the current term.  If this returns
             SeekStatus.END, the enum is unpositioned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(System.Int64)">
            <summary>
            Seeks to the specified term by ordinal (position) as
             previously returned by <seealso cref="!:#ord"/>.  The target ord
             may be before or after the current ord, and must be
             within bounds.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)" -->
        <member name="M:Lucene.Net.Index.TermsEnum.Term">
            <summary>
            Returns current term. Do not call this when the enum
             is unpositioned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Ord">
            <summary>
            Returns ordinal position for current term.  this is an
             optional method (the codec may throw {@link
             UnsupportedOperationException}).  Do not call this
             when the enum is unpositioned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.DocFreq">
            <summary>
            Returns the number of documents containing the current
             term.  Do not call this when the enum is unpositioned.
             <seealso cref="!:SeekStatus#END"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term
             across all documents (the sum of the freq() for each
             doc that has this term).  this will be -1 if the
             codec doesn't support this measure.  Note that, like
             other term measures, this measure does not take
             deleted documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.Bits,Lucene.Net.Index.DocsEnum)">
            <summary>
            Get <seealso cref="T:Lucene.Net.Index.DocsEnum"/> for the current term.  Do not
             call this when the enum is unpositioned.  this method
             will not return null.
            </summary>
            <param name="liveDocs"> unset bits are documents that should not
            be returned </param>
            <param name="reuse"> pass a prior DocsEnum for possible reuse  </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.Bits,Lucene.Net.Index.DocsEnum,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.Bits,Lucene.Net.Index.DocsAndPositionsEnum)" -->
        <member name="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.Bits,Lucene.Net.Index.DocsAndPositionsEnum,System.Int32)">
            <summary>
            Get <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term,
             with control over whether offsets and payloads are
             required.  Some codecs may be able to optimize their
             implementation when offsets and/or payloads are not required.
             Do not call this when the enum is unpositioned.  this
             will return null if positions were not indexed.
            </summary>
             <param name="liveDocs"> unset bits are documents that should not
             be returned </param>
             <param name="reuse"> pass a prior DocsAndPositionsEnum for possible reuse </param>
             <param name="flags"> specifies which optional per-position values you
                    require; see <seealso cref="!:DocsAndPositionsEnum#FLAG_OFFSETS"/> and
                    <seealso cref="!:DocsAndPositionsEnum#FLAG_PAYLOADS"/>.  </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsEnum.TermState" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.TermsEnum.EMPTY" -->
        <member name="T:Lucene.Net.Index.TermsEnum.SeekStatus">
            <summary>
            Represents returned result from <seealso cref="!:#seekCeil"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.END">
            <summary>
            The term was not found, and the end of iteration was hit. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.FOUND">
            <summary>
            The precise term was found. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.NOT_FOUND">
            <summary>
            A different term was found after the requested term </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Return if term is accepted, not accepted or the iteration should ended
            (and possibly seek).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,System.Boolean)">
            <summary>
            Creates a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.Attributes">
            <summary>
            Returns the related attributes, the returned <seealso cref="T:Lucene.Net.Util.AttributeSource"/>
            is shared with the delegate {@code TermsEnum}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="!:UnsupportedOperationException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="!:UnsupportedOperationException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(System.Int64)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="!:UnsupportedOperationException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="!:UnsupportedOperationException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.TermState">
            <summary>
            Returns the filtered enums term state
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.FilteredTermsEnum.InitialSeekTerm" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus" -->
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES">
            <summary>
            Accept the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES_AND_SEEK">
            <summary>
            Accept the term and advance (<seealso cref="!:FilteredTermsEnum#nextSeekTerm(BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO">
            <summary>
            Reject the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO_AND_SEEK">
            <summary>
            Reject the term and advance (<seealso cref="!:FilteredTermsEnum#nextSeekTerm(BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.END">
            <summary>
            Reject the term and stop enumerating. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.AutomatonTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.Automaton.CompiledAutomaton)" -->
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns true if the term matches the automaton. Also stashes away the term
            to assist with smart enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString">
             <summary>
             Increments the byte buffer to the next String in binary order after s that will not put
             the machine into a reject state. If such a string does not exist, returns
             false.
            
             The correctness of this method depends upon the automaton being deterministic,
             and having no transitions to dead states.
             </summary>
             <returns> true if more possible solutions exist for the DFA </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString(System.Int32,System.Int32)">
             <summary>
             Returns the next String in lexicographic order that will not put
             the machine into a reject state.
            
             this method traverses the DFA from the given position in the String,
             starting at the given state.
            
             If this cannot satisfy the machine, returns false. this method will
             walk the minimal path, in lexicographic order, as long as possible.
            
             If this method returns false, then there might still be more solutions,
             it is necessary to backtrack to find out.
             </summary>
             <param name="state"> current non-reject state </param>
             <param name="position"> useful portion of the string </param>
             <returns> true if more possible solutions exist for the DFA from this
                     position </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Backtrack(System.Int32)">
            <summary>
            Attempts to backtrack thru the string after encountering a dead end
            at some given position. Returns false if no more possible strings
            can match.
            </summary>
            <param name="position"> current position in the input String </param>
            <returns> position >=0 if more possible solutions exist for the DFA </returns>
        </member>
        <member name="P:Lucene.Net.Index.AutomatonTermsEnum.Linear">
            <summary>
            Sets the enum to operate in linear fashion, as we have found
            a looping transition at position: we set an upper bound and
            act like a TermRangeQuery for this portion of the term space.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.ComputeStats">
            <summary>
            For debugging -- used by CheckIndex too </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.ComputeBlockStats">
            <summary>
            Runs next() through the entire terms dict,
             computing aggregate statistics.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.BlockTreeTermsWriter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.FieldsConsumer" -->
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.AddField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Add a new field </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Dispose">
            <summary>
            Called when we are done adding everything. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.Fields)">
            <summary>
            Called during merging to merge all <seealso cref="T:Lucene.Net.Index.Fields"/> from
             sub-readers.  this must recurse to merge all postings
             (terms, docs, positions, etc.).  A {@link
             PostingsFormat} can override this default
             implementation to do its own merging.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE">
            <summary>
            Suggested default value for the {@code
             minItemsInBlock} parameter to {@link
             #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE">
            <summary>
            Suggested default value for the {@code
             maxItemsInBlock} parameter to {@link
             #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_EXTENSION">
            <summary>
            Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_START">
            <summary>
            Initial terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_APPEND_ONLY">
            <summary>
            Append-only </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_META_ARRAY">
            <summary>
            Meta data as array </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CHECKSUM">
            <summary>
            checksums </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CURRENT">
            <summary>
            Current terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)">
            <summary>
            Create a new writer.  The number of items (terms or
             sub-blocks) per block will aim to be between
             minItemsPerBlock and maxItemsPerBlock, though in some
             cases the blocks may be smaller than the min.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the terms file trailer. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the index file trailer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermsConsumer" -->
        <member name="M:Lucene.Net.Codecs.TermsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.StartTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            Starts a new term in this field; this may be called
             with no corresponding call to finish if the term had
             no docs.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.FinishTerm(Lucene.Net.Util.BytesRef,Lucene.Net.Codecs.TermStats)">
            <summary>
            Finishes the current term; numDocs must be > 0.
             <code>stats.totalTermFreq</code> will be -1 when term
             frequencies are omitted for the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Finish(System.Int64,System.Int64,System.Int32)">
            <summary>
            Called when we are done adding terms to this field.
             <code>sumTotalTermFreq</code> will be -1 when term
             frequencies are omitted for the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Merge(Lucene.Net.Index.MergeState,System.Nullable{Lucene.Net.Index.FieldInfo.IndexOptions},Lucene.Net.Index.TermsEnum)">
            <summary>
            Default merge impl </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermsConsumer.Comparator">
            <summary>
            Return the BytesRef Comparator used to sort terms
             before feeding to this API.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1.FreezeTail`1">
            <summary>
            Expert: this is invoked by Builder whenever a suffix
             is serialized.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Fst.Builder`1" -->
        <member name="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Instantiates an FST/FSA builder without any pruning. A shortcut
            to {@link #Builder(FST.INPUT_TYPE, int, int, boolean,
            boolean, int, Outputs, FreezeTail, boolean, float,
            boolean, int)} with pruning options turned off.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,Lucene.Net.Util.Fst.Outputs{`0},Lucene.Net.Util.Fst.Builder{`0}.FreezeTail{`0},System.Boolean,System.Single,System.Boolean,System.Int32)" -->
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Add(Lucene.Net.Util.IntsRef,`0)">
            <summary>
            It's OK to add the same input twice in a row with
             different outputs, as long as outputs impls the merge
             method. Note that input is fully consumed after this
             method is returned (so caller is free to reuse), but
             output is not.  So if your outputs are changeable (eg
             <seealso cref="T:Lucene.Net.Util.Fst.ByteSequenceOutputs"/> or {@link
             IntSequenceOutputs}) then you cannot reuse across
             calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Finish">
            <summary>
            Returns final FST.  NOTE: this will return null if
             nothing is accepted by the FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1.FreezeTail`1">
            <summary>
            Expert: this is invoked by Builder whenever a suffix
             is serialized.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1.Arc`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) arc. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) Node. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1.Depth">
            <summary>
            this node's depth, starting from the automaton root. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1.#ctor(Lucene.Net.Util.Fst.Builder{`1},System.Int32)">
            <param name="depth">
                     The node's depth starting from the automaton root. Needed for
                     LUCENE-2934 (node expansion based on conditions other than the
                     fanout size). </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Codec" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.NamedSPILoader`1.NamedSPI" -->
        <member name="T:Lucene.Net.Util.NamedSPILoader`1">
            <summary>
            Helper class for loading named SPIs from classpath (e.g. Codec, PostingsFormat).
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NamedSPILoader`1.Reload" -->
        <member name="M:Lucene.Net.Util.NamedSPILoader`1.CheckServiceName(System.String)">
            <summary>
            Validates that a service name meets the requirements of <seealso cref="T:Lucene.Net.Util.NamedSPILoader`1.NamedSPI"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedSPILoader`1.IsLetterOrDigit(System.Char)">
            <summary>
            Checks whether a character is a letter or digit (ascii) which are defined in the spec.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.NamedSPILoader`1.NamedSPI" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Codec.#ctor(System.String)" -->
        <member name="M:Lucene.Net.Codecs.Codec.PostingsFormat">
            <summary>
            Encodes/decodes postings </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.DocValuesFormat">
            <summary>
            Encodes/decodes docvalues </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.StoredFieldsFormat">
            <summary>
            Encodes/decodes stored fields </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.TermVectorsFormat">
            <summary>
            Encodes/decodes term vectors </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.FieldInfosFormat">
            <summary>
            Encodes/decodes field infos file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.SegmentInfoFormat">
            <summary>
            Encodes/decodes segment info file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.NormsFormat">
            <summary>
            Encodes/decodes document normalization values </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.LiveDocsFormat">
            <summary>
            Encodes/decodes live docs </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.ForName(System.String)">
            <summary>
            looks up a codec by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.AvailableCodecs">
            <summary>
            returns a list of all available codec names </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Codec.ReloadCodecs" -->
        <member name="M:Lucene.Net.Codecs.Codec.ToString">
            <summary>
            returns the codec's name. Subclasses can override to provide
            more detail (such as parameters).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Name">
            <summary>
            Returns this codec's name </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Default">
            <summary>
            expert: returns the default codec used for newly created
             <seealso cref="T:Lucene.Net.Index.IndexWriterConfig"/>s.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.CodecUtil" -->
        <member name="F:Lucene.Net.Codecs.CodecUtil.CODEC_MAGIC">
            <summary>
            Constant to identify the start of a codec header.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.CodecUtil.FOOTER_MAGIC">
            <summary>
            Constant to identify the start of a codec footer.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.HeaderLength(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckHeaderNoMagic(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)">
            <summary>
            Like {@link
             #checkHeader(DataInput,String,int,int)} except this
             version assumes the first int has already been read
             and validated from the input.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.FooterLength" -->
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)">
            <summary>
            Validates the codec footer previously written by <seealso cref="!:#writeFooter"/>. </summary>
            <returns> actual checksum value </returns>
            <exception cref="!:IOException"> if the footer is invalid, if the checksum does not match,
                                or if {@code in} is not properly positioned before the footer
                                at the end of the stream. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.RetrieveChecksum(Lucene.Net.Store.IndexInput)">
            <summary>
            Returns (but does not validate) the checksum previously written by <seealso cref="!:#checkFooter"/>. </summary>
            <returns> actual checksum value </returns>
            <exception cref="!:IOException"> if the footer is invalid </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckEOF(Lucene.Net.Store.IndexInput)">
            <summary>
            Checks that the stream is positioned at the end, and throws exception
            if it is not. </summary>
            @deprecated Use <seealso cref="!:#checkFooter"/> instead, this should only used for files without checksums
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.ChecksumEntireFile(Lucene.Net.Store.IndexInput)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat" -->
        <member name="T:Lucene.Net.Codecs.StoredFieldsFormat">
            <summary>
            Controls the format of stored fields
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> to load stored
             fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> to write stored
             fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexReader">
            <summary>
            Random-access reader for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> impl for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsReader">
            <summary>
            Codec API for reading stored fields.
            
            You need to implement visitDocument(int, StoredFieldVisitor) to
            read the stored fields for a document, implement clone( (creating
            clones of any IndexInputs used, etc), and close() 
            
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.VisitDocument(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Visit the stored fields for document <code>n</code> </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.EnsureOpen">
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Close the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/>s.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.DataInput" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadByte" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadShort" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadInt" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadVInt" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadLong" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadVLong" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.ReadString" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataInput.Clone" -->
        <member name="M:Lucene.Net.Store.DataInput.ReadStringStringMap">
            <summary>
            Reads a Map&lt;String,String&gt; previously written
             with <seealso cref="!:DataOutput#writeStringStringMap(Map)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadStringSet">
            <summary>
            Reads a Set&lt;String&gt; previously written
             with <seealso cref="!:DataOutput#writeStringSet(Set)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.SkipBytes(System.Int64)">
            <summary>
            Skip over <code>numBytes</code> bytes. The contract on this method is that it
            should have the same behavior as reading the same number of bytes into a
            buffer and discarding its content. Negative values of <code>numBytes</code>
            are not supported.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.ChunkSize">
            <summary>
            Return the decompressed size of the chunk
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Next(System.Int32)">
            <summary>
            Go to the chunk containing the provided doc ID.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Decompress">
            <summary>
            Decompress the chunk.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CopyCompressedData(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy compressed data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CheckIntegrity">
            <summary>
            Check integrity of the data. The iterator is not usable after this method has been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> impl for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.StoredFieldsWriter" -->
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the stored fields of the document.
             <seealso cref="!:#writeField(FieldInfo, IndexableField)"/> will be called
             <code>numStoredFields</code> times. Note that this is
             called even if the document has no stored fields, in
             this case <code>numStoredFields</code> will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.FinishDocument">
            <summary>
            Called when a document and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IndexableField)">
            <summary>
            Writes a single stored field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
             any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <seealso cref="!:#close()"/>, passing in the number
             of documents that were written. Note that this is
             intentionally redundant (equivalent to the number of
             calls to <seealso cref="!:#startDocument(int)"/>, but a Codec should
             check that this is the case to detect the JRE bug described
             in LUCENE-1282.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the stored fields from the readers in
             <code>mergeState</code>. The default implementation skips
             over deleted documents, and uses <seealso cref="!:#startDocument(int)"/>,
             <seealso cref="!:#writeField(FieldInfo, IndexableField)"/>, and <seealso cref="!:#finish(FieldInfos, int)"/>,
             returning the number of documents that were written.
             Implementations can override this method for more sophisticated
             merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.AddDocument``1(System.Collections.Generic.IEnumerable{``0},Lucene.Net.Index.FieldInfos)">
            <summary>
            sugar method for startDocument() + writeField() for every stored field in the document </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat">
            <summary>
            A <seealso cref="T:Lucene.Net.Codecs.TermVectorsFormat"/> that compresses chunks of documents together in
            order to improve the compression ratio.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsFormat">
            <summary>
            Controls the format of term vectors
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.TermVectorsReader"/> to read term
             vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> to write term
             vectors.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.TermVectorsReader"/> for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsReader">
             <summary>
             Codec API for reading term vectors:
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Get(System.Int32)">
            <summary>
            Returns term vectors for this document, or null if
             term vectors were not indexed. If offsets are
             available they are in an <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.OffsetAttribute"/>
             available from the <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.TermVectorsReader.CheckIntegrity" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Clone">
            <summary>
            Create a clone that one caller at a time may use to
             read term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.EnsureOpen">
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if this TermVectorsReader is closed </exception>
        </member>
        <member name="T:Lucene.Net.Index.DocsAndPositionsEnum">
            <summary>
            Also iterates through positions. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocsEnum">
            <summary>
            Iterates through the documents and term freqs.
             NOTE: you must first call <seealso cref="!:#nextDoc"/> before using
             any of the per-doc methods.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSetIterator">
            <summary>
            this abstract class defines methods to iterate over a set of non-decreasing
            doc ids. Note that this class assumes it iterates on doc Ids, and therefore
            <seealso cref="!:#NO_MORE_DOCS"/> is set to {@value #NO_MORE_DOCS} in order to be used as
            a sentinel object. Implementations of this class are expected to consider
            <seealso cref="!:Integer#MAX_VALUE"/> as an invalid value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS">
            <summary>
            When returned by <seealso cref="!:#nextDoc()"/>, <seealso cref="!:#advance(int)"/> and
            <seealso cref="!:#docID()"/> it means there are no more docs in the iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.Empty">
            <summary>
            An empty {@code DocIdSetIterator} instance </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.DocID" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.NextDoc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.DocIdSetIterator.SlowAdvance(System.Int32)">
            <summary>
            Slow (linear) implementation of <seealso cref="!:#advance"/> relying on
             <seealso cref="!:#nextDoc()"/> to advance beyond the target position.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.Cost" -->
        <member name="F:Lucene.Net.Index.DocsEnum.FLAG_NONE">
            <summary>
            Flag to pass to <seealso cref="!:TermsEnum#docs(Bits,DocsEnum,int)"/> if you don't
            require term frequencies in the returned enum. When passed to
            <seealso cref="!:TermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,int)"/> means
            that no offsets and payloads will be returned.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsEnum.FLAG_FREQS">
            <summary>
            Flag to pass to <seealso cref="!:TermsEnum#docs(Bits,DocsEnum,int)"/>
             if you require term frequencies in the returned enum.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocsEnum.Freq" -->
        <member name="M:Lucene.Net.Index.DocsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsEnum.FLAG_OFFSETS">
            <summary>
            Flag to pass to <seealso cref="!:TermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,int)"/>
             if you require offsets in the returned enum.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsEnum.FLAG_PAYLOADS">
            <summary>
            Flag to pass to  <seealso cref="!:TermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,int)"/>
             if you require payloads in the returned enum.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.NextPosition">
            <summary>
            Returns the next position.  You should only call this
             up to <seealso cref="!:DocsEnum#freq()"/> times else
             the behavior is not defined.  If positions were not
             indexed this will return -1; this only happens if
             offsets were indexed and you passed needsOffset=true
             when pulling the enum.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.StartOffset">
            <summary>
            Returns start offset for the current position, or -1
             if offsets were not indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.EndOffset">
            <summary>
            Returns end offset for the current position, or -1 if
             offsets were not indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsAndPositionsEnum.Payload">
            <summary>
            Returns the payload at this position, or null if no
             payload was indexed. You should not modify anything
             (neither members of the returned BytesRef nor bytes
             in the byte[]).
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermVectorsWriter" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the term vectors of the document.
             <seealso cref="!:#startField(FieldInfo, int, boolean, boolean, boolean)"/> will
             be called <code>numVectorFields</code> times. Note that if term
             vectors are enabled, this is called even if the document
             has no vector fields, in this case <code>numVectorFields</code>
             will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishDocument">
            <summary>
            Called after a doc and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Called before writing the terms of the field.
             <seealso cref="!:#startTerm(BytesRef, int)"/> will be called <code>numTerms</code> times.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishField">
            <summary>
            Called after a field and all its terms have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Adds a term and its term frequency <code>freq</code>.
            If this field has positions and/or offsets enabled, then
            <seealso cref="!:#addPosition(int, int, int, BytesRef)"/> will be called
            <code>freq</code> times respectively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishTerm">
            <summary>
            Called after a term and all its positions have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a term position and offsets </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
             any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <seealso cref="!:#close()"/>, passing in the number
             of documents that were written. Note that this is
             intentionally redundant (equivalent to the number of
             calls to <seealso cref="!:#startDocument(int)"/>, but a Codec should
             check that this is the case to detect the JRE bug described
             in LUCENE-1282.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.TermVectorsWriter.AddProx(System.Int32,Lucene.Net.Store.DataInput,Lucene.Net.Store.DataInput)" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the term vectors from the readers in
             <code>mergeState</code>. The default implementation skips
             over deleted documents, and uses <seealso cref="!:#startDocument(int)"/>,
             <seealso cref="!:#startField(FieldInfo, int, boolean, boolean, boolean)"/>,
             <seealso cref="!:#startTerm(BytesRef, int)"/>, <seealso cref="!:#addPosition(int, int, int, BytesRef)"/>,
             and <seealso cref="!:#finish(FieldInfos, int)"/>,
             returning the number of documents that were written.
             Implementations can override this method for more sophisticated
             merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.Fields,Lucene.Net.Index.MergeState)">
            <summary>
            Safe (but, slowish) default method to write every
             vector field in the document.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermVectorsWriter.Comparator">
            <summary>
            Return the BytesRef Comparator used to sort terms
             before feeding to this API.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FlushFieldNums">
            <summary>
            Returns a sorted array containing unique field numbers </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.DocData">
            <summary>
            a pending doc </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FieldData">
            <summary>
            a pending field </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressionMode">
            <summary>
            A compression mode. Tells how much effort should be spent on compression and
            decompression of stored fields.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST">
            <summary>
            A compression mode that trades compression ratio for speed. Although the
            compression ratio might remain high, compression and decompression are
            very fast. Use this mode with indices that have a high update rate but
            should be able to load documents from disk quickly.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.HIGH_COMPRESSION">
            <summary>
            A compression mode that trades speed for compression ratio. Although
            compression and decompression might be slow, this compression mode should
            provide a good compression ratio. this mode might be interesting if/when
            your index size is much bigger than your OS cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST_DECOMPRESSION">
            <summary>
            this compression mode is similar to <seealso cref="!:#FAST"/> but it spends more time
            compressing in order to improve the compression ratio. this compression
            mode is best used with indices that have a low update rate but should be
            able to load documents from disk quickly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewCompressor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Compressing.Compressor"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewDecompressor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/> instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Decompressor">
            <summary>
            A decompressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress bytes that were stored between offsets <code>offset</code> and
            <code>offset+length</code> in the original stream from the compressed
            stream <code>in</code> to <code>bytes</code>. After returning, the length
            of <code>bytes</code> (<code>bytes.length</code>) must be equal to
            <code>length</code>. Implementations of this method are free to resize
            <code>bytes</code> depending on their needs.
            </summary>
            <param name="in"> the input that stores the compressed stream </param>
            <param name="originalLength"> the length of the original data (before compression) </param>
            <param name="offset"> bytes before this offset do not need to be decompressed </param>
            <param name="length"> bytes after <code>offset+length</code> do not need to be decompressed </param>
            <param name="bytes"> a <seealso cref="T:Lucene.Net.Util.BytesRef"/> where to store the decompressed data </param>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Compressor">
            <summary>
            A data compressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput)">
            <summary>
            Compress bytes into <code>out</code>. It it the responsibility of the
            compressor to add all necessary information so that a <seealso cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/>
            will know when to stop decompressing bytes from the stream.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.LZ4">
             <summary>
             LZ4 compression and decompression routines.
            
             http://code.google.com/p/lz4/
             http://fastcompression.blogspot.fr/p/lz4.html
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decompress at least <code>decompressedLen</code> bytes into
            <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large
            enough to be able to hold <b>all</b> decompressed data (meaning that you
            need to know the total decompressed length).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HashTable)">
            <summary>
            Compress <code>bytes[off:off+len]</code> into <code>out</code> using
            at most 16KB of memory. <code>ht</code> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.CompressHC(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HCHashTable)">
            <summary>
            Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to
            <seealso cref="!:LZ4#compress(byte[], int, int, DataOutput, HashTable)"/>, this method
            is slower and uses more memory (~ 256KB per thread) but should provide
            better compression ratios (especially on large inputs) because it chooses
            the best match among up to 256 candidates and then performs trade-offs to
            fix overlapping matches. <code>ht</code> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.DocValuesConsumer" -->
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddNumericField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes numeric docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of numeric values (one for each document). {@code null} indicates
                          a missing value. </param>
            <exception cref="T:System.IO.IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddBinaryField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Writes binary docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values (one for each document). {@code null} indicates
                          a missing value. </param>
            <exception cref="T:System.IO.IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted binary docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values in sorted order (deduplicated). </param>
            <param name="docToOrd"> Iterable of ordinals (one for each document). {@code -1} indicates
                            a missing value. </param>
            <exception cref="T:System.IO.IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedSetField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted set docvalues for a field </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values in sorted order (deduplicated). </param>
            <param name="docToOrdCount"> Iterable of the number of values for each document. A zero ordinal
                                 count indicates a missing value. </param>
            <param name="ords"> Iterable of ordinal occurrences (docToOrdCount*maxDoc total). </param>
            <exception cref="T:System.IO.IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeNumericField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.NumericDocValues},System.Collections.Generic.IList{Lucene.Net.Util.Bits})">
            <summary>
            Merges the numeric docvalues from <code>toMerge</code>.
            <p>
            The default implementation calls <seealso cref="!:#addNumericField"/>, passing
            an Iterable that merges and filters deleted documents on the fly.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesConsumer.MergeBinaryField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.BinaryDocValues},System.Collections.Generic.IList{Lucene.Net.Util.Bits})" -->
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedDocValues})">
            <summary>
            Merges the sorted docvalues from <code>toMerge</code>.
            <p>
            The default implementation calls <seealso cref="!:#addSortedField"/>, passing
            an Iterable that merges ordinals and values and filters deleted documents.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedSetField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedSetDocValues})" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.DocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.DocValuesFormat.Name_Renamed">
            <summary>
            Unique name that's used to retrieve this format when
             reading the index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesFormat.#ctor(System.String)" -->
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write docvalues to the
             index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)" -->
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)">
            <summary>
            looks up a format by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.AvailableDocValuesFormats">
            <summary>
            returns a list of all available format names </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesFormat.ReloadDocValuesFormats" -->
        <member name="T:Lucene.Net.Codecs.DocValuesProducer">
             <summary>
             Abstract API that produces numeric, binary and
             sorted docvalues.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetNumeric(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetBinary(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSorted(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSortedSet(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetDocsWithField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Util.Bits"/> at the size of <code>reader.maxDoc()</code>,
             with turned on bits for each docid that does have a value for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesProducer.CheckIntegrity" -->
        <member name="T:Lucene.Net.Codecs.FieldInfosFormat">
            <summary>
            Encodes/decodes <seealso cref="T:Lucene.Net.Index.FieldInfos"/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosReader">
            <summary>
            Returns a <seealso cref="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosReader"/> to read field infos
             from the index
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosWriter">
            <summary>
            Returns a <seealso cref="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosWriter"/> to write field infos
             to the index
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosReader">
            <summary>
            Codec API for reading <seealso cref="T:Lucene.Net.Index.FieldInfos"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.Read(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read the <seealso cref="T:Lucene.Net.Index.FieldInfos"/> previously written with {@link
             FieldInfosWriter}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosWriter">
            <summary>
            Codec API for writing <seealso cref="T:Lucene.Net.Index.FieldInfos"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.Write(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Writes the provided <seealso cref="T:Lucene.Net.Index.FieldInfos"/> to the
             directory.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.FilterCodec" -->
        <member name="F:Lucene.Net.Codecs.FilterCodec.delegate">
            <summary>
            The codec to filter. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FilterCodec.#ctor(System.String,Lucene.Net.Codecs.Codec)">
            <summary>
            Sole constructor. When subclassing this codec,
            create a no-arg ctor and pass the delegate codec
            and a unique name to this ctor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.LiveDocsFormat">
            <summary>
            Format for live/deleted documents
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(System.Int32)">
            <summary>
            Creates a new MutableBits, with all bits set, for the specified size. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(Lucene.Net.Util.Bits)">
            <summary>
            Creates a new mutablebits of the same bits set and size of existing. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.ReadLiveDocs(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Read live docs bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.WriteLiveDocs(Lucene.Net.Util.MutableBits,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Persist live docs bits.  Use {@link
             SegmentCommitInfo#getNextDelGen} to determine the
             generation of the deletes file you should write to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.Files(Lucene.Net.Index.SegmentCommitInfo,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Records all files in use by this <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> into the files argument. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec">
            <summary>
            Supports the Lucene 3.x index format (readonly) </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION">
            <summary>
            Extension of compound file for doc store files </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.GetDocStoreFiles(Lucene.Net.Index.SegmentInfo)">
            <summary>
            Returns file names for shared doc stores, if any, else
            null.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosFormat">
            <summary>
            Lucene3x ReadOnly FieldInfosFromat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader">
            <summary>
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFields">
            <summary>
            Exposes flex API on a pre-flex index, as a codec.
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsFormat">
            <summary>
            Lucene3x ReadOnly NormsFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.NormsFormat">
            <summary>
            Encodes/decodes per-document score normalization values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.NormsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write norms to the
             index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.NormsFormat.NormsProducer(Lucene.Net.Index.SegmentReadState)" -->
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer">
            <summary>
            Reads Lucene 3.x norms format and exposes it via DocValues API
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_EXTENSION">
            <summary>
            Extension of norms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.SEPARATE_NORMS_EXTENSION">
            <summary>
            Extension of separate norms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_HEADER">
            <summary>
            norms header placeholder </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValues">
            <summary>
            A per-document numeric value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.Get(System.Int32)">
            <summary>
            Returns the numeric value for the specified document ID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> numeric value </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat">
            <summary>
            Codec that reads the pre-flex-indexing postings
             format.  It does not provide a writer because newly
             written segments should use the Codec configured on IndexWriter.
            </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.PostingsFormat.EMPTY">
            <summary>
            Zero-length {@code PostingsFormat} array. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsFormat.name">
            <summary>
            Unique name that's used to retrieve this format when
             reading the index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsFormat.#ctor(System.String)" -->
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Writes a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)">
             <summary>
             Reads a segment.  NOTE: by the time this call
              returns, it must hold open any files it will need to
              use; else, those files may be deleted.
              Additionally, required files may be deleted during the execution of
              this call before there is a chance to open them. Under these
              circumstances an IOException should be thrown by the implementation.
              IOExceptions are expected and will automatically cause a retry of the
              segment opening logic with the newly revised segments.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)">
            <summary>
            looks up a format by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.AvailablePostingsFormats">
            <summary>
            returns a list of all available format names </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsFormat.ReloadPostingsFormats" -->
        <member name="P:Lucene.Net.Codecs.PostingsFormat.Name">
            <summary>
            Returns this posting format's name </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_EXTENSION">
            <summary>
            Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat">
            <summary>
            Lucene3x ReadOnly SegmentInfoFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.SegmentInfoFormat" -->
        <member name="M:Lucene.Net.Codecs.SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoReader">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoReader"/> for reading
             <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoWriter">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoWriter"/> for writing
             <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS">
            <summary>
            this format adds optional per-segment String
             diagnostics storage, and switches userData to Map
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_HAS_VECTORS">
            <summary>
            Each segment records whether it has term vectors </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_3_1">
            <summary>
            Each segment records the Lucene version that created it. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION">
            <summary>
            Extension used for saving each SegmentInfo, once a 3.x
             index is first committed to with 4.0.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreOffset(Lucene.Net.Index.SegmentInfo)" -->
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreSegment(Lucene.Net.Index.SegmentInfo)">
            <returns> name used to derive fields/vectors file we share with other segments </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreIsCompoundFile(Lucene.Net.Index.SegmentInfo)">
            <returns> whether doc store files are stored in compound file (*.cfx) </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader">
            <summary>
            Lucene 3x implementation of <seealso cref="T:Lucene.Net.Codecs.SegmentInfoReader"/>.
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoReader">
            <summary>
            Specifies an API for classes that can read <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> information.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.Read(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data from a directory. </summary>
            <param name="directory"> directory to read from </param>
            <param name="segmentName"> name of the segment to read </param>
            <returns> infos instance to be populated with data </returns>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader.ReadLegacySegmentInfo(Lucene.Net.Store.Directory,System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            reads from legacy 3.x segments_N </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader">
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader">
             <summary>
             this abstract class reads skip lists with multiple levels.
            
             See <seealso cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/> for the information about the encoding
             of the multi level skip lists.
            
             Subclasses must implement the abstract method <seealso cref="!:#readSkipData(int, IndexInput)"/>
             which defines the actual format of the skip data.
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.MaxNumberOfSkipLevels">
            <summary>
            the maximum number of skip levels possible for this index </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipStream">
            <summary>
            skipStream for each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipPointer">
            <summary>
            The start pointer of each skip level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipInterval">
            <summary>
             skipInterval of each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.NumSkipped">
            <summary>
            Number of docs skipped per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipDoc">
            <summary>
            Doc id of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.LastDoc">
            <summary>
            Doc id of last read skip entry with docId &lt;= target. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.ChildPointer">
            <summary>
            Child pointer of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.LastChildPointer">
            <summary>
            childPointer of last read skip entry with docId &lt;=
             target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListReader}. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListReader}, where
             {@code skipInterval} and {@code skipMultiplier} are
             the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)">
            <summary>
            Skips entries to the first beyond the current whose document number is
             greater than or equal to <i>target</i>. Returns the current doc count.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SeekChild(System.Int32)">
            <summary>
            Seeks the skip entry on the given level </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.Init(System.Int64,System.Int32)">
            <summary>
            Initializes the reader, for reuse on a new term. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.LoadSkipLevels">
            <summary>
            Loads the skip levels </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> the level skip data shall be read from </param>
            <param name="skipStream"> the skip stream to read from </param>
        </member>
        <member name="P:Lucene.Net.Codecs.MultiLevelSkipListReader.Doc">
            <summary>
            Returns the id of the doc to which the last call of <seealso cref="!:#skipTo(int)"/>
             has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MultiLevelSkipListReader.LastSkipData">
            <summary>
            Copies the values of the last read skip entry on this level </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipBuffer">
            <summary>
            used to buffer the top skip levels </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.IndexInput" -->
        <member name="M:Lucene.Net.Store.IndexInput.#ctor(System.String)">
            <summary>
            resourceDescription should be a non-null, opaque string
             describing this resource; it's returned from
             <seealso cref="!:#toString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Dispose">
            <summary>
            Closes the stream to further operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexInput.Seek(System.Int64)" -->
        <member name="M:Lucene.Net.Store.IndexInput.Length">
            <summary>
            The number of bytes in the file. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexInput.Clone" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Store.IndexInput.FilePointer" -->
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsFormat">
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader">
            <summary>
            Class responsible for access to stored document fields.
            <p/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
             IndexInputs with the original one.  It is the caller's
             job not to close the original FieldsReader until all
             clones are called (eg, currently SegmentReader manages
             this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.CheckCodeVersion(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Verifies that the code version which wrote the segment is supported. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.EnsureOpen">
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/> streams.
            this means that the Fields values will not be accessible.
            </summary>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsFormat">
            <summary>
            Lucene3x ReadOnly TermVectorsFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader">
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.Size">
            
             <returns> The number of documents in the reader </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs">
            @deprecated (4.0)
             @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipProx(System.Int64,System.Int32)">
            <summary>
            Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum">
            @deprecated (4.0) No longer used with flex indexing, except for
            reading old segments
            @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next">
            <summary>
            Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Term">
            <summary>
            Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Prev">
            <summary>
            Returns the previous Term enumerated. Initially null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo">
            <summary>
            Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo(Lucene.Net.Codecs.Lucene3x.TermInfo)">
            <summary>
            Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.DocFreq">
            <summary>
            Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Dispose">
            <summary>
            Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions">
            <summary>
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions.SkipProx(System.Int64,System.Int32)">
            <summary>
            Called by super.skipTo(). </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermBuffer">
            <summary>
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfo">
            <summary>
            A TermInfo is the record of information stored for a
            term </summary>
            @deprecated (4.0) this class is no longer used in flexible
            indexing.
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.TermInfo.DocFreq">
            <summary>
            The number of documents which contain the term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene3x.TermInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Size">
            <summary>
            Returns the number of term/value pairs in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>
            Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term,System.Boolean)">
            <summary>
            Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>
            Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms">
            <summary>
            Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>
            Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfosReader.ThreadResources">
            <summary>
            Per-thread resources managed by ThreadLocal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex" -->
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.#ctor(Lucene.Net.Codecs.Lucene3x.SegmentTermEnum,System.Int32,System.Int64,System.Int32)">
            <summary>
            Loads the segment information at segment load time.
            </summary>
            <param name="indexEnum">
                     the term enum. </param>
            <param name="indexDivisor">
                     the index divisor. </param>
            <param name="tiiFileLength">
                     the size of the tii file, used to approximate the size of the
                     buffer. </param>
            <param name="totalIndexInterval">
                     the total index interval. </param>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>
            Binary search for the given term.
            </summary>
            <param name="term">
                     the term to locate. </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetTerm(System.Int32)">
            <summary>
            Gets the term at the given position.  For testing.
            </summary>
            <param name="termIndex">
                     the position to read the term from the index. </param>
            <returns> the term. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.Length">
            <summary>
            Returns the number of terms.
            </summary>
            <returns> int. </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            The compares the given term against the term in the index specified by the
            term index. ie It returns negative N when term is less than index term;
            </summary>
            <param name="term">
                     the given term. </param>
            <param name="termIndex">
                     the index of the of term to compare. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput,Lucene.Net.Util.BytesRef)">
            <summary>
            Compare the fields of the terms first, and if not equals return from
            compare. If equal compare terms.
            </summary>
            <param name="term">
                     the term to compare. </param>
            <param name="termIndex">
                     the position of the term in the input to compare </param>
            <param name="input">
                     the input buffer. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareField(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput)">
            <summary>
            Compares the fields before checking the text of the terms.
            </summary>
            <param name="term">
                     the given term. </param>
            <param name="termIndex">
                     the term that exists in the data block. </param>
            <param name="input">
                     the data block. </param>
            <returns> int. </returns>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.BitVector">
             <summary>
             Optimized implementation of a vector of bits.  this is more-or-less like
              java.util.BitSet, but also includes the following:
              <ul>
              <li>a count() method, which efficiently computes the number of one bits;</li>
              <li>optimized read from and write to disk;</li>
              <li>inlinable get() method;</li>
              <li>store and load, as bit set or d-gaps, depending on sparseness;</li>
              </ul>
            
              @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.MutableBits">
            <summary>
            Extension of Bits for live documents.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits">
            <summary>
            Interface for Bitset-like structures.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Bits.Get(System.Int32)">
            <summary>
            Returns the value of the bit with the specified <code>index</code>.
            </summary>
            <param name="index"> index, should be non-negative and &lt; <seealso cref="!:#length()"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
            <returns> <code>true</code> if the bit is set, <code>false</code> otherwise. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Bits.Length">
            <summary>
            Returns the number of bits in this set </summary>
        </member>
        <member name="M:Lucene.Net.Util.MutableBits.Clear(System.Int32)">
            <summary>
            Sets the bit specified by <code>index</code> to false. </summary>
            <param name="index"> index, should be non-negative and &lt; <seealso cref="!:#length()"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(System.Int32)">
            <summary>
            Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Set(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.GetAndSet(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to true, and
             returns true if bit was already set
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Clear(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Get(System.Int32)">
            <summary>
            Returns <code>true</code> if <code>bit</code> is one and
             <code>false</code> if it is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Size">
            <summary>
            Returns the number of bits in this vector.  this is also one greater than
             the number of the largest valid bit number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Count">
            <summary>
            Returns the total number of one bits in this vector.  this is efficiently
             computed and cached, so that, if the vector is not changed, no
             recomputation is done for repeated calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Write(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Writes this vector to the file <code>name</code> in Directory
             <code>d</code>, in a format that can be read by the constructor {@link
             #BitVector(Directory, String, IOContext)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.InvertAll">
            <summary>
            Invert all bits </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.SetAll">
            <summary>
            Set all bits </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteBits(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteClearedDgaps(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a d-gaps list </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a bit vector from the file <code>name</code> in Directory
             <code>d</code>, as written by the <seealso cref="!:#write"/> method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadBits(Lucene.Net.Store.IndexInput)">
            <summary>
            Read as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadSetDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            read as a d-gaps list </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadClearedDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            read as a d-gaps cleared bits list </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.RecomputedCount">
            <summary>
            For testing </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.Sparse">
            <summary>
            Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene40"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat.PER_FIELD_NAME">
            <summary>
            Name of this <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat.GetPostingsFormatForField(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader">
            <summary>
            Reads the 4.0 format of norms/docvalues
            @lucene.experimental </summary>
            @deprecated Only for reading old 4.0 and 4.1 segments
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValues">
            <summary>
            A per-document byte[]
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.Get(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Lookup the value for document. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SortedDocValues" -->
        <member name="M:Lucene.Net.Index.SortedDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.GetOrd(System.Int32)">
            <summary>
            Returns the ordinal for the specified docID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> ordinal for the document: this is dense, starts at 0, then
                    increments by 1 for the next value in sorted order. Note that
                    missing values are indicated by -1. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SortedDocValues.LookupOrd(System.Int32,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Index.SortedDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If {@code key} exists, returns its ordinal, else
             returns {@code -insertionPoint-1}, like {@code
             Arrays.binarySearch}.
            </summary>
             <param name="key"> Key to look up
             </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.TermsEnum">
            <summary>
            Returns a <seealso cref="M:Lucene.Net.Index.SortedDocValues.TermsEnum"/> over the values.
            The enum supports <seealso cref="!:TermsEnum#ord()"/> and <seealso cref="!:TermsEnum#seekExact(long)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SortedDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> number of unique values in this SortedDocValues. this is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.DELETES_EXTENSION">
            <summary>
            Extension of deletes </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat">
            <summary>
            Provides a <seealso cref="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
            PostingsWriterBase}.
            </summary>
            @deprecated Only for reading old 4.0 segments
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsBaseFormat">
             <summary>
             Provides a <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
             PostingsWriterBase}.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsBaseFormat.Name">
            <summary>
            Unique name that's used to retrieve this codec when
             reading the index
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.#ctor(System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Creates the <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> for this
             format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsWriterBase(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates the <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsWriterBase(Lucene.Net.Index.SegmentWriteState)"/> for this
             format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.MinBlockSize">
            <summary>
            minimum items (terms or sub-blocks) per block for BlockTree </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.MaxBlockSize">
            <summary>
            maximum items (terms or sub-blocks) per block for BlockTree </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor">
            <summary>
            Creates {@code Lucene40PostingsFormat} with default
             settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader" -->
        <member name="T:Lucene.Net.Codecs.PostingsReaderBase">
            <summary>
            The core terms dictionaries (BlockTermsReader,
             BlockTreeTermsReader) interact with a single instance
             of this class to manage creation of <seealso cref="T:Lucene.Net.Index.DocsEnum"/> and
             <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instances.  It provides an
             IndexInput (termsIn) where this class may read any
             previously stored data that it had written in its
             corresponding <seealso cref="T:Lucene.Net.Codecs.PostingsWriterBase"/> at indexing
             time.
             @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Init(Lucene.Net.Store.IndexInput)">
            <summary>
            Performs any initialization, such as reading and
             verifying the header from the provided terms
             dictionary <seealso cref="T:Lucene.Net.Store.IndexInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.NewTermState">
            <summary>
            Return a newly created empty TermState </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsReaderBase.DecodeTerm(System.Int64[],Lucene.Net.Store.DataInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)" -->
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Docs(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.Bits,Lucene.Net.Index.DocsEnum,System.Int32)">
            <summary>
            Must fully consume state, since after this call that
             TermState may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.DocsAndPositions(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.Bits,Lucene.Net.Index.DocsAndPositionsEnum,System.Int32)">
            <summary>
            Must fully consume state, since after this call that
             TermState may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsReaderBase.CheckIntegrity" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentDocsAndPositionsEnum.Payload">
            <summary>
            Returns the payload at this position, or null if no
             payload was indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentFullPositionsEnum.Payload">
            <summary>
            Returns the payload at this position, or null if no
             payload was indexed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter" -->
        <member name="T:Lucene.Net.Codecs.SegmentInfoWriter">
            <summary>
            Specifies an API for classes that can write out <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Write <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data. </summary>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.Init(System.Int64,System.Int64,System.Int64,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Per-term initialization. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.OffsetLength">
            <summary>
            Returns the offset length (endOffset-startOffset) of the position stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
             IndexInputs with the original one.  It is the caller's
             job not to close the original FieldsReader until all
             clones are called (eg, currently SegmentReader manages
             this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Index.FieldInfos,System.Int32,System.Int32,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput)">
            <summary>
            Used only by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.EnsureOpen">
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/> streams.
            this means that the Fields values will not be accessible.
            </summary>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Size">
            <summary>
            Returns number of documents. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.RawDocs(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns the length in bytes of each raw document in a
             contiguous range of length numDocs starting with
             startDocID.  Returns the IndexInput (the fieldStream),
             already seeked to the starting point for startDocID.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
               when merging stored fields
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.AddRawDocuments(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32)">
            <summary>
            Bulk write a contiguous series of documents.  The
             lengths array is the length (in bytes) of each raw
             document.  The stream IndexInput is the
             fieldsStream from which we should bulk-copy all
             bytes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat">
            <summary>
            Lucene 4.0 Term Vectors format.
            <p>Term Vector support is an optional on a field by field basis. It consists of
            3 files.</p>
            <ol>
            <li><a name="tvx" id="tvx"></a>
            <p>The Document Index or .tvx file.</p>
            <p>For each document, this stores the offset into the document data (.tvd) and
            field data (.tvf) files.</p>
            <p>DocumentIndex (.tvx) --&gt; Header,&lt;DocumentPosition,FieldPosition&gt;
            <sup>NumDocs</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>DocumentPosition --&gt; <seealso cref="!:DataOutput#writeLong UInt64"/> (offset in the .tvd file)</li>
              <li>FieldPosition --&gt; <seealso cref="!:DataOutput#writeLong UInt64"/> (offset in the .tvf file)</li>
            </ul>
            </li>
            <li><a name="tvd" id="tvd"></a>
            <p>The Document or .tvd file.</p>
            <p>this contains, for each document, the number of fields, a list of the fields
            with term vector info and finally a list of pointers to the field information
            in the .tvf (Term Vector Fields) file.</p>
            <p>The .tvd file is used to map out the fields that have term vectors stored
            and where the field information is in the .tvf file.</p>
            <p>Document (.tvd) --&gt; Header,&lt;NumFields, FieldNums,
            FieldPositions&gt; <sup>NumDocs</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>NumFields --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>FieldNums --&gt; &lt;FieldNumDelta&gt; <sup>NumFields</sup></li>
              <li>FieldNumDelta --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>FieldPositions --&gt; &lt;FieldPositionDelta&gt; <sup>NumFields-1</sup></li>
              <li>FieldPositionDelta --&gt; <seealso cref="!:DataOutput#writeVLong VLong"/></li>
            </ul>
            </li>
            <li><a name="tvf" id="tvf"></a>
            <p>The Field or .tvf file.</p>
            <p>this file contains, for each field that has a term vector stored, a list of
            the terms, their frequencies and, optionally, position, offset, and payload
            information.</p>
            <p>Field (.tvf) --&gt; Header,&lt;NumTerms, Flags, TermFreqs&gt;
            <sup>NumFields</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>NumTerms --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Flags --&gt; <seealso cref="!:DataOutput#writeByte Byte"/></li>
              <li>TermFreqs --&gt; &lt;TermText, TermFreq, Positions?, PayloadData?, Offsets?&gt;
                  <sup>NumTerms</sup></li>
              <li>TermText --&gt; &lt;PrefixLength, Suffix&gt;</li>
              <li>PrefixLength --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Suffix --&gt; <seealso cref="!:DataOutput#writeString String"/></li>
              <li>TermFreq --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Positions --&gt; &lt;PositionDelta PayloadLength?&gt;<sup>TermFreq</sup></li>
              <li>PositionDelta --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>PayloadLength --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>PayloadData --&gt; <seealso cref="!:DataOutput#writeByte Byte"/><sup>NumPayloadBytes</sup></li>
              <li>Offsets --&gt; &lt;<seealso cref="!:DataOutput#writeVInt VInt"/>, <seealso cref="!:DataOutput#writeVInt VInt"/>&gt;<sup>TermFreq</sup></li>
            </ul>
            <p>Notes:</p>
            <ul>
            <li>Flags byte stores whether this term vector has position, offset, payload.
            information stored.</li>
            <li>Term byte prefixes are shared. The PrefixLength is the number of initial
            bytes from the previous term which must be pre-pended to a term's suffix
            in order to form the term's bytes. Thus, if the previous term's text was "bone"
            and the term is "boy", the PrefixLength is two and the suffix is "y".</li>
            <li>PositionDelta is, if payloads are disabled for the term's field, the
            difference between the position of the current occurrence in the document and
            the previous occurrence (or zero, if this is the first occurrence in this
            document). If payloads are enabled for the term's field, then PositionDelta/2
            is the difference between the current and the previous position. If payloads
            are enabled and PositionDelta is odd, then PayloadLength is stored, indicating
            the length of the payload at the current term position.</li>
            <li>PayloadData is metadata associated with a term position. If
            PayloadLength is stored at the current position, then it indicates the length
            of this payload. If PayloadLength is not stored, then this payload has the same
            length as the payload at the previous position. PayloadData encodes the
            concatenated bytes for all of a terms occurrences.</li>
            <li>Offsets are stored as delta encoded VInts. The first VInt is the
            startOffset, the second is the endOffset.</li>
            </ul>
            </li>
            </ol>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Used by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.RawDocs(System.Int32[],System.Int32[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.Size">
            
             <returns> The number of documents in the reader </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
               when merging term vectors
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.AddRawDocuments(Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader,System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Do a bulk copy of numDocs documents from reader to our
            streams.  this is used to expedite merging, if the
            field numbers are congruent.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.Dispose(System.Boolean)">
            <summary>
            Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.ForUtil">
            <summary>
            Encode all values in normal area with fixed bit width,
            which is determined by the max value in this block.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.ALL_VALUES_EQUAL">
            <summary>
            Special number of bits per value used whenever all values to encode are equal.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_ENCODED_SIZE">
            <summary>
            Upper limit of the number of bytes that might be required to stored
            <code>BLOCK_SIZE</code> encoded values.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_DATA_SIZE">
            <summary>
            Upper limit of the number of values that might be decoded in a single call to
            <seealso cref="!:#readBlock(IndexInput, byte[], int[])"/>. Although values after
            <code>BLOCK_SIZE</code> are garbage, it is necessary to allocate value buffers
            whose size is &gt;= MAX_DATA_SIZE to avoid <seealso cref="!:ArrayIndexOutOfBoundsException"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ComputeIterations(Lucene.Net.Util.Packed.PackedInts.Decoder)">
            <summary>
            Compute the number of iterations required to decode <code>BLOCK_SIZE</code>
            values with the provided <seealso cref="!:Decoder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.EncodedSize(Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes required to encode a block of values that require
            <code>bitsPerValue</code> bits per value with format <code>format</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(System.Single,Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> instance and save state into <code>out</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <seealso cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> from a <seealso cref="T:Lucene.Net.Store.DataInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.WriteBlock(System.Int32[],System.Byte[],Lucene.Net.Store.IndexOutput)">
            <summary>
            Write a block of data (<code>For</code> format).
            </summary>
            <param name="data">     the data to write </param>
            <param name="encoded">  a buffer to use to encode data </param>
            <param name="out">      the destination output </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ReadBlock(Lucene.Net.Store.IndexInput,System.Byte[],System.Int32[])">
            <summary>
            Read the next block of data (<code>For</code> format).
            </summary>
            <param name="in">        the input to use to read data </param>
            <param name="encoded">   a buffer that can be used to store encoded data </param>
            <param name="decoded">   where to write decoded data </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.SkipBlock(Lucene.Net.Store.IndexInput)">
            <summary>
            Skip the next block of data.
            </summary>
            <param name="in">      the input where to read data </param>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.BitsRequired(System.Int32[])">
            <summary>
            Compute the number of bits required to serialize any of the longs in
            <code>data</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat">
             <summary>
             Provides a <seealso cref="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
             PostingsWriterBase}.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.DOC_EXTENSION">
            <summary>
            Filename extension for document number, frequencies, and skip data.
            See chapter: <a href="#Frequencies">Frequencies and Skip Data</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.POS_EXTENSION">
            <summary>
            Filename extension for positions.
            See chapter: <a href="#Positions">Positions</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.PAY_EXTENSION">
            <summary>
            Filename extension for payloads and offsets.
            See chapter: <a href="#Payloads">Payloads and Offsets</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE">
            <summary>
            Fixed packed block size, number of integers encoded in
            a single packed block.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor">
            <summary>
            Creates {@code Lucene41PostingsFormat} with default
             settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.ReadVIntBlock(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Read values that have been written using variable-length encoding instead of bit-packing.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PostingsWriterBase" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PostingsConsumer" -->
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.StartDoc(System.Int32,System.Int32)">
            <summary>
            Adds a new doc in this term.
            <code>freq</code> will be -1 when term frequencies are omitted
            for the field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsConsumer.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsConsumer.FinishDoc" -->
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.Merge(Lucene.Net.Index.MergeState,System.Nullable{Lucene.Net.Index.FieldInfo.IndexOptions},Lucene.Net.Index.DocsEnum,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Default merge impl: append documents, mapping around
             deletes
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.Init(Lucene.Net.Store.IndexOutput)">
            <summary>
            Called once after startup, before any terms have been
             added.  Implementations typically write a header to
             the provided {@code termsOut}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.NewTermState">
            <summary>
            Return a newly created empty TermState </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.StartTerm">
            <summary>
            Start a new term.  Note that a matching call to {@link
             #finishTerm(BlockTermState)} is done, only if the term has at least one
             document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Finishes the current term.  The provided {@link
             BlockTermState} contains the term's summary statistics,
             and will holds metadata from PBF when returned
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.EncodeTerm(System.Int64[],Lucene.Net.Store.DataOutput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)">
             <summary>
             Encode metadata as long[] and byte[]. {@code absolute} controls whether
             current term is delta encoded according to latest term.
             Usually elements in {@code longs} are file pointers, so each one always
             increases when a new term is consumed. {@code out} is used to write generic
             bytes, which are not monotonic.
            
             NOTE: sometimes long[] might contain "don't care" values that are unused, e.g.
             the pointer to postings list may not be defined for some terms but is defined
             for others, if it is designed to inline  some postings data in term dictionary.
             In this case, the postings writer should always use the last value, so that each
             element in metadata long[] remains monotonic.
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.SetField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Sets the current field for writing, and returns the
            fixed length of long[] metadata (which is fixed per
            field), called when the writing switches to another field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.MaxSkipLevels">
            <summary>
            Expert: The maximum number of skip levels. Smaller values result in
            slightly smaller indexes, but slower skipping in big posting lists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,System.Single)">
            <summary>
            Creates a postings writer with the specified PackedInts overhead ratio </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates a postings writer with <code>PackedInts.COMPACT</code> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Called when we are done adding docs to this term </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader">
             <summary>
             Implements the skip list reader for block postings format
             that stores positions and payloads.
            
             Although this skipper uses MultiLevelSkipListReader as an interface,
             its definition of skip position will be a little different.
            
             For example, when skipInterval = blockSize = 3, df = 2*skipInterval = 6,
            
             0 1 2 3 4 5
             d d d d d d    (posting list)
                 ^     ^    (skip point in MultiLeveSkipWriter)
                   ^        (skip point in Lucene41SkipWriter)
            
             In this case, MultiLevelSkipListReader will use the last document as a skip point,
             while Lucene41SkipReader should assume no skip point will comes.
            
             If we use the interface directly in Lucene41SkipReader, it may silly try to read
             another skip data after the only skip point is loaded.
            
             To illustrate this, we can call skipTo(d[5]), since skip point d[3] has smaller docId,
             and numSkipped+blockSize== df, the MultiLevelSkipListReader will assume the skip list
             isn't exhausted yet, and try to load a non-existed skip point
            
             Therefore, we'll trim df before passing it to the interface. see trim(int)
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.Trim(System.Int32)">
             <summary>
             Trim original docFreq to tell skipReader read proper number of skip points.
            
             Since our definition in Lucene41Skip* is a little different from MultiLevelSkip*
             this trimmed docFreq will prevent skipReader from:
             1. silly reading a non-existed skip point after the last block boundary
             2. moving into the vInt block
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.DocPointer">
            <summary>
            Returns the doc pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter">
             <summary>
             Write skip lists with multiple levels, and support skip within block ints.
            
             Assume that docFreq = 28, skipInterval = blockSize = 12
            
              |       block#0       | |      block#1        | |vInts|
              d d d d d d d d d d d d d d d d d d d d d d d d d d d d (posting list)
                                      ^                       ^       (level 0 skip point)
            
             Note that skipWriter will ignore first document in block#0, since
             it is useless as a skip point.  Also, we'll never skip into the vInts
             block, only record skip data at the start its start point(if it exist).
            
             For each skip point, we will record:
             1. docID in former position, i.e. for position 12, record docID[11], etc.
             2. its related file points(position, payload),
             3. related numbers or uptos(position, payload).
             4. start offset.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListWriter">
             <summary>
             this abstract class writes skip lists with multiple levels.
            
             <pre>
            
             Example for skipInterval = 3:
                                                                 c            (skip level 2)
                             c                 c                 c            (skip level 1)
                 x     x     x     x     x     x     x     x     x     x      (skip level 0)
             d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  (posting list)
                 3     6     9     12    15    18    21    24    27    30     (df)
            
             d - document
             x - skip data
             c - skip data with child pointer
            
             Skip level i contains every skipInterval-th entry from skip level i-1.
             Therefore the number of entries on level i is: floor(df / ((skipInterval ^ (i + 1))).
            
             Each skip entry on a level i>0 contains a pointer to the corresponding skip entry in list i-1.
             this guarantees a logarithmic amount of skips to find the target document.
            
             While this class takes care of writing the different skip levels,
             subclasses must define the actual format of the skip data.
             </pre>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.NumberOfSkipLevels">
            <summary>
            number of levels in this skip list </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.SkipInterval">
            <summary>
            the skip interval in the list with level = 0 </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.SkipMultiplier">
            <summary>
            skipInterval used for level &gt; 0 </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.SkipBuffer">
            <summary>
            for every skip level a different buffer is used </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListWriter}. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListWriter}, where
             {@code skipInterval} and {@code skipMultiplier} are
             the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.Init">
            <summary>
            Allocates internal skip buffers. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.ResetSkip">
            <summary>
            Creates new buffers or empties the existing ones </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkipData(System.Int32,Lucene.Net.Store.IndexOutput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> the level skip data shall be writing for </param>
            <param name="skipBuffer"> the skip buffer to write to </param>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.BufferSkip(System.Int32)">
            <summary>
            Writes the current skip data to the buffers. The current document frequency determines
            the max level is skip data is to be written to.
            </summary>
            <param name="df"> the current document frequency </param>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkip(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the buffered skip lists to the given output.
            </summary>
            <param name="output"> the IndexOutput the skip lists shall be written to </param>
            <returns> the pointer the skip list starts </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter.BufferSkip(System.Int32,System.Int32,System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Sets the values for the current skip data.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat">
             <summary>
             Lucene 4.1 stored fields format.
            
             <p><b>Principle</b></p>
             <p>this <seealso cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> compresses blocks of 16KB of documents in
             order to improve the compression ratio compared to document-level
             compression. It uses the <a href="http://code.google.com/p/lz4/">LZ4</a>
             compression algorithm, which is fast to compress and very fast to decompress
             data. Although the compression method that is used focuses more on speed
             than on compression ratio, it should provide interesting compression ratios
             for redundant inputs (such as log files, HTML or plain text).</p>
             <p><b>File formats</b></p>
             <p>Stored fields are represented by two files:</p>
             <ol>
             <li><a name="field_data" id="field_data"></a>
             <p>A fields data file (extension <tt>.fdt</tt>). this file stores a compact
             representation of documents in compressed blocks of 16KB or more. When
             writing a segment, documents are appended to an in-memory <tt>byte[]</tt>
             buffer. When its size reaches 16KB or more, some metadata about the documents
             is flushed to disk, immediately followed by a compressed representation of
             the buffer using the
             <a href="http://code.google.com/p/lz4/">LZ4</a>
             <a href="http://fastcompression.blogspot.fr/2011/05/lz4-explained.html">compression format</a>.</p>
             <p>Here is a more detailed description of the field data file format:</p>
             <ul>
             <li>FieldData (.fdt) --&gt; &lt;Header&gt;, PackedIntsVersion, &lt;Chunk&gt;<sup>ChunkCount</sup></li>
             <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
             <li>PackedIntsVersion --&gt; <seealso cref="!:PackedInts#VERSION_CURRENT"/> as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>ChunkCount is not known in advance and is the number of chunks necessary to store all document of the segment</li>
             <li>Chunk --&gt; DocBase, ChunkDocs, DocFieldCounts, DocLengths, &lt;CompressedDocs&gt;</li>
             <li>DocBase --&gt; the ID of the first document of the chunk as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>ChunkDocs --&gt; the number of documents in the chunk as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>DocFieldCounts --&gt; the number of stored fields of every document in the chunk, encoded as followed:<ul>
               <li>if chunkDocs=1, the unique value is encoded as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
               <li>else read a <seealso cref="!:DataOutput#writeVInt VInt"/> (let's call it <tt>bitsRequired</tt>)<ul>
                 <li>if <tt>bitsRequired</tt> is <tt>0</tt> then all values are equal, and the common value is the following <seealso cref="!:DataOutput#writeVInt VInt"/></li>
                 <li>else <tt>bitsRequired</tt> is the number of bits required to store any value, and values are stored in a <seealso cref="!:PackedInts packed"/> array where every value is stored on exactly <tt>bitsRequired</tt> bits</li>
               </ul></li>
             </ul></li>
             <li>DocLengths --&gt; the lengths of all documents in the chunk, encoded with the same method as DocFieldCounts</li>
             <li>CompressedDocs --&gt; a compressed representation of &lt;Docs&gt; using the LZ4 compression format</li>
             <li>Docs --&gt; &lt;Doc&gt;<sup>ChunkDocs</sup></li>
             <li>Doc --&gt; &lt;FieldNumAndType, Value&gt;<sup>DocFieldCount</sup></li>
             <li>FieldNumAndType --&gt; a <seealso cref="!:DataOutput#writeVLong VLong"/>, whose 3 last bits are Type and other bits are FieldNum</li>
             <li>Type --&gt;<ul>
               <li>0: Value is String</li>
               <li>1: Value is BinaryValue</li>
               <li>2: Value is Int</li>
               <li>3: Value is Float</li>
               <li>4: Value is Long</li>
               <li>5: Value is Double</li>
               <li>6, 7: unused</li>
             </ul></li>
             <li>FieldNum --&gt; an ID of the field</li>
             <li>Value --&gt; <seealso cref="!:DataOutput#writeString(String) String"/> | BinaryValue | Int | Float | Long | Double depending on Type</li>
             <li>BinaryValue --&gt; ValueLength &lt;Byte&gt;<sup>ValueLength</sup></li>
             </ul>
             <p>Notes</p>
             <ul>
             <li>If documents are larger than 16KB then chunks will likely contain only
             one document. However, documents can never spread across several chunks (all
             fields of a single document are in the same chunk).</li>
             <li>When at least one document in a chunk is large enough so that the chunk
             is larger than 32KB, the chunk will actually be compressed in several LZ4
             blocks of 16KB. this allows <seealso cref="T:Lucene.Net.Index.StoredFieldVisitor"/>s which are only
             interested in the first fields of a document to not have to decompress 10MB
             of data if the document is 10MB, but only 16KB.</li>
             <li>Given that the original lengths are written in the metadata of the chunk,
             the decompressor can leverage this information to stop decoding as soon as
             enough data has been decompressed.</li>
             <li>In case documents are incompressible, CompressedDocs will be less than
             0.5% larger than Docs.</li>
             </ul>
             </li>
             <li><a name="field_index" id="field_index"></a>
             <p>A fields index file (extension <tt>.fdx</tt>).</p>
             <ul>
             <li>FieldsIndex (.fdx) --&gt; &lt;Header&gt;, &lt;ChunkIndex&gt;</li>
             <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
             <li>ChunkIndex: See <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/></li>
             </ul>
             </li>
             </ol>
             <p><b>Known limitations</b></p>
             <p>this <seealso cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> does not support individual documents
             larger than (<tt>2<sup>31</sup> - 2<sup>14</sup></tt>) bytes. In case this
             is a problem, you should use another format, such as
             <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>.</p>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene42"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat.PER_FIELD_NAME">
            <summary>
            Name of this <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Perfield.PerFieldDocValuesFormat.GetDocValuesFormatForField(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor">
            <summary>
            Calls {@link #Lucene42NormsFormat(float)
            Lucene42DocValuesFormat(PackedInts.FASTEST)}
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor(System.Single)">
             <summary>
             Creates a new Lucene42DocValuesFormat with the specified
             <code>acceptableOverheadRatio</code> for NumericDocValues. </summary>
             <param name="acceptableOverheadRatio"> compression parameter for numerics.
                    Currently this is only used when the number of unique values is small.
            
             @lucene.experimental </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor">
            <summary>
            Calls {@link #Lucene42DocValuesFormat(float)
            Lucene42DocValuesFormat(PackedInts.DEFAULT)}
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor(System.Single)">
             <summary>
             Creates a new Lucene42DocValuesFormat with the specified
             <code>acceptableOverheadRatio</code> for NumericDocValues. </summary>
             <param name="acceptableOverheadRatio"> compression parameter for numerics.
                    Currently this is only used when the number of unique values is small.
            
             @lucene.experimental </param>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer">
            <summary>
            Reader for <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SortedSetDocValues" -->
        <member name="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS">
            <summary>
            When returned by <seealso cref="!:#nextOrd()"/> it means there are no more
            ordinals for the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.NextOrd">
            <summary>
            Returns the next ordinal for the current document (previously
            set by <seealso cref="!:#setDocument(int)"/>. </summary>
            <returns> next ordinal for the document, or <seealso cref="!:#NO_MORE_ORDS"/>.
                    ordinals are dense, start at 0, then increment by 1 for
                    the next value in sorted order.  </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SortedSetDocValues.LookupOrd(System.Int64,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Index.SortedSetDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If {@code key} exists, returns its ordinal, else
             returns {@code -insertionPoint-1}, like {@code
             Arrays.binarySearch}.
            </summary>
             <param name="key"> Key to look up
             </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.TermsEnum">
            <summary>
            Returns a <seealso cref="M:Lucene.Net.Index.SortedSetDocValues.TermsEnum"/> over the values.
            The enum supports <seealso cref="!:TermsEnum#ord()"/> and <seealso cref="!:TermsEnum#seekExact(long)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SortedSetDocValues.Document">
            <summary>
            Sets iteration to the specified docID </summary>
            <param name="docID"> document ID  </param>
        </member>
        <member name="P:Lucene.Net.Index.SortedSetDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> number of unique values in this SortedDocValues. this is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsConsumer">
            <summary>
            Writer for <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene45.Lucene45Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene45"
             </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer">
            <summary>
            writer for <seealso cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/> </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.DELTA_COMPRESSED">
            <summary>
            Compressed using packed blocks of ints. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.GCD_COMPRESSED">
            <summary>
            Compressed by computing the GCD. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.TABLE_COMPRESSED">
            <summary>
            Compressed by giving IDs to unique values. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_FIXED_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (fixed length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_VARIABLE_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (variable length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_PREFIX_COMPRESSED">
            <summary>
            Compressed binary with shared prefixes </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_WITH_ADDRESSES">
            <summary>
            Standard storage for sorted set values with 1 level of indirection:
             docId -> address -> ord.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_SINGLE_VALUED_SORTED">
            <summary>
            Single-valued sorted set values, encoded as sorted values, so no level
             of indirection: docId -> ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.#ctor(Lucene.Net.Index.SegmentWriteState,System.String,System.String,System.String,System.String)">
            <summary>
            expert: Creates a new writer </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.AddTermsDict(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            expert: writes a value dictionary for a sorted/sortedset field </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat.#ctor">
            <summary>
            Sole Constructor </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer">
            <summary>
            reader for <seealso cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/> </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.#ctor(Lucene.Net.Index.SegmentReadState,System.String,System.String,System.String,System.String)">
            <summary>
            expert: instantiates a new reader </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetAddressInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            returns an address instance for variable-length binary values.
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetIntervalInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            returns an address instance for prefix-compressed binary values.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetOrdIndexInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry)">
            <summary>
            returns an address instance for sortedset ordinal lists
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.LongValues">
            <summary>
            Abstraction over an array of longs.
             this class extends NumericDocValues so that we don't need to add another
             level of abstraction every time we want eg. to use the <seealso cref="T:Lucene.Net.Util.Packed.PackedInts"/>
             utility classes to represent a <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> instance.
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongValues.Get(System.Int64)">
            <summary>
            Get value at <code>index</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.RandomAccessOrds" -->
        <member name="M:Lucene.Net.Index.RandomAccessOrds.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.RandomAccessOrds.OrdAt(System.Int32)" -->
        <member name="M:Lucene.Net.Index.RandomAccessOrds.Cardinality">
            <summary>
            Returns the cardinality for the current document (previously
            set by <seealso cref="!:#setDocument(int)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry">
            <summary>
            metadata entry for a numeric docvalues field </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.MissingOffset">
            <summary>
            offset to the bitset representing docsWithField, or -1 if no documents have missing values </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Offset">
            <summary>
            offset to the actual numeric values </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.PackedIntsVersion">
            <summary>
            packed ints version used to encode these numerics </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Count">
            <summary>
            count of values written </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.BlockSize">
            <summary>
            packed ints blocksize </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry">
            <summary>
            metadata entry for a binary docvalues field </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.MissingOffset">
            <summary>
            offset to the bitset representing docsWithField, or -1 if no documents have missing values </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.Offset">
            <summary>
            offset to the actual binary values </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.Count">
            <summary>
            count of values written </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressesOffset">
            <summary>
            offset to the addressing data that maps a value to its slice of the byte[] </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressInterval">
            <summary>
            interval of shared prefix chunks (when using prefix-compressed binary) </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.PackedIntsVersion">
            <summary>
            packed ints version used to encode addressing information </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.BlockSize">
            <summary>
            packed ints blocksize </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.SortedSetEntry">
            <summary>
            metadata entry for a sorted-set docvalues field </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene45"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments,
             remapping docIDs (this is used for segment merging).
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.MergeState">
            <summary>
            Sets the <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.MergeState"/>, which is used to re-map
             document IDs.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments,
             remapping docIDs (this is used for segment merging).
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState">
            <summary>
            Sets the <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState"/>, which is used to re-map
             document IDs.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Codecs.MappingMultiDocsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermStats" -->
        <member name="F:Lucene.Net.Codecs.TermStats.DocFreq">
            <summary>
            How many documents have at least one occurrence of
             this term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.TermStats.TotalTermFreq">
            <summary>
            Total number of times this term occurs across all
             documents in the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermStats.#ctor(System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.BinaryDocValuesField" -->
        <member name="T:Lucene.Net.Documents.Field">
             <summary>
             Expert: directly create a field for a document.  Most
             users should use one of the sugar subclasses: {@link
             IntField}, <seealso cref="T:Lucene.Net.Documents.LongField"/>, <seealso cref="T:Lucene.Net.Documents.FloatField"/>, {@link
             DoubleField}, <seealso cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>, {@link
             NumericDocValuesField}, <seealso cref="T:Lucene.Net.Documents.SortedDocValuesField"/>, {@link
             StringField}, <seealso cref="T:Lucene.Net.Documents.TextField"/>, <seealso cref="T:Lucene.Net.Documents.StoredField"/>.
            
             <p/> A field is a section of a Document. Each field has three
             parts: name, type and value. Values may be text
             (String, Reader or pre-analyzed TokenStream), binary
             (byte[]), or numeric (a Number).  Fields are optionally stored in the
             index, so that they may be returned with hits on the document.
            
             <p/>
             NOTE: the field type is an <seealso cref="T:Lucene.Net.Index.IndexableFieldType"/>.  Making changes
             to the state of the IndexableFieldType will impact any
             Field it is used in.  It is strongly recommended that no
             changes be made after Field instantiation.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexableField">
             <summary>
             Represents a single field for indexing.  IndexWriter
              consumes Iterable&lt;IndexableField&gt; as a document.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexableField.Name">
            <summary>
            Field name </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexableField.FieldType">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexableFieldType"/> describing the properties
            of this field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexableField.GetBoost" -->
        <member name="M:Lucene.Net.Index.IndexableField.BinaryValue">
            <summary>
            Non-null if this field has a binary value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexableField.GetTokenStream(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates the TokenStream used for indexing this field.  If appropriate,
            implementations should use the given Analyzer to create the TokenStreams.
            </summary>
            <param name="analyzer"> Analyzer that should be used to create the TokenStreams from </param>
            <returns> TokenStream value for indexing the document.  Should always return
                    a non-null value if the field is to be indexed </returns>
            <exception cref="T:System.IO.IOException"> Can be thrown while creating the TokenStream </exception>
        </member>
        <member name="P:Lucene.Net.Index.IndexableField.StringValue">
            <summary>
            Non-null if this field has a string value </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexableField.ReaderValue">
            <summary>
            Non-null if this field has a Reader value </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexableField.NumericValue">
            <summary>
            Non-null if this field has a numeric value </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Type">
            <summary>
            Field's type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Name_Renamed">
            <summary>
            Field's name
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.FieldsData">
            <summary>
            Field's value </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TokenStream_Renamed">
            <summary>
            Pre-analyzed tokenStream for indexed fields; this is
            separate from fieldsData because you are allowed to
            have both; eg maybe field has a String value but you
            customize how it's tokenized
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Documents.Field.Boost_Renamed" -->
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: creates a field with no initial value.
            Intended only for custom Field subclasses. </summary>
            <param name="name"> field name </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentNullException"> if either the name or type
                    is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with Reader value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> reader value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentNullException"> if either the name or type
                    is null, or if the field's type is stored(), or
                    if tokenized() is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if the reader is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with TokenStream value. </summary>
            <param name="name"> field name </param>
            <param name="tokenStream"> TokenStream value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if either the name or type
                    is null, or if the field's type is stored(), or
                    if tokenized() is false, or if indexed() is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if the tokenStream is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.FieldType)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32,Lucene.Net.Documents.FieldType)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Documents.FieldType)" -->
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with String value. </summary>
            <param name="name"> field name </param>
            <param name="value"> string value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if either the name or value
                    is null, or if the field's type is neither indexed() nor stored(),
                    or if indexed() is false but storeTermVectors() is true. </exception>
            <exception cref="T:System.ArgumentNullException"> if the type is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.TokenStreamValue">
            <summary>
            The TokenStream for this field to be used when indexing, or null. If null,
            the Reader value or String value is analyzed to produce the indexed tokens.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Field.ToString">
            <summary>
            Prints a Field for human consumption. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.FieldType">
            <summary>
            Returns the <seealso cref="M:Lucene.Net.Documents.Field.FieldType"/> for this field. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.StringValue">
             <summary>
             <p>
             Expert: change the value of this field. this can be used during indexing to
             re-use a single Field instance to improve indexing speed by avoiding GC
             cost of new'ing and reclaiming Field instances. Typically a single
             <seealso cref="T:Lucene.Net.Documents.Document"/> instance is re-used as well. this helps most on small
             documents.
             </p>
            
             <p>
             Each Field instance should only be used once within a single
             <seealso cref="T:Lucene.Net.Documents.Document"/> instance. See <a href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed">ImproveIndexingSpeed</a> for details.
             </p>
             </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.ReaderValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.Field.BytesValue" -->
        <member name="P:Lucene.Net.Documents.Field.ByteValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.ShortValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.IntValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.LongValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.FloatValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.DoubleValue">
            <summary>
            Expert: change the value of this field. See
            <seealso cref="!:#setStringValue(String)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.TokenStream">
            <summary>
            Expert: sets the token stream to be used for indexing and causes
            isIndexed() and isTokenized() to return true. May be combined with stored
            values from stringValue() or getBinaryValue()
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.Boost">
            <summary>
            Sets the boost factor on this field. </summary>
            <exception cref="!:IllegalArgumentException"> if this field is not indexed,
                    or if it omits norms. </exception>
            <seealso> cref= #boost() </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Field.StringTokenStream.#ctor" -->
        <member name="P:Lucene.Net.Documents.Field.StringTokenStream.Value">
            <summary>
            Sets the string value. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Store">
            <summary>
            Specifies whether and how a field should be stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>
            Store the original field value in the index. this is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>
            Do not store the field's value in the index. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.Field.Index" -->
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is
            <see cref="T:Lucene.Net.Documents.Field.Store">stored</see>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED">
            <summary>Index the tokens produced by running the field's
            value through an Analyzer.  This is useful for
            common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED">
            <summary>Index the field's value without using an Analyzer, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS">
            <summary>Expert: Index the field's value without an Analyzer,
            and also disable the storing of norms.  Note that you
            can also separately enable/disable norms by setting
            <see cref="!:AbstractField.OmitNorms"/>.  No norms means that
            index-time field and document boosting and field
            length normalization are disabled.  The benefit is
            less memory usage as norms take up one byte of RAM
            per indexed field for every document in the index,
            during searching.  Note that once you index a given
            field <i>with</i> norms enabled, disabling norms will
            have no effect.  In other words, for this to have the
            above described effect on a field, all instances of
            that field must be indexed with NOT_ANALYZED_NO_NORMS
            from the beginning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED_NO_NORMS">
            <summary>Expert: Index the tokens produced by running the
            field's value through an Analyzer, and also
            separately disable the storing of norms.  See
            <see cref="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS"/> for what norms are
            and why you may want to disable them.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.TermVector">
            <summary>Specifies whether and how a field should have term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>Do not store term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurrences in that document.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
             <summary> Store the term vector + token position information
            
             </summary>
             <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES">
             </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
             <summary> Store the term vector + Token offset information
            
             </summary>
             <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES">
             </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
             <summary> Store the term vector + Token position and offset information
            
             </summary>
             <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES">
             </seealso>
             <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
             </seealso>
             <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
             </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.BinaryDocValuesField.fType">
            <summary>
            Type for straight bytes DocValues.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.BinaryDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new binary DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="value"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.ByteDocValuesField" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.NumericDocValuesField" -->
        <member name="F:Lucene.Net.Documents.NumericDocValuesField.TYPE">
            <summary>
            Type for numeric DocValues.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumericDocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new DocValues field with the specified 64-bit long value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit long value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.ByteDocValuesField.#ctor(System.String,System.SByte)">
            <summary>
            Creates a new DocValues field with the specified 8-bit byte value </summary>
            <param name="name"> field name </param>
            <param name="value"> 8-bit byte value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.CompressionTools">
            <summary>
            Simple utility class providing static methods to
             compress and decompress binary data for stored fields.
             this class uses java.util.zip.Deflater and Inflater
             classes to compress and decompress.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Compresses the specified byte range using the
             specified compressionLevel (constants are defined in
             java.util.zip.Deflater).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compresses the specified byte range, with default BEST_COMPRESSION level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[])">
            <summary>
            Compresses all bytes in the array, with default BEST_COMPRESSION level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)">
            <summary>
            Compresses the String value, with default BEST_COMPRESSION level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String,System.Int32)">
            <summary>
            Compresses the String value using the specified
             compressionLevel (constants are defined in
             java.util.zip.Deflater).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the byte array previously returned by
             compress (referenced by the provided BytesRef)
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[])">
            <summary>
            Decompress the byte array previously returned by
             compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the byte array previously returned by
             compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[])">
            <summary>
            Decompress the byte array previously returned by
             compressString back into a String
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the byte array previously returned by
             compressString back into a String
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the byte array (referenced by the provided BytesRef)
             previously returned by compressString back into a String
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateTools" -->
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a Date to a string suitable for indexing.
            </summary>
            <param name="date"> the date to be converted </param>
            <param name="resolution"> the desired resolution, see
             <seealso cref="!:#round(Date, DateTools.Resolution)"/> </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
             depending on <code>resolution</code>; using GMT as timezone  </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a millisecond time to a string suitable for indexing.
            </summary>
            <param name="time"> the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT </param>
            <param name="resolution"> the desired resolution, see
             <seealso cref="!:#round(long, DateTools.Resolution)"/> </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
             depending on <code>resolution</code>; using GMT as timezone </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary>
            Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT.
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT </returns>
            <exception cref="!:ParseException"> if <code>dateString</code> is not in the
             expected format  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary>
            Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as a
            Date object.
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the parsed time as a Date object </returns>
            <exception cref="!:ParseException"> if <code>dateString</code> is not in the
             expected format  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
            will be changed to <code>2004-09-01 00:00:00</code> when using
            <code>Resolution.MONTH</code>.
            </summary>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <code>resolution</code>
             set to 0 or 1 </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <code>1095767411000</code>
            (which represents 2004-09-21 13:50:11) will be changed to
            <code>1093989600000</code> (2004-09-01 00:00:00) when using
            <code>Resolution.MONTH</code>.
            </summary>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <code>resolution</code>
             set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT </returns>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools.Resolution">
            <summary>
            Specifies the time granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.YEAR">
            <summary>
            Limit a date's resolution to year granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MONTH">
            <summary>
            Limit a date's resolution to month granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.DAY">
            <summary>
            Limit a date's resolution to day granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.HOUR">
            <summary>
            Limit a date's resolution to hour granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MINUTE">
            <summary>
            Limit a date's resolution to minute granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.SECOND">
            <summary>
            Limit a date's resolution to second granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MILLISECOND">
            <summary>
            Limit a date's resolution to millisecond granularity. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DerefBytesDocValuesField" -->
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for bytes DocValues: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for bytes DocValues: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)" -->
        <member name="T:Lucene.Net.Documents.Document">
             <summary>
             Documents are the unit of indexing and search.
            
             A Document is a set of fields.  Each field has a name and a textual value.
             A field may be <seealso cref="!:Lucene.Net.Index.IndexableFieldType#stored() stored"/> with the document, in which
             case it is returned with search hits on the document.  Thus each document
             should typically contain one or more stored fields which uniquely identify
             it.
            
             <p>Note that fields which are <i>not</i> <seealso cref="!:Lucene.Net.Index.IndexableFieldType#stored() stored"/> are
             <i>not</i> available in documents retrieved from the index, e.g. with {@link
             ScoreDoc#doc} or <seealso cref="!:IndexReader#document(int)"/>.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>
            Constructs a new document with no fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Index.IndexableField)">
            <summary>
            <p>Adds a field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</p>
            <p> Note that add like the removeField(s) methods only makes sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary>
            <p>Removes field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first field that has been added.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary>
            <p>Removes all fields with the given name from the document.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary>
            Returns an array of byte arrays for of the fields that have the name specified
            as the method parameter.  this method returns an empty
            array when there are no matching fields.  It never
            returns null.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <code>BytesRef[]</code> of binary field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary>
            Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. this method will return <code>null</code>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            </summary>
            <param name="name"> the name of the field. </param>
            <returns> a <code>BytesRef</code> containing the binary field value or <code>null</code> </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>
            Returns a field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary>
            Returns an array of <seealso cref="T:Lucene.Net.Index.IndexableField"/>s with the given name.
            this method returns an empty array when there are no
            matching fields.  It never returns null.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <code>IndexableField[]</code> array </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary>
            Returns an array of values of the field specified as the method parameter.
            this method returns an empty array when there are no
            matching fields.  It never returns null.
            For <seealso cref="T:Lucene.Net.Documents.IntField"/>, <seealso cref="T:Lucene.Net.Documents.LongField"/>, {@link
            FloatField} and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instances back, use <seealso cref="!:#getFields"/>. </summary>
            <param name="name"> the name of the field </param>
            <returns> a <code>String[]</code> of field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>
            Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            For <seealso cref="T:Lucene.Net.Documents.IntField"/>, <seealso cref="T:Lucene.Net.Documents.LongField"/>, {@link
            FloatField} and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instance back, use <seealso cref="!:#getField"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>
            Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Document.Fields">
            <summary>
            Returns a List of all the fields in a document.
            <p>Note that fields which are <i>not</i> stored are
            <i>not</i> available in documents retrieved from the
            index, e.g. <seealso cref="!:IndexSearcher#doc(int)"/> or {@link
            IndexReader#document(int)}.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DocumentStoredFieldVisitor" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.StoredFieldVisitor" -->
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.BinaryField(Lucene.Net.Index.FieldInfo,System.Byte[])">
            <summary>
            Process a binary field. </summary>
            <param name="value"> newly allocated byte array with the binary contents.  </param>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.StringField(Lucene.Net.Index.FieldInfo,System.String)">
            <summary>
            Process a string field </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.IntField(Lucene.Net.Index.FieldInfo,System.Int32)">
            <summary>
            Process a int numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.LongField(Lucene.Net.Index.FieldInfo,System.Int64)">
            <summary>
            Process a long numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.FloatField(Lucene.Net.Index.FieldInfo,System.Single)">
            <summary>
            Process a float numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.DoubleField(Lucene.Net.Index.FieldInfo,System.Double)">
            <summary>
            Process a double numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.NeedsField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Hook before processing a field.
            Before a field is processed, this method is invoked so that
            subclasses can return a <seealso cref="T:Lucene.Net.Index.StoredFieldVisitor.Status"/> representing whether
            they need that particular field or not, or to stop processing
            entirely.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldVisitor.Status">
            <summary>
            Enumeration of possible return values for <seealso cref="!:#needsField"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.YES">
            <summary>
            YES: the field should be visited. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.NO">
            <summary>
            NO: don't visit this field, but continue processing fields for this document. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.STOP">
            <summary>
            STOP: don't visit this field and stop processing any other fields for this document. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})">
            <summary>
            Load only fields named in the provided <code>Set&lt;String&gt;</code>. </summary>
            <param name="fieldsToAdd"> Set of fields to load, or <code>null</code> (all fields). </param>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.String[])">
            <summary>
            Load only fields named in the provided fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor">
            <summary>
            Load all stored fields. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.DocumentStoredFieldVisitor.Document">
            <summary>
            Retrieve the visited document. </summary>
            <returns> Document populated with stored fields. Note that only
                    the stored information in the field instances is valid,
                    data such as boosts, indexing options, term vector options,
                    etc is not set. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DoubleDocValuesField" -->
        <member name="M:Lucene.Net.Documents.DoubleDocValuesField.#ctor(System.String,System.Double)">
            <summary>
            Creates a new DocValues field with the specified 64-bit double value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DoubleField" -->
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_NOT_STORED">
            <summary>
            Type for a DoubleField that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_STORED">
            <summary>
            Type for a stored DoubleField:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored DoubleField with the provided value
             and default <code>precisionStep</code> {@link
             NumericUtils#PRECISION_STEP_DEFAULT} (4). </summary>
             <param name="name"> field name </param>
             <param name="value"> 64-bit double value </param>
             <param name="stored"> Store.YES if the content should also be stored </param>
             <exception cref="!:IllegalArgumentException"> if the field name is null.  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the {@link
             FieldType}. </summary>
             <param name="name"> field name </param>
             <param name="value"> 64-bit double value </param>
             <param name="type"> customized field type: must have <seealso cref="!:FieldType#numericType()"/>
                    of <seealso cref="!:FieldType.NumericType#DOUBLE"/>. </param>
             <exception cref="!:IllegalArgumentException"> if the field name or type is null, or
                     if the field type does not have a DOUBLE numericType() </exception>
        </member>
        <member name="M:Lucene.Net.Documents.FieldExtensions.ToTermVector(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get the best representation of a TermVector given the flags.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldType">
            <summary>
            Describes the properties of a field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexableFieldType">
            <summary>
            Describes the properties of a field.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexableFieldType.Indexed">
            <summary>
            True if this field should be indexed (inverted) </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexableFieldType.Stored">
            <summary>
            True if the field's value should be stored </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.Tokenized" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.StoreTermVectors" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.StoreTermVectorOffsets" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.StoreTermVectorPositions" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.StoreTermVectorPayloads" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexableFieldType.OmitNorms" -->
        <member name="P:Lucene.Net.Index.IndexableFieldType.IndexOptions">
            <summary>
            <seealso cref="P:Lucene.Net.Index.IndexableFieldType.IndexOptions"/>, describing what should be
            recorded into the inverted index
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexableFieldType.DocValueType">
            <summary>
            DocValues <seealso cref="!:DocValuesType"/>: if non-null then the field's value
            will be indexed into docValues.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor(Lucene.Net.Documents.FieldType)">
            <summary>
            Create a new mutable FieldType with all of the properties from <code>ref</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor">
            <summary>
            Create a new FieldType with default properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.Freeze">
            <summary>
            Prevents future changes. Note, it is recommended that this is called once
            the FieldTypes's properties have been set, to prevent unintentional state
            changes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.ToString">
            <summary>
            Prints a Field for human consumption. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.Indexed" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.Stored" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.Tokenized" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.StoreTermVectors" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.StoreTermVectorOffsets" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.StoreTermVectorPositions" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.StoreTermVectorPayloads" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.OmitNorms" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.IndexOptions" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.NumericTypeValue" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.NumericPrecisionStep" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Documents.FieldType.DocValueType" -->
        <member name="T:Lucene.Net.Documents.FieldType.NumericType">
            <summary>
            Data type of the numeric value
            @since 3.2
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldType.NumericType.INT">
            <summary>
            32-bit integer numeric type </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldType.NumericType.LONG">
            <summary>
            64-bit long numeric type </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldType.NumericType.FLOAT">
            <summary>
            32-bit float numeric type </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldType.NumericType.DOUBLE">
            <summary>
            64-bit double numeric type </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.FloatDocValuesField" -->
        <member name="M:Lucene.Net.Documents.FloatDocValuesField.#ctor(System.String,System.Single)">
            <summary>
            Creates a new DocValues field with the specified 32-bit float value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit float value </param>
            <exception cref="T:System.ArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.FloatField" -->
        <member name="F:Lucene.Net.Documents.FloatField.TYPE_NOT_STORED">
            <summary>
            Type for a FloatField that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FloatField.TYPE_STORED">
            <summary>
            Type for a stored FloatField:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FloatField.#ctor(System.String,System.Single,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored FloatField with the provided value
             and default <code>precisionStep</code> {@link
             NumericUtils#PRECISION_STEP_DEFAULT} (4). </summary>
             <param name="name"> field name </param>
             <param name="value"> 32-bit double value </param>
             <param name="stored"> Store.YES if the content should also be stored </param>
             <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.FloatField.#ctor(System.String,System.Single,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the {@link
             FieldType}. </summary>
             <param name="name"> field name </param>
             <param name="value"> 32-bit float value </param>
             <param name="type"> customized field type: must have <seealso cref="!:FieldType#numericType()"/>
                    of <seealso cref="!:FieldType.NumericType#FLOAT"/>. </param>
             <exception cref="!:IllegalArgumentException"> if the field name or type is null, or
                     if the field type does not have a FLOAT numericType() </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.IntDocValuesField" -->
        <member name="M:Lucene.Net.Documents.IntDocValuesField.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new DocValues field with the specified 32-bit integer value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit integer value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.IntField" -->
        <member name="F:Lucene.Net.Documents.IntField.TYPE_NOT_STORED">
            <summary>
            Type for an IntField that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.IntField.TYPE_STORED">
            <summary>
            Type for a stored IntField:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.IntField.#ctor(System.String,System.Int32,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored IntField with the provided value
             and default <code>precisionStep</code> {@link
             NumericUtils#PRECISION_STEP_DEFAULT} (4). </summary>
             <param name="name"> field name </param>
             <param name="value"> 32-bit integer value </param>
             <param name="stored"> Store.YES if the content should also be stored </param>
             <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.IntField.#ctor(System.String,System.Int32,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the {@link
             FieldType}. </summary>
             <param name="name"> field name </param>
             <param name="value"> 32-bit integer value </param>
             <param name="type"> customized field type: must have <seealso cref="!:FieldType#numericType()"/>
                    of <seealso cref="!:FieldType.NumericType#INT"/>. </param>
             <exception cref="!:IllegalArgumentException"> if the field name or type is null, or
                     if the field type does not have a INT numericType() </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.LongDocValuesField" -->
        <member name="M:Lucene.Net.Documents.LongDocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new DocValues field with the specified 64-bit long value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit long value </param>
            <exception cref="T:System.ArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.LongField" -->
        <member name="F:Lucene.Net.Documents.LongField.TYPE_NOT_STORED">
            <summary>
            Type for a LongField that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.LongField.TYPE_STORED">
            <summary>
            Type for a stored LongField:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.LongField.#ctor(System.String,System.Int64,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored LongField with the provided value
             and default <code>precisionStep</code> {@link
             NumericUtils#PRECISION_STEP_DEFAULT} (4). </summary>
             <param name="name"> field name </param>
             <param name="value"> 64-bit long value </param>
             <param name="stored"> Store.YES if the content should also be stored </param>
             <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.LongField.#ctor(System.String,System.Int64,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the {@link
             FieldType}. </summary>
             <param name="name"> field name </param>
             <param name="value"> 64-bit long value </param>
             <param name="type"> customized field type: must have <seealso cref="!:FieldType#numericType()"/>
                    of <seealso cref="!:FieldType.NumericType#LONG"/>. </param>
             <exception cref="!:IllegalArgumentException"> if the field name or type is null, or
                     if the field type does not have a LONG numericType() </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.PackedLongDocValuesField" -->
        <member name="M:Lucene.Net.Documents.PackedLongDocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new DocValues field with the specified long value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit long value </param>
            <exception cref="T:System.ArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.ShortDocValuesField" -->
        <member name="M:Lucene.Net.Documents.ShortDocValuesField.#ctor(System.String,System.Int16)">
            <summary>
            Creates a new DocValues field with the specified 16-bit short value </summary>
            <param name="name"> field name </param>
            <param name="value"> 16-bit short value </param>
            <exception cref="T:System.ArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.SortedBytesDocValuesField" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.SortedDocValuesField" -->
        <member name="F:Lucene.Net.Documents.SortedDocValuesField.TYPE">
            <summary>
            Type for sorted bytes DocValues
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for sorted bytes DocValues: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for sorted bytes DocValues: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length sorted DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length sorted DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.SortedSetDocValuesField" -->
        <member name="F:Lucene.Net.Documents.SortedSetDocValuesField.TYPE">
            <summary>
            Type for sorted bytes DocValues
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedSetDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StoredField">
            <summary>
            A field whose value is stored so that {@link
             IndexSearcher#doc} and <seealso cref="!:IndexReader#document"/> will
             return the field and its value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StoredField.TYPE">
            <summary>
            Type for a stored-only field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.StoredField.#ctor(System.String,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.String)">
            <summary>
            Create a stored-only field with the given string value. </summary>
            <param name="name"> field name </param>
            <param name="value"> string value </param>
            <exception cref="!:IllegalArgumentException"> if the field name or value is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int32)">
            <summary>
            Create a stored-only field with the given integer value. </summary>
            <param name="name"> field name </param>
            <param name="value"> integer value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Single)">
            <summary>
            Create a stored-only field with the given float value. </summary>
            <param name="name"> field name </param>
            <param name="value"> float value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int64)">
            <summary>
            Create a stored-only field with the given long value. </summary>
            <param name="name"> field name </param>
            <param name="value"> long value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Double)">
            <summary>
            Create a stored-only field with the given double value. </summary>
            <param name="name"> field name </param>
            <param name="value"> double value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.StraightBytesDocValuesField" -->
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for direct bytes DocValues: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for direct bytes DocValues: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable length DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length direct DocValues field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StringField">
            <summary>
            A field that is indexed but not tokenized: the entire
             String value is indexed as a single token.  For example
             this might be used for a 'country' field or an 'id'
             field, or any field that you intend to use for sorting
             or access through the field cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_NOT_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
             DOCS_ONLY, not stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
             DOCS_ONLY, stored
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StringField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new StringField. </summary>
             <param name="name"> field name </param>
             <param name="value"> String value </param>
             <param name="stored"> Store.YES if the content should also be stored </param>
             <exception cref="!:IllegalArgumentException"> if the field name or value is null. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.TextField">
            <summary>
            A field that is indexed and tokenized, without term
             vectors.  For example this would be used on a 'body'
             field, that contains the bulk of a document's text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_NOT_STORED">
            <summary>
            Indexed, tokenized, not stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_STORED">
            <summary>
            Indexed, tokenized, stored. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.IO.TextReader)">
            <summary>
            Creates a new un-stored TextField with Reader value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> reader value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null </exception>
            <exception cref="!:NullPointerException"> if the reader is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new TextField with String value. </summary>
            <param name="name"> field name </param>
            <param name="value"> string value </param>
            <param name="store"> Store.YES if the content should also be stored </param>
            <exception cref="!:IllegalArgumentException"> if the field name or value is null. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new un-stored TextField with TokenStream value. </summary>
            <param name="name"> field name </param>
            <param name="stream"> TokenStream value </param>
            <exception cref="!:IllegalArgumentException"> if the field name is null. </exception>
            <exception cref="!:NullPointerException"> if the tokenStream is null </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.AtomicReader" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexReader" -->
        <member name="M:Lucene.Net.Index.IndexReader.AddReaderClosedListener(Lucene.Net.Index.IndexReader.ReaderClosedListener)">
             <summary>
             Expert: adds a <seealso cref="T:Lucene.Net.Index.IndexReader.ReaderClosedListener"/>.  The
             provided listener will be invoked when this reader is closed.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RemoveReaderClosedListener(Lucene.Net.Index.IndexReader.ReaderClosedListener)">
             <summary>
             Expert: remove a previously added <seealso cref="T:Lucene.Net.Index.IndexReader.ReaderClosedListener"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RegisterParentReader(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: this method is called by {@code IndexReader}s which wrap other readers
            (e.g. <seealso cref="T:Lucene.Net.Index.CompositeReader"/> or <seealso cref="T:Lucene.Net.Index.FilterAtomicReader"/>) to register the parent
            at the child (this reader) on construction of the parent. When this reader is closed,
            it will mark all registered parents as closed, too. The references to parent readers
            are weak only, so they can be GCed once they are no longer in use.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.IncRef" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TryIncRef" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.DecRef" -->
        <member name="M:Lucene.Net.Index.IndexReader.EnsureOpen">
            <summary>
            Throws AlreadyClosedException if this IndexReader or any
            of its child readers is closed, otherwise returns.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Equals(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetHashCode" -->
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a IndexReader reading the index in the given
             Directory </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            @deprecated Use <seealso cref="!:DirectoryReader#open(Directory)"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a IndexReader reading the index in the given
             Directory with the given termInfosIndexDivisor. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as {@link
             IndexWriterConfig#setTermIndexInterval} except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to N, then one in every
             N*termIndexInterval terms in the index is loaded into
             memory.  By setting this to a value &gt; 1 you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            @deprecated Use <seealso cref="!:DirectoryReader#open(Directory,int)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)" -->
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an IndexReader reading the index in the given
             <seealso cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            @deprecated Use <seealso cref="!:DirectoryReader#open(IndexCommit)"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an IndexReader reading the index in the given
             <seealso cref="T:Lucene.Net.Index.IndexCommit"/> and termInfosIndexDivisor. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as {@link
             IndexWriterConfig#setTermIndexInterval} except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to N, then one in every
             N*termIndexInterval terms in the index is loaded into
             memory.  By setting this to a value &gt; 1 you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            @deprecated Use <seealso cref="!:DirectoryReader#open(IndexCommit,int)"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVectors(System.Int32)">
            <summary>
            Retrieve term vectors for this document, or null if
             term vectors were not indexed.  The returned Fields
             instance acts like a single-document inverted index
             (the docID will be 0).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVector(System.Int32,System.String)">
            <summary>
            Retrieve term vector for this document and field, or
             null if term vectors were not indexed.  The returned
             Fields instance acts like a single-document inverted
             index (the docID will be 0).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Expert: visits the fields of a stored document, for
             custom processing/loading of each field.  If you
             simply want to load all fields, use {@link
             #document(int)}.  If you want to load a subset, use
             <seealso cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Document(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            <summary>
            Like <seealso cref="!:#document(int)"/> but only loads the specified
            fields.  Note that this is simply sugar for {@link
            DocumentStoredFieldVisitor#DocumentStoredFieldVisitor(Set)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Dispose">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
            <exception cref="T:System.IO.IOException">If there is a low-level IO error</exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>
            Implements close. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the total number of occurrences of {@code term} across all
            documents (the sum of the freq() for each doc that has this term). this
            will be -1 if the codec doesn't support this measure. Note that, like other
            term measures, this measure does not take deleted documents into account.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetSumDocFreq(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetDocCount(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetSumTotalTermFreq(System.String)" -->
        <member name="P:Lucene.Net.Index.IndexReader.RefCount">
            <summary>
            Expert: returns the current refCount for this reader </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>
            Returns the number of documents in this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>
            Returns one greater than the largest possible document number.
            this may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>
            Returns true if any documents have been deleted. Implementers should
             consider overriding this method if <seealso cref="!:#maxDoc()"/> or <seealso cref="!:#numDocs()"/>
             are not constant-time operations.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexReader.Context" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexReader.Leaves" -->
        <member name="P:Lucene.Net.Index.IndexReader.CoreCacheKey">
            <summary>
            Expert: Returns a key for this IndexReader, so FieldCache/CachingWrapperFilter can find
            it again.
            this key must not have equals()/hashCode() methods, so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey">
            <summary>
            Expert: Returns a key for this IndexReader that also includes deletions,
            so FieldCache/CachingWrapperFilter can find it again.
            this key must not have equals()/hashCode() methods, so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader.ReaderClosedListener">
             <summary>
             A custom listener that's invoked when the IndexReader
             is closed.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.ReaderClosedListener.OnClose(Lucene.Net.Index.IndexReader)">
            <summary>
            Invoked when the <seealso cref="T:Lucene.Net.Index.IndexReader"/> is closed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.HasNorms(System.String)">
            <summary>
            Returns true if there are norms stored for this field. </summary>
            @deprecated (4.0) use <seealso cref="!:#getFieldInfos()"/> and check <seealso cref="!:FieldInfo#hasNorms()"/>
                              for the field instead.
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the number of documents containing the term
            <code>t</code>.  this method returns 0 if the term or
            field does not exists.  this method does not take into
            account deleted documents that have not yet been merged
            away.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.Terms(System.String)">
            <summary>
            this may return null if the field does not exist. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.AtomicReader.TermDocsEnum(Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.AtomicReader.TermPositionsEnum(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> for this field, or
             null if no <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> were indexed for
             this field.  The returned instance should only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetBinaryDocValues(System.String)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field, or
             null if no <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> were indexed for
             this field.  The returned instance should only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedDocValues(System.String)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> for this field, or
             null if no <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> were indexed for
             this field.  The returned instance should only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedSetDocValues(System.String)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field, or
             null if no <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/> were indexed for
             this field.  The returned instance should only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetDocsWithField(System.String)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Util.Bits"/> at the size of <code>reader.maxDoc()</code>,
             with turned on bits for each docid that does have a value for this field,
             or null if no DocValues were indexed for this field. The
             returned instance should only be used by a single thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetNormValues(System.String)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> representing norms
             for this field, or null if no <seealso cref="T:Lucene.Net.Index.NumericDocValues"/>
             were indexed. The returned instance should only be
             used by a single thread.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.AtomicReader.CheckIntegrity" -->
        <member name="P:Lucene.Net.Index.AtomicReader.Fields">
            <summary>
            Returns <seealso cref="P:Lucene.Net.Index.AtomicReader.Fields"/> for this reader.
            this method may return null if the reader has no
            postings.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.FieldInfos">
            <summary>
            Get the <seealso cref="P:Lucene.Net.Index.AtomicReader.FieldInfos"/> describing all fields in
            this reader.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.LiveDocs">
             <summary>
             Returns the <seealso cref="T:Lucene.Net.Util.Bits"/> representing live (not
              deleted) docs.  A set bit indicates the doc ID has not
              been deleted.  If this method returns null it means
              there are no deleted documents (all documents are
              live).
            
              The returned instance has been safely published for
              use by multiple threads without additional
              synchronization.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.AtomicReaderContext">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/> for <seealso cref="P:Lucene.Net.Index.AtomicReaderContext.AtomicReader"/> instances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexReaderContext">
            <summary>
            A struct like class that represents a hierarchical relationship between
            <seealso cref="T:Lucene.Net.Index.IndexReader"/> instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReaderContext.Parent">
            <summary>
            The reader context for this reader's immediate parent, or null if none </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReaderContext.IsTopLevel">
            <summary>
            <code>true</code> if this context struct represents the top level reader within the hierarchical context </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReaderContext.DocBaseInParent">
            <summary>
            the doc base for this reader in the parent, <tt>0</tt> if parent is null </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReaderContext.OrdInParent">
            <summary>
            the ord for this reader in the parent, <tt>0</tt> if parent is null </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Reader">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Index.IndexReader"/>, this context represents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexReaderContext.Leaves" -->
        <member name="P:Lucene.Net.Index.IndexReaderContext.Children">
            <summary>
            Returns the context's children iff this context is a composite context
            otherwise <code>null</code>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.AtomicReaderContext.Ord">
            <summary>
            The readers ord in the top-level's leaves array </summary>
        </member>
        <member name="F:Lucene.Net.Index.AtomicReaderContext.DocBase">
            <summary>
            The readers absolute doc base </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.AtomicReader,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.BaseCompositeReader`1" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CompositeReader" -->
        <member name="M:Lucene.Net.Index.CompositeReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders" -->
        <member name="F:Lucene.Net.Index.BaseCompositeReader`1.SubReadersList">
            <summary>
            List view solely for <seealso cref="!:#getSequentialSubReaders()"/>,
            for effectiveness the array is used internally.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.#ctor(`0[])">
            <summary>
            Constructs a {@code BaseCompositeReader} on the given subReaders. </summary>
            <param name="subReaders"> the wrapped sub-readers. this array is returned by
            <seealso cref="!:#getSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification, the subclass is responsible
            to do this. </param>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderIndex(System.Int32)">
            <summary>
            Helper method for subclasses to get the corresponding reader for a doc ID </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderBase(System.Int32)">
            <summary>
            Helper method for subclasses to get the docBase of the given sub-reader index. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesFieldUpdates">
             <summary>
             A <seealso cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
             <seealso cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates">
             <summary>
             Holds updates of a single DocValues field, for a set of documents.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Add(System.Int32,System.Object)">
            <summary>
            Add an update to a document. For unsetting a value you should pass
            {@code null}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.GetIterator">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator"/> over the updated documents and their
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Merge(Lucene.Net.Index.DocValuesFieldUpdates)">
            <summary>
            Merge with another <seealso cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/>. this is called for a
            segment which received updates while it was being merged. The given updates
            should override whatever updates are in that instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Any">
            <summary>
            Returns true if this instance contains any updates. </summary>
            <returns> TODO </returns>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator">
            <summary>
            An iterator over documents and their updated values. Only documents with
            updates are returned by this iterator, and the documents are returned in
            increasing order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc">
            <summary>
            Returns the next document which has an update, or
            <seealso cref="!:DocIdSetIterator#NO_MORE_DOCS"/> if there are no more documents to
            return.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Doc">
            <summary>
            Returns the current document this iterator is on. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Value">
            <summary>
            Returns the value of the document returned from <seealso cref="!:#nextDoc()"/>. A
            {@code null} value means that it was unset for this document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Reset">
            <summary>
            Reset the iterator's state. Should be called before <seealso cref="!:#nextDoc()"/>
            and <seealso cref="!:#value()"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.InPlaceMergeSorter">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Sorter"/> implementation based on the merge-sort algorithm that merges
             in place (no extra memory will be allocated). Small arrays are sorted with
             insertion sort.
             @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Sorter">
            <summary>
            Base class for sorting algorithms implementations.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.#ctor">
            <summary>
            Sole constructor, used for inheritance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Compare(System.Int32,System.Int32)">
            <summary>
            Compare entries found in slots <code>i</code> and <code>j</code>.
             The contract for the returned value is the same as
             <seealso cref="!:Comparator#compare(Object, Object)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Swap(System.Int32,System.Int32)">
            <summary>
            Swap values at slots <code>i</code> and <code>j</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <code>from</code> (inclusive) and ends at
             <code>to</code> (exclusive).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.InPlaceMergeSorter.#ctor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesWriter">
            <summary>
            Buffers up pending byte[] per doc, then flushes when
             segment flushes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.BinaryDocValuesWriter.MAX_LENGTH">
            <summary>
            Maximum length for a binary field. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BitsSlice">
             <summary>
             Exposes a slice of an existing Bits as a new Bits.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.ApplyDeletesAndUpdates(Lucene.Net.Index.IndexWriter.ReaderPool,System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Resolves the buffered deleted Term/Query/docIDs, into
             actual deleted docIDs in the liveDocs MutableBits for
             each SegmentReader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceWriter">
            <summary>
            Class to write byte streams into slices of shared
            byte[].  this is used by DocumentsWriter to hold the
            posting list for many terms in RAM.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.DataOutput" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteInt(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteShort(System.Int16)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteVInt(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteLong(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteVLong(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteString(System.String)" -->
        <member name="M:Lucene.Net.Store.DataOutput.CopyBytes(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Copy numBytes bytes from input to ourself. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})" -->
        <member name="M:Lucene.Net.Index.ByteSliceWriter.Init(System.Int32)">
            <summary>
            Set up the writer to write at address.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.WriteByte(System.Byte)">
            <summary>
            Write byte into byte slice stream </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CheckIndex" -->
        <member name="M:Lucene.Net.Index.CheckIndex.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Create a new CheckIndex on the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.SetInfoStream(System.IO.StreamWriter,System.Boolean)">
            <summary>
            Set infoStream where messages should go.  If null, no
             messages are printed.  If verbose is true then more
             details are printed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.DoCheckIndex" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})" -->
        <member name="M:Lucene.Net.Index.CheckIndex.TestFieldNorms(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter)">
            <summary>
            Test field norms.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.CheckFields(Lucene.Net.Index.Fields,Lucene.Net.Util.Bits,System.Int32,Lucene.Net.Index.FieldInfos,System.Boolean,System.Boolean,System.IO.StreamWriter,System.Boolean)">
            <summary>
            checks Fields api is consistent with itself.
            searcher is optional, to verify with queries. Can be null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter)">
            <summary>
            Test the term index.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter,System.Boolean)">
            <summary>
            Test the term index.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestStoredFields(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter)">
            <summary>
            Test stored fields.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestDocValues(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter)">
            <summary>
            Test docvalues.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter)">
            <summary>
            Test term vectors.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.StreamWriter,System.Boolean,System.Boolean)">
            <summary>
            Test term vectors.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)" -->
        <member name="P:Lucene.Net.Index.CheckIndex.CrossCheckTermVectors">
            <summary>
            If true, term vectors are compared against postings to
             make sure they are the same.  this will likely
             drastically increase time it takes to run CheckIndex!
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.InfoStream">
            <summary>
            Set infoStream where messages should go. See <seealso cref="!:#setInfoStream(PrintStream,boolean)"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status">
             <summary>
             Returned from <seealso cref="!:#checkIndex()"/> detailing the health and status of the index.
            
             @lucene.experimental
            
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.Clean">
            <summary>
            True if no problems were found with the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.MissingSegments">
            <summary>
            True if we were unable to locate and load the segments_N file. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.CantOpenSegments">
            <summary>
            True if we were unable to open the segments_N file. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.MissingSegmentVersion">
            <summary>
            True if we were unable to read the version number from segments_N file. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentsFileName">
            <summary>
            Name of latest segments_N file in the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.NumSegments">
            <summary>
            Number of segments in the index. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.CheckIndex.Status.SegmentsChecked" -->
        <member name="F:Lucene.Net.Index.CheckIndex.Status.ToolOutOfDate">
            <summary>
            True if the index was created with a newer version of Lucene than the CheckIndex tool. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfos">
            <summary>
            List of <seealso cref="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus"/> instances, detailing status of each segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.Dir">
            <summary>
            Directory index is in. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.NewSegments">
            <summary>
            SegmentInfos instance containing only segments that
            had no problems (this is used with the <seealso cref="!:CheckIndex#fixIndex"/>
            method to repair the index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TotLoseDocCount">
            <summary>
            How many documents will be lost to bad segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.NumBadSegments">
            <summary>
            How many bad segments were found. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.Partial">
            <summary>
            True if we checked only specific segments ({@link
            #checkIndex(List)}) was called with non-null
            argument).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.MaxSegmentName">
            <summary>
            The greatest segment name. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.ValidCounter">
            <summary>
            Whether the SegmentInfos.counter is greater than any of the segments' names. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.UserData">
            <summary>
            Holds the userData of the last commit in the index </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus">
             <summary>
             Holds the status of each segment in the index.
              See <seealso cref="!:#segmentInfos"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Name">
            <summary>
            Name of the segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Codec">
            <summary>
            Codec used to read this segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocCount">
            <summary>
            Document count (does not take deletions into account). </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Compound">
            <summary>
            True if segment is compound file format. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFiles">
            <summary>
            Number of files referenced by this segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.SizeMB">
            <summary>
            Net size (MB) of the files referenced by this
             segment.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreOffset">
            <summary>
            Doc store offset, if this segment shares the doc
             store files (stored fields and term vectors) with
             other segments.  this is -1 if it does not share.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreSegment">
            <summary>
            String of the shared doc store segment, or null if
             this segment does not share the doc store files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreCompoundFile">
            <summary>
            True if the shared doc store files are compound file
             format.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.HasDeletions">
            <summary>
            True if this segment has pending deletions. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DeletionsGen">
            <summary>
            Current deletions generation. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumDeleted">
            <summary>
            Number of deleted documents. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.OpenReaderPassed">
            <summary>
            True if we were able to open an AtomicReader on this
             segment.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFields">
            <summary>
            Number of fields in this segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Diagnostics">
            <summary>
            Map that includes certain
             debugging details that IndexWriter records into
             each segment it creates
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.FieldNormStatus">
            <summary>
            Status for testing of field norms (null if field norms could not be tested). </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermIndexStatus">
            <summary>
            Status for testing of indexed terms (null if indexed terms could not be tested). </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.StoredFieldStatus">
            <summary>
            Status for testing of stored fields (null if stored fields could not be tested). </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermVectorStatus">
            <summary>
            Status for testing of term vectors (null if term vectors could not be tested). </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocValuesStatus">
            <summary>
            Status for testing of DocValues (null if DocValues could not be tested). </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus">
            <summary>
            Status from testing field norms.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.TotFields">
            <summary>
            Number of fields successfully tested </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.Error">
            <summary>
            Exception thrown during term index test (null on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus">
            <summary>
            Status from testing term index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TermCount">
            <summary>
            Number of terms with at least one live doc. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.DelTermCount">
            <summary>
            Number of terms with zero live docs docs. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotFreq">
            <summary>
            Total frequency across all terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotPos">
            <summary>
            Total number of positions. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.Error">
            <summary>
            Exception thrown during term index test (null on success) </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.BlockTreeStats">
            <summary>
            Holds details of block allocations in the block
             tree terms dictionary (this is only set if the
             <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> for this segment uses block
             tree.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.TotFields">
            <summary>
            Total number of stored fields tested. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.Error">
            <summary>
            Exception thrown during stored fields test (null on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.TotVectors">
            <summary>
            Total number of term vectors tested. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.Error">
            <summary>
            Exception thrown during term vector test (null on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus">
            <summary>
            Status from testing DocValues
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalValueFields">
            <summary>
            Total number of docValues tested. </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalNumericFields">
            <summary>
            Total number of numeric fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalBinaryFields">
            <summary>
            Total number of binary fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedFields">
            <summary>
            Total number of sorted fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedSetFields">
            <summary>
            Total number of sortedset fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.Error">
            <summary>
            Exception thrown during doc values test (null on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompositeReaderContext">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/> for <seealso cref="T:Lucene.Net.Index.CompositeReader"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.CompositeReader,System.Int32,System.Int32,System.Collections.Generic.List{Lucene.Net.Index.IndexReaderContext})">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.CompositeReaderContext"/> for intermediate readers that aren't
            not top-level readers in the current context
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReader,System.Collections.Generic.List{Lucene.Net.Index.IndexReaderContext},System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.CompositeReaderContext"/> for top-level readers with parent set to <code>null</code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler">
             <summary>
             A <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> that runs each merge using a
              separate thread.
            
              <p>Specify the max number of threads that may run at
              once, and the maximum number of simultaneous merges
              with <seealso cref="!:#setMaxMergesAndThreads"/>.</p>
            
              <p>If the number of merges exceeds the max number of threads
              then the largest merges are paused until one of the smaller
              merges completes.</p>
            
              <p>If more than <seealso cref="!:#getMaxMergeCount"/> merges are
              requested then this class will forcefully throttle the
              incoming threads by pausing until one more more merges
              complete.</p>
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeScheduler">
            <summary>
            <p>Expert: <seealso cref="T:Lucene.Net.Index.IndexWriter"/> uses an instance
             implementing this interface to execute the merges
             selected by a <seealso cref="T:Lucene.Net.Index.MergePolicy"/>.  The default
             MergeScheduler is <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>.</p>
             <p>Implementers of sub-classes should make sure that <seealso cref="!:#clone()"/>
             returns an independent instance able to work with any <seealso cref="T:Lucene.Net.Index.IndexWriter"/>
             instance.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Run the merges provided by <seealso cref="!:IndexWriter#getNextMerge()"/>. </summary>
            <param name="writer"> the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> to obtain the merges from. </param>
            <param name="trigger"> the <seealso cref="T:Lucene.Net.Index.MergeTrigger"/> that caused this merge to happen </param>
            <param name="newMergesFound"> <code>true</code> iff any new merges were found by the caller otherwise <code>false</code>
             </param>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Dispose">
            <summary>
            Close this MergeScheduler. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_THREAD_COUNT">
            <summary>
            Default {@code maxThreadCount}.
            We default to 1: tests on spinning-magnet drives showed slower
            indexing performance if more than one merge thread runs at
            once (though on an SSD it was faster)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_MERGE_COUNT">
            <summary>
            Default {@code maxMergeCount}. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreads">
            <summary>
            List of currently active <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.Dir">
            <summary>
            <seealso cref="T:Lucene.Net.Store.Directory"/> that holds the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.Writer">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/> that owns this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadCount_Renamed">
            <summary>
            How many <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s have kicked off (this is use
             to name them).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.#ctor">
            <summary>
            Sole constructor, with all settings set to default
             values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)">
            <summary>
            Sets the maximum number of merge threads and simultaneous merges allowed.
            </summary>
            <param name="maxMergeCount"> the max # simultaneous merges that are allowed.
                  If a merge is necessary yet we already have this many
                  threads running, the incoming thread (that is calling
                  add/updateDocument) will block until a merge thread
                  has completed.  Note that we will only run the
                  smallest <code>maxThreadCount</code> merges at a time. </param>
            <param name="maxThreadCount"> the max # simultaneous merge threads that should
                  be running at once.  this must be &lt;= <code>maxMergeCount</code> </param>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.compareByMergeDocCount">
            <summary>
            Sorts <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s; larger merges come first. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.ConcurrentMergeScheduler.UpdateMergeThreads" -->
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Verbose">
             <summary>
             Returns true if verbosing is enabled. this method is usually used in
             conjunction with <seealso cref="!:#message(String)"/>, like that:
            
             <pre class="prettyprint">
             if (verbose()) {
               message("your message");
             }
             </pre>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Message(System.String)">
            <summary>
            Outputs the given message - this method assumes <seealso cref="!:#verbose()"/> was
            called and returned true.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Sync">
            <summary>
            Wait for any running merge threads to finish. this call is not interruptible as used by <seealso cref="!:#close()"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadCount">
            <summary>
            Returns the number of merge threads that are alive. Note that this number
            is &lt;= <seealso cref="!:#mergeThreads"/> size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.DoMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual merge, by calling <seealso cref="!:IndexWriter#merge"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThread(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new MergeThread </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.HandleMergeException(System.Exception)">
            <summary>
            Called when an exception is hit in a background merge
             thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.ClearSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount" -->
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount">
            <summary>
            See <seealso cref="!:#setMaxMergesAndThreads"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadPriority">
            <summary>
            Return the priority that merge threads run at.  By
             default the priority is 1 plus the priority of (ie,
             slightly higher priority than) the first thread that
             calls merge.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread">
            <summary>
            Runs a merge thread, which may run one or more merges
             in sequence.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IThreadRunnable">
            <summary>
            this interface should be implemented by any class whose instances are intended
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IThreadRunnable.Run">
            <summary>
            this method has to be implemented in order that starting of the thread causes the object's
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.ThreadClass._threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="name">The name of the thread</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
            <param name="NanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread. Calling this method
            usually terminates the thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread while also providing
            exception information about the thread termination.
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current object
            </summary>
            <returns>A String that represents the current object</returns>
        </member>
        <member name="M:Lucene.Net.Support.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="P:Lucene.Net.Support.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.#ctor(Lucene.Net.Index.ConcurrentMergeScheduler,Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.RunningMerge">
            <summary>
            Record the currently running merge. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.CurrentMerge">
            <summary>
            Return the current merge, or null if this {@code
             MergeThread} is done.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.ThreadPriority">
            <summary>
            Set the priority of this thread. </summary>
        </member>
        <member name="T:Lucene.Net.Index.CorruptIndexException">
            <summary>
            this exception is thrown when Lucene detects
            an inconsistency in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DirectoryReader" -->
        <member name="F:Lucene.Net.Index.DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR">
            <summary>
            Default termInfosIndexDivisor. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryReader.Directory_Renamed">
            <summary>
            The index directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a IndexReader reading the index in the given
             Directory </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a IndexReader reading the index in the given
             Directory with the given termInfosIndexDivisor. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as {@link
             IndexWriterConfig#setTermIndexInterval} except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to N, then one in every
             N*termIndexInterval terms in the index is loaded into
             memory.  By setting this to a value &gt; 1 you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely.
             <b>NOTE:</b> divisor settings &gt; 1 do not apply to all PostingsFormat
             implementations, including the default one in this release. It only makes
             sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)" -->
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an IndexReader reading the index in the given
             <seealso cref="P:Lucene.Net.Index.DirectoryReader.IndexCommit"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an IndexReader reading the index in the given
             <seealso cref="P:Lucene.Net.Index.DirectoryReader.IndexCommit"/> and termInfosIndexDivisor. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as {@link
             IndexWriterConfig#setTermIndexInterval} except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to N, then one in every
             N*termIndexInterval terms in the index is loaded into
             memory.  By setting this to a value &gt; 1 you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely.
             <b>NOTE:</b> divisor settings &gt; 1 do not apply to all PostingsFormat
             implementations, including the default one in this release. It only makes
             sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)" -->
        <member name="M:Lucene.Net.Index.DirectoryReader.ListCommits(Lucene.Net.Store.Directory)">
            <summary>
            Returns all commit points that exist in the Directory.
             Normally, because the default is {@link
             KeepOnlyLastCommitDeletionPolicy}, there would be only
             one commit point.  But if you're using a custom {@link
             IndexDeletionPolicy} then there could be many commits.
             Once you have a given commit, you can open a reader on
             it by calling <seealso cref="!:DirectoryReader#open(IndexCommit)"/>
             There must be at least one commit in
             the Directory, else this method throws {@link
             IndexNotFoundException}.  Note that if a commit is in
             progress while this method is running, that commit
             may or may not be returned.
            </summary>
             <returns> a sorted list of <seealso cref="P:Lucene.Net.Index.DirectoryReader.IndexCommit"/>s, from oldest
             to latest.  </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary>
            Returns <code>true</code> if an index likely exists at
            the specified directory.  Note that if a corrupt index
            exists, or if an index in the process of committing </summary>
            <param name="directory"> the directory to check for an index </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: Constructs a {@code DirectoryReader} on the given subReaders. </summary>
            <param name="segmentReaders"> the wrapped atomic index segment readers. this array is
            returned by <seealso cref="!:#getSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification outside of this reader.
            Subclasses of {@code DirectoryReader} should take care to not allow
            modification of this internal array, e.g. <seealso cref="!:#doOpenIfChanged()"/>. </param>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged">
            <summary>
            Implement this method to support <seealso cref="!:#openIfChanged(DirectoryReader)"/>.
            If this reader does not support reopen, return {@code null}, so
            client code is happy. this should be consistent with <seealso cref="!:#isCurrent"/>
            (should always return {@code true}) if reopen is not supported. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> null if there are no changes; else, a new
            DirectoryReader instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexCommit)">
            <summary>
            Implement this method to support <seealso cref="!:#openIfChanged(DirectoryReader,IndexCommit)"/>.
            If this reader does not support reopen from a specific <seealso cref="P:Lucene.Net.Index.DirectoryReader.IndexCommit"/>,
            throw <seealso cref="!:UnsupportedOperationException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> null if there are no changes; else, a new
            DirectoryReader instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Implement this method to support <seealso cref="!:#openIfChanged(DirectoryReader,IndexWriter,boolean)"/>.
            If this reader does not support reopen from <seealso cref="T:Lucene.Net.Index.IndexWriter"/>,
            throw <seealso cref="!:UnsupportedOperationException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> null if there are no changes; else, a new
            DirectoryReader instance. </returns>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Version">
             <summary>
             Version number when this IndexReader was opened.
            
             <p>this method
             returns the version recorded in the commit that the
             reader opened.  this version is advanced every time
             a change is made with <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.</p>
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Current">
             <summary>
             Check whether any new changes have occurred to the
             index since this reader was opened.
            
             <p>If this reader was created by calling <seealso cref="!:#open"/>,
             then this method checks if any further commits
             (see <seealso cref="!:IndexWriter#commit"/>) have occurred in the
             directory.</p>
            
             <p>If instead this reader is a near real-time reader
             (ie, obtained by a call to {@link
             DirectoryReader#open(IndexWriter,boolean)}, or by calling <seealso cref="!:#openIfChanged"/>
             on a near real-time reader), then this method checks if
             either a new commit has occurred, or any new
             uncommitted changes have taken place via the writer.
             Note that even if the writer has only performed
             merging, this method will still return false.</p>
            
             <p>In any event, if this returns false, you should call
             <seealso cref="!:#openIfChanged"/> to get a new reader that sees the
             changes.</p>
             </summary>
             <exception cref="T:System.IO.IOException">           if there is a low-level IO error </exception>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.IndexCommit">
            <summary>
            Expert: return the IndexCommit that this reader has opened.
            <p/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.DocFieldConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Called when DocumentsWriterPerThread decides to create a new
             segment
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Abort">
            <summary>
            Called when an aborting exception is hit </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumerPerField.ProcessFields(Lucene.Net.Index.IndexableField[],System.Int32)">
            <summary>
            Processes all occurrences of a single field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessor">
            <summary>
            this is a DocConsumer that gathers all fields under the
            same name, and calls per-field consumers to process field
            by field.  this class doesn't doesn't do any "real" work
            of its own: it just forwards the fields to a
            DocFieldConsumer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessorPerField">
            <summary>
            Holds all per thread, per field state.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverter">
            <summary>
            this is a DocFieldConsumer that inverts each field,
             separately, from a Document, and accepts a
             InvertedTermsConsumer to process those terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverterPerField">
            <summary>
            Holds state for inverting all occurrences of a single
            field in the document.  this class doesn't do anything
            itself; instead, it forwards the tokens produced by
            analysis to its own consumer
            (InvertedDocConsumerPerField).  It also interacts with an
            endConsumer (InvertedDocEndConsumerPerField).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocTermOrds">
             <summary>
             this class enables fast access to multiple term ords for
             a specified field across all docIDs.
            
             Like FieldCache, it uninverts the index and holds a
             packed data structure in RAM to enable fast access.
             Unlike FieldCache, it can handle multi-valued fields,
             and, it does not hold the term bytes in RAM.  Rather, you
             must obtain a TermsEnum from the <seealso cref="!:#getOrdTermsEnum"/>
             method, and then seek-by-ord to get the term's bytes.
            
             While normally term ords are type long, in this API they are
             int as the internal representation here cannot address
             more than MAX_INT unique terms.  Also, typically this
             class is used on fields with relatively few unique terms
             vs the number of documents.  In addition, there is an
             internal limit (16 MB) on how many bytes each chunk of
             documents may consume.  If you trip this limit you'll hit
             an InvalidOperationException.
            
             Deleted documents are skipped during uninversion, and if
             you look them up you'll get 0 ords.
            
             The returned per-document ords do not retain their
             original order in the document.  Instead they are returned
             in sorted (by ord, ie term's BytesRef comparator) order.  They
             are also de-dup'd (ie if doc has same term more than once
             in this field, you'll only get that ord back once).
            
             this class tests whether the provided reader is able to
             retrieve terms by ord (ie, it's single segment, and it
             uses an ord-capable terms index).  If not, this class
             will create its own term index internally, allowing to
             create a wrapped TermsEnum that can handle ord.  The
             <seealso cref="!:#getOrdTermsEnum"/> method then provides this
             wrapped enum, if necessary.
            
             The RAM consumption of this class can be high!
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.DEFAULT_INDEX_INTERVAL_BITS">
            <summary>
            Every 128th term is indexed, by default. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.MaxTermDocFreq">
            <summary>
            Don't uninvert terms that exceed this count. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Field">
            <summary>
            Field we are uninverting. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.NumTermsInField">
            <summary>
            Number of terms in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.TermInstances">
            <summary>
            Total number of references to term numbers. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Total_time">
            <summary>
            Total time to uninvert the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Phase1_time">
            <summary>
            Time for phase1 of the uninvert process. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Index">
            <summary>
            Holds the per-document ords or a pointer to the ords. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Tnums">
            <summary>
            Holds term ords for documents. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.SizeOfIndexedStrings">
            <summary>
            Total bytes (sum of term lengths) for all indexed terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.IndexedTermsArray">
            <summary>
            Holds the indexed (by default every 128th) terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.Prefix">
            <summary>
            If non-null, only terms matching this prefix were
             indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.OrdBase">
            <summary>
            Ordinal of the first term in the field, or 0 if the
             <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> does not implement {@link
             TermsEnum#ord}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.DocsEnum">
            <summary>
            Used while uninverting. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.RamUsedInBytes">
            <summary>
            Returns total bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.Bits,System.String)">
            <summary>
            Inverts all terms </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Inverts only terms starting w/ prefix </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Subclass inits w/ this, but be sure you then call
             uninvert, only once
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)" -->
        <member name="M:Lucene.Net.Index.DocTermOrds.NumTerms">
            <summary>
            Returns the number of terms in this field
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VisitTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Subclass can override this </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.SetActualDocFreq(System.Int32,System.Int32)">
            <summary>
            Invoked during <seealso cref="!:#uninvert(AtomicReader,Bits,BytesRef)"/>
             to record the document frequency for each uninverted
             term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Uninvert(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.Bits,Lucene.Net.Util.BytesRef)">
            <summary>
            Call this only once (if you subclass!) </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VIntSize(System.Int32)">
            <summary>
            Number of bytes to represent an unsigned int as a vint. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.LookupTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Returns the term (<seealso cref="T:Lucene.Net.Util.BytesRef"/>) corresponding to
             the provided ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.GetIterator(Lucene.Net.Index.AtomicReader)">
            <summary>
            Returns a SortedSetDocValues view of this instance </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocTermOrds.Empty">
            <summary>
            Returns {@code true} if no terms were indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Iterator.Read(System.Int32[])">
            <summary>
            Buffer must be at least 5 ints long.  Returns number
             of term ords placed into buffer; if this count is
             less than buffer.length then that is the end.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter">
             <summary>
             this class accepts multiple added documents and directly
             writes segment files.
            
             Each added document is passed to the <seealso cref="T:Lucene.Net.Index.DocConsumer"/>,
             which in turn processes the document and interacts with
             other consumers in the indexing chain.  Certain
             consumers, like <seealso cref="T:Lucene.Net.Index.StoredFieldsConsumer"/> and {@link
             TermVectorsConsumer}, digest a document and
             immediately write bytes to the "doc store" files (ie,
             they do not consume RAM per document, except while they
             are processing the document).
            
             Other consumers, eg <seealso cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and
             <seealso cref="T:Lucene.Net.Index.NormsConsumer"/>, buffer bytes in RAM and flush only
             when a new segment is produced.
            
             Once we have used our allowed RAM buffer, or the number
             of added docs is large enough (in the case we are
             flushing by doc count instead of RAM usage), we create a
             real segment and flush it to the Directory.
            
             Threads:
            
             Multiple threads are allowed into addDocument at once.
             There is an initial synchronized call to getThreadState
             which allocates a ThreadState for this thread.  The same
             thread will get the same ThreadState over time (thread
             affinity) so that if there are consistent patterns (for
             example each thread is indexing a different content
             source) then we make better use of RAM.  Then
             processDocument is called on that ThreadState without
             synchronization (most of the "heavy lifting" is in this
             call).  Finally the synchronized "finishDocument" is
             called to flush changes to the directory.
            
             When flush is called by IndexWriter we forcefully idle
             all threads and flush only once they are all idle.  this
             means you can call flush with a given thread even while
             other threads are actively adding/deleting documents.
            
            
             Exceptions:
            
             Because this class directly updates in-memory posting
             lists, and flushes stored fields and term vectors
             directly to files in the directory, there are certain
             limited times when an exception can corrupt this state.
             For example, a disk full while flushing stored fields
             leaves this file in a corrupt state.  Or, an OOM
             exception while appending to the in-memory posting lists
             can corrupt that posting list.  We call such exceptions
             "aborting exceptions".  In these cases we must call
             abort() to discard all docs added since the last flush.
            
             All other exceptions ("non-aborting exceptions") can
             still partially update the index structures.  These
             updates are consistent, but, they represent only a part
             of the document seen up until the exception was hit.
             When this happens, we immediately mark the document as
             deleted so that the document is always atomically ("all
             or none") added to the index.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.IndexWriter)">
            <summary>
            Called if we hit an exception at a bad time (when
             updating the index files) and must discard all
             currently buffered docs.  this resets our state,
             discarding any docs added since last flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriter.NumDocs">
            <summary>
            Returns how many docs are currently buffered in RAM. </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.Event">
             <summary>
             Interface for internal atomic events. See <seealso cref="T:Lucene.Net.Index.DocumentsWriter"/> for details. Events are executed concurrently and no order is guaranteed.
             Each event should only rely on the serializeability within it's process method. All actions that must happen before or after a certain action must be
             encoded inside the <seealso cref="!:#process(IndexWriter, boolean, boolean)"/> method.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
             <summary>
              An <code>IndexWriter</code> creates and maintains an index.
            
              <p>The <seealso cref="!:OpenMode"/> option on
              <seealso cref="!:IndexWriterConfig#setOpenMode(OpenMode)"/> determines
              whether a new index is created, or whether an existing index is
              opened. Note that you can open an index with <seealso cref="!:OpenMode#CREATE"/>
              even while readers are using the index. The old readers will
              continue to search the "point in time" snapshot they had opened,
              and won't see the newly created index until they re-open. If
              <seealso cref="!:OpenMode#CREATE_OR_APPEND"/> is used IndexWriter will create a
              new index if there is not already an index at the provided path
              and otherwise open the existing index.</p>
            
              <p>In either case, documents are added with {@link #addDocument(Iterable)
              addDocument} and removed with <seealso cref="!:#deleteDocuments(Term)"/> or {@link
              #deleteDocuments(Query)}. A document can be updated with {@link
              #updateDocument(Term, Iterable) updateDocument} (which just deletes
              and then adds the entire document). When finished adding, deleting
              and updating documents, <seealso cref="!:#close() close"/> should be called.</p>
            
              <a name="flush"></a>
              <p>These changes are buffered in memory and periodically
              flushed to the <seealso cref="P:Lucene.Net.Index.IndexWriter.Directory"/> (during the above method
              calls). A flush is triggered when there are enough added documents
              since the last flush. Flushing is triggered either by RAM usage of the
              documents (see <seealso cref="!:IndexWriterConfig#setRAMBufferSizeMB"/>) or the
              number of added documents (see <seealso cref="!:IndexWriterConfig#setMaxBufferedDocs(int)"/>).
              The default is to flush when RAM usage hits
              <seealso cref="!:IndexWriterConfig#DEFAULT_RAM_BUFFER_SIZE_MB"/> MB. For
              best indexing speed you should flush by RAM usage with a
              large RAM buffer. Additionally, if IndexWriter reaches the configured number of
              buffered deletes (see <seealso cref="!:IndexWriterConfig#setMaxBufferedDeleteTerms"/>)
              the deleted terms and queries are flushed and applied to existing segments.
              In contrast to the other flush options <seealso cref="!:IndexWriterConfig#setRAMBufferSizeMB"/> and
              <seealso cref="!:IndexWriterConfig#setMaxBufferedDocs(int)"/>, deleted terms
              won't trigger a segment flush. Note that flushing just moves the
              internal buffered state in IndexWriter into the index, but
              these changes are not visible to IndexReader until either
              <seealso cref="!:#commit()"/> or <seealso cref="!:#close"/> is called.  A flush may
              also trigger one or more segment merges which by default
              run with a background thread so as not to block the
              addDocument calls (see <a href="#mergePolicy">below</a>
              for changing the <seealso cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>).</p>
            
              <p>Opening an <code>IndexWriter</code> creates a lock file for the directory in use. Trying to open
              another <code>IndexWriter</code> on the same directory will lead to a
              <seealso cref="T:Lucene.Net.Store.LockObtainFailedException"/>. The <seealso cref="T:Lucene.Net.Store.LockObtainFailedException"/>
              is also thrown if an IndexReader on the same directory is used to delete documents
              from the index.</p>
            
              <a name="deletionPolicy"></a>
              <p>Expert: <code>IndexWriter</code> allows an optional
              <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation to be
              specified.  You can use this to control when prior commits
              are deleted from the index.  The default policy is {@link
              KeepOnlyLastCommitDeletionPolicy} which removes all prior
              commits as soon as a new commit is done (this matches
              behavior before 2.2).  Creating your own policy can allow
              you to explicitly keep previous "point in time" commits
              alive in the index for some time, to allow readers to
              refresh to the new commit without having the old commit
              deleted out from under them.  this is necessary on
              filesystems like NFS that do not support "delete on last
              close" semantics, which Lucene's "point in time" search
              normally relies on. </p>
            
              <a name="mergePolicy"></a> <p>Expert:
              <code>IndexWriter</code> allows you to separately change
              the <seealso cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> and the <seealso cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>.
              The <seealso cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> is invoked whenever there are
              changes to the segments in the index.  Its role is to
              select which merges to do, if any, and return a {@link
              MergePolicy.MergeSpecification} describing the merges.
              The default is <seealso cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.  Then, the {@link
              MergeScheduler} is invoked with the requested merges and
              it decides when and how to run the merges.  The default is
              <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>. </p>
            
              <a name="OOME"></a><p><b>NOTE</b>: if you hit an
              OutOfMemoryError then IndexWriter will quietly record this
              fact and block all future segment commits.  this is a
              defensive measure in case any internal state (buffered
              documents and deletions) were corrupted.  Any subsequent
              calls to <seealso cref="!:#commit()"/> will throw an
              InvalidOperationException.  The only course of action is to
              call <seealso cref="!:#close()"/>, which internally will call {@link
              #rollback()}, to undo any changes to the index since the
              last commit.  You can also just call <seealso cref="!:#rollback()"/>
              directly.</p>
            
              <a name="thread-safety"></a><p><b>NOTE</b>: {@link
              IndexWriter} instances are completely thread
              safe, meaning multiple threads can call any of its
              methods, concurrently.  If your application requires
              external synchronization, you should <b>not</b>
              synchronize on the <code>IndexWriter</code> instance as
              this may cause deadlock; use your own (non-Lucene) objects
              instead. </p>
            
              <p><b>NOTE</b>: If you call
              <code>Thread.interrupt()</code> on a thread that's within
              IndexWriter, IndexWriter will try to catch this (eg, if
              it's in a wait() or Thread.sleep()), and will then throw
              the unchecked exception <seealso cref="T:System.Threading.ThreadInterruptedException"/>
              and <b>clear</b> the interrupt status on the thread.</p>
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommit">
             <summary>
             An interface for implementations that support 2-phase commit. You can use
             <seealso cref="T:Lucene.Net.Index.TwoPhaseCommitTool"/> to execute a 2-phase commit algorithm over several
             <seealso cref="T:Lucene.Net.Index.TwoPhaseCommit"/>s.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommit.PrepareCommit">
            <summary>
            The first stage of a 2-phase commit. Implementations should do as much work
            as possible in this method, but avoid actual committing changes. If the
            2-phase commit fails, <seealso cref="!:#rollback()"/> is called to discard all changes
            since last successful commit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommit.Commit">
            <summary>
            The second phase of a 2-phase commit. Implementations should ideally do
            very little work in this method (following <seealso cref="!:#prepareCommit()"/>, and
            after it returns, the caller can assume that the changes were successfully
            committed to the underlying storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommit.Rollback">
            <summary>
            Discards any changes that have occurred since the last commit. In a 2-phase
            commit algorithm, where one of the objects failed to <seealso cref="!:#commit()"/> or
            <seealso cref="!:#prepareCommit()"/>, this method is used to roll all other objects
            back to their previous state.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME">
            <summary>
            Name of the write lock in the index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE">
            <summary>
            Key for the source of a segment in the <seealso cref="!:SegmentInfo#getDiagnostics() diagnostics"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_MERGE">
            <summary>
            Source of a segment which results from a merge of other segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_FLUSH">
            <summary>
            Source of a segment which results from a flush. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_ADDINDEXES_READERS">
            <summary>
            Source of a segment which results from a call to <seealso cref="!:#addIndexes(IndexReader...)"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH">
            <summary>
            Absolute hard maximum length for a term, in bytes once
            encoded as UTF8.  If a term arrives from the analyzer
            longer than this length, an
            <code>IllegalArgumentException</code>  is thrown
            and a message is printed to infoStream, if set (see {@link
            IndexWriterConfig#setInfoStream(InfoStream)}).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetReader(System.Boolean)">
             <summary>
             Expert: returns a readonly reader, covering all
             committed as well as un-committed changes to the index.
             this provides "near real-time" searching, in that
             changes made during an IndexWriter session can be
             quickly made available for searching without closing
             the writer nor calling <seealso cref="!:#commit"/>.
            
             <p>Note that this is functionally equivalent to calling
             {#flush} and then opening a new reader.  But the turnaround time of this
             method should be faster since it avoids the potentially
             costly <seealso cref="!:#commit"/>.</p>
            
             <p>You must close the <seealso cref="T:Lucene.Net.Index.IndexReader"/> returned by
             this method once you are done using it.</p>
            
             <p>It's <i>near</i> real-time because there is no hard
             guarantee on how quickly you can get a new reader after
             making changes with IndexWriter.  You'll have to
             experiment in your situation to determine if it's
             fast enough.  As this is a new and experimental
             feature, please report back on your findings so we can
             learn, improve and iterate.</p>
            
             <p>The resulting reader supports {@link
             DirectoryReader#openIfChanged}, but that call will simply forward
             back to this method (though this may change in the
             future).</p>
            
             <p>The very first time this method is called, this
             writer instance will make every effort to pool the
             readers that it opens for doing merges, applying
             deletes, etc.  this means additional resources (RAM,
             file descriptors, CPU time) will be consumed.</p>
            
             <p>For lower latency on reopening a reader, you should
             call <seealso cref="!:IndexWriterConfig#setMergedSegmentWarmer"/> to
             pre-warm a newly merged segment before it's committed
             to the index.  this is important for minimizing
             index-to-search delay after a large merge.  </p>
            
             <p>If an addIndexes* call is running in another thread,
             then this reader will only search those segments from
             the foreign index that have been successfully copied
             over, so far</p>.
            
             <p><b>NOTE</b>: Once the writer is closed, any
             outstanding readers may continue to be used.  However,
             if you attempt to reopen any of those readers, you'll
             hit an <seealso cref="T:Lucene.Net.Store.AlreadyClosedException"/>.</p>
            
             @lucene.experimental
             </summary>
             <returns> IndexReader that covers entire index plus all
             changes made so far by this IndexWriter instance
             </returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumDeletedDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Obtain the number of deleted docs for a pooled reader.
            If the reader isn't being pooled, the segmentInfo's
            delCount is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)">
            <summary>
            Used internally to throw an <seealso cref="T:Lucene.Net.Store.AlreadyClosedException"/> if this
            IndexWriter has been closed or is in the process of closing.
            </summary>
            <param name="failIfClosing">
                     if true, also fail when {@code IndexWriter} is in the process of
                     closing ({@code closing=true}) but not yet done closing (
                     {@code closed=false}) </param>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException">
                      if this IndexWriter is closed or in the process of closing </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.EnsureOpen" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Dispose" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)">
             <summary>
             Closes the index with or without waiting for currently
             running merges to finish.  this is only meaningful when
             using a MergeScheduler that runs merges in background
             threads.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer, again.  See <a
             href="#OOME">above</a> for details.</p>
            
             <p><b>NOTE</b>: it is dangerous to always call
             close(false), especially when IndexWriter is not open
             for very long, because this can result in "merge
             starvation" whereby long merges will never have a
             chance to finish.  this will cause too many segments in
             your index over time.</p>
             </summary>
             <param name="waitForMerges"> if true, this call will block
             until all merges complete; else, it will ask all
             running merges to abort, wait until those merges have
             finished (which should be at most a few seconds), and
             then return. </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumDocs">
            <summary>
            Returns total number of docs in this index, including
             docs not yet flushed (still in the RAM buffer), and
             including deletions.  <b>NOTE:</b> buffered deletions
             are not counted.  If you really need these to be
             counted you should call <seealso cref="!:#commit()"/> first. </summary>
             <seealso> cref= #numDocs  </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasDeletions">
            <summary>
            Returns true if this index has deletions (including
            buffered deletions).  Note that this will return true
            if there are buffered Term/Query deletions, even if it
            turns out those buffered deletions don't match any
            documents.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField})" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Adds a document to this index, using the provided analyzer instead of the
             value of <seealso cref="!:#getAnalyzer()"/>.
            
             <p>See <seealso cref="!:#addDocument(Iterable)"/> for details on
             index and IndexWriter state after an Exception, and
             flushing/merging temporary free space requirements.</p>
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}})" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Atomically adds a block of documents, analyzed using the
             provided analyzer, with sequentially assigned document
             IDs, such that an external reader will see all or none
             of the documents.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error
            
             @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}})">
             <summary>
             Atomically deletes documents matching the provided
             delTerm and adds a block of documents with sequentially
             assigned document IDs, such that an external reader
             will see all or none of the documents.
            
             See <seealso cref="!:#addDocuments(Iterable)"/>.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error
            
             @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Atomically deletes documents matching the provided
             delTerm and adds a block of documents, analyzed  using
             the provided analyzer, with sequentially
             assigned document IDs, such that an external reader
             will see all or none of the documents.
            
             See <seealso cref="!:#addDocuments(Iterable)"/>.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error
            
             @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
             <summary>
             Deletes the document(s) containing <code>term</code>.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="term"> the term to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
             <summary>
             Expert: attempts to delete by document ID, as long as
              the provided reader is a near-real-time reader (from {@link
              DirectoryReader#open(IndexWriter,boolean)}).  If the
              provided reader is an NRT reader obtained from this
              writer, and its segment has not been merged away, then
              the delete succeeds and this method returns true; else, it
              returns false the caller must then separately delete by
              Term or Query.
            
              <b>NOTE</b>: this method can only delete documents
              visible to the currently open NRT reader.  If you need
              to delete documents indexed after opening the NRT
              reader you must use the other deleteDocument methods
              (e.g., <seealso cref="!:#deleteDocuments(Term)"/>).
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
             <summary>
             Deletes the document(s) containing any of the
             terms. All given deletes are applied and flushed atomically
             at the same time.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="terms"> array of terms to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
             <summary>
             Deletes the document(s) matching the provided query.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="query"> the query to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
             <summary>
             Deletes the document(s) matching any of the provided queries.
             All given deletes are applied and flushed atomically at the same time.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="queries"> array of queries to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField})">
             <summary>
             Updates a document by first deleting the document(s)
             containing <code>term</code> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Updates a document by first deleting the document(s)
             containing <code>term</code> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <param name="analyzer"> the analyzer to use when analyzing the document </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateNumericDocValue(Lucene.Net.Index.Term,System.String,System.Nullable{System.Int64})">
             <summary>
             Updates a document's <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> for <code>field</code> to the
             given <code>value</code>. this method can be used to 'unset' a document's
             value by passing {@code null} as the new value. Also, you can only update
             fields that already exist in the index, not add new fields through this
             method.
            
             <p>
             <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately
             close the writer. See <a href="#OOME">above</a> for details.
             </p>
             </summary>
             <param name="term">
                      the term to identify the document(s) to be updated </param>
             <param name="field">
                      field name of the <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> field </param>
             <param name="value">
                      new value for the field </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.UpdateBinaryDocValue(Lucene.Net.Index.Term,System.String,Lucene.Net.Util.BytesRef)" -->
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>
            If non-null, information about merges will be printed to this.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32,System.Boolean)">
             <summary>
             Just like <seealso cref="!:#forceMerge(int)"/>, except you can
              specify whether the call should block until
              all merging completes.  this is only meaningful with a
              <seealso cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> that is able to run merges in
              background threads.
            
              <p><b>NOTE</b>: if this method hits an OutOfMemoryError
              you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxNumSegmentsMergesPending">
            <summary>
            Returns true if any merges in pendingMerges or
             runningMerges are maxNumSegments merges.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes" -->
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMerge">
             <summary>
             Expert: asks the mergePolicy whether any merges are
             necessary now and if so, runs the requested merges and
             then iterate (test again if merges are needed) until no
             more merges are returned by the mergePolicy.
            
             Explicit calls to maybeMerge() are usually not
             necessary. The most common case is when merge policy
             parameters have changed.
            
             this method will call the <seealso cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> with
             <seealso cref="!:MergeTrigger#EXPLICIT"/>.
            
             <p><b>NOTE</b>: if this method hits an OutOfMemoryError
             you should immediately close the writer.  See <a href="#OOME">above</a> for details.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasPendingMerges">
             <summary>
             Expert: returns true if there are merges waiting to be scheduled.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Rollback">
            <summary>
            Close the <code>IndexWriter</code> without committing
            any changes that have occurred since the last commit
            (or since it was opened, if commit hasn't been called).
            this removes any temporary files that had been created,
            after which the state of the index will be the same as
            it was when commit() was last called or when this
            writer was first opened.  this also clears a previous
            call to <seealso cref="!:#prepareCommit"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.DeleteAll" -->
        <member name="M:Lucene.Net.Index.IndexWriter.WaitForMerges">
             <summary>
             Wait for any currently outstanding merges to finish.
            
             <p>It is guaranteed that any merges started prior to calling this method
                will have completed once this method completes.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Checkpoint">
            <summary>
            Called whenever the SegmentInfos has been updated and
            the index files referenced exist (correctly) in the
            index directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CheckpointNoSIS">
            <summary>
            Checkpoints with IndexFileDeleter, so it's aware of
             new files, and increments changeCount, so on
             close/commit we will write a new segments file, but
             does NOT bump segmentInfos.version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Changed">
            <summary>
            Called internally if any index state has changed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PublishFlushedSegment(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.FrozenBufferedUpdates,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Atomically adds the segment private delete packet and publishes the flushed
            segments SegmentInfo to the index writer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AcquireWriteLocks(Lucene.Net.Store.Directory[])">
            <summary>
            Acquires write locks on all the directories; be sure
             to match with a call to <seealso cref="!:IOUtils#close"/> in a
             finally clause.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])" -->
        <member name="M:Lucene.Net.Index.IndexWriter.CopySegmentAsIs(Lucene.Net.Index.SegmentCommitInfo,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.ISet{System.String},Lucene.Net.Store.IOContext,System.Collections.Generic.ISet{System.String})">
            <summary>
            Copies the segment files as-is into the IndexWriter's directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoAfterFlush">
            <summary>
            A hook for extending classes to execute operations after pending added and
            deleted documents have been flushed to the Directory but before the change
            is committed (new segments_N file written).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoBeforeFlush">
            <summary>
            A hook for extending classes to execute operations before pending added and
            deleted documents are flushed to the Directory.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.PrepareCommit" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Commit" -->
        <member name="M:Lucene.Net.Index.IndexWriter.HasUncommittedChanges">
            <summary>
            Returns true if there may be changes that have not been
             committed.  There are cases where this may return true
             when there are no actual "real" changes to the index,
             for example if you've deleted by Term or Query but
             that Term or Query does not match any documents.
             Also, if a merge kicked off as a result of flushing a
             new segment during <seealso cref="!:#commit"/>, or a concurrent
             merged finished, this method may return true right
             after you had just called <seealso cref="!:#commit"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)">
            <summary>
            Flush all in-memory buffered updates (adds and deletes)
            to the Directory. </summary>
            <param name="triggerMerge"> if true, we may merge segments (if
             deletes or docs were flushed) if necessary </param>
            <param name="applyAllDeletes"> whether pending deletes should also </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RamSizeInBytes">
            <summary>
            Expert:  Return the total size of all index files currently cached in memory.
            Useful for size management with flushRamDocs()
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumRamDocs">
            <summary>
            Expert:  Return the number of documents currently
             buffered in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CommitMergedDeletesAndUpdates(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Index.MergeState)">
            <summary>
            Carefully merges deletes and updates for the segments we just merged. this
            is tricky because, although merging will clear all deletes (compacts the
            documents) and compact all the updates, new deletes and updates may have
            been flushed to the segments since the merge was started. this method
            "carries over" such new deletes and updates onto the newly merged segment,
            and saves the resulting deletes and updates files (incrementing the delete
            and DV generations for merge.info). If no deletes were flushed, no new
            deletes file is saved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)">
             <summary>
             Merges the indicated segments, replacing them in the stack with a
             single segment.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeSuccess(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Hook that's called when the specified merge is complete. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RegisterMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Checks whether this merge involves any segments
             already participating in a merge.  If not, this merge
             is "registered", meaning we record that its segments
             are now participating in a merge, and true is
             returned.  Else (the merge conflicts) false is
             returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeInit(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does initial setup for a merge, which is fast but holds
             the synchronized lock on IndexWriter instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeFinish(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does fininishing for a merge, which is fast but holds
             the synchronized lock on IndexWriter instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeMiddle(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual (time-consuming) work of the merge,
             but without holding synchronized lock on IndexWriter
             instance
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString">
             <summary>
             Returns a string description of all segments, for
              debugging.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
             <summary>
             Returns a string description of the specified
              segments, for debugging.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Returns a string description of the specified
              segment, for debugging.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.StartCommit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Walk through all files referenced by the current
             segmentInfos and ask the Directory to sync each file,
             if it wasn't already.  If that succeeds, then we
             prepare a new segments_N file but do not fully commit
             it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IsLocked(Lucene.Net.Store.Directory)">
            <summary>
            Returns <code>true</code> iff the index in the named directory is
            currently locked. </summary>
            <param name="directory"> the directory to check for a lock </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Unlock(Lucene.Net.Store.Directory)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles" -->
        <member name="M:Lucene.Net.Index.IndexWriter.CreateCompoundFile(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.MergeState.CheckAbort,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            NOTE: this method creates a compound file for all files returned by
            info.files(). While, generally, this may include separate norms and
            deletion files, this SegmentInfo must not reference such files when this
            method is called, because they are not allowed within a compound file.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.FlushFailed(Lucene.Net.Index.SegmentInfo)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.SlowFileExists(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Used only by asserts: returns true if the file exists
             (can be opened), false if it cannot be opened, and
             (unlike Java's File.exists) throws IOException if
             there's some unexpected error.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.FieldNumberMap">
            <summary>
            Loads or returns the already loaded the global field number map for this <seealso cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/>.
            If this <seealso cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/> has no global field number map the returned instance is empty
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Config">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/>, which can be used to query the IndexWriter
            current settings, as well as modify "live" ones.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Directory">
            <summary>
            Returns the Directory used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Analyzer">
            <summary>
            Returns the analyzer used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.MaxDoc">
            <summary>
            Returns total number of docs in this index, including
             docs not yet flushed (still in the RAM buffer),
             not counting deletions. </summary>
             <seealso> cref= #numDocs  </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexWriter.MergingSegments" -->
        <member name="P:Lucene.Net.Index.IndexWriter.NextMerge">
             <summary>
             Expert: the <seealso cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> calls this method to retrieve the next
             merge requested by the MergePolicy
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.IndexWriter.CommitData" -->
        <member name="P:Lucene.Net.Index.IndexWriter.KeepFullyDeletedSegments">
             <summary>
             Only for testing.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.ReaderPool">
            <summary>
            Holds shared SegmentReader instances. IndexWriter uses
             SegmentReaders for 1) applying deletes, 2) doing
             merges, 3) handing out a real-time reader.  this pool
             reuses instances of the SegmentReaders in all these
             places if it is in "near real-time mode" (getReader()
             has been called on this instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.DropAll(System.Boolean)">
            <summary>
            Remove all our references to readers, and commits
             any pending changes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Commit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Commit live docs changes for the segment readers for
            the provided infos.
            </summary>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Get(Lucene.Net.Index.SegmentCommitInfo,System.Boolean)">
            <summary>
            Obtain a ReadersAndLiveDocs instance from the
            readerPool.  If create is true, you must later call
            <seealso cref="!:#release(ReadersAndUpdates)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer" -->
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.Warm(Lucene.Net.Index.AtomicReader)">
            <summary>
            Invoked on the <seealso cref="T:Lucene.Net.Index.AtomicReader"/> for the newly
             merged segment, before that segment is made visible
             to near-real-time readers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.Event">
             <summary>
             Interface for internal atomic events. See <seealso cref="T:Lucene.Net.Index.DocumentsWriter"/> for details. Events are executed concurrently and no order is guaranteed.
             Each event should only rely on the serializeability within it's process method. All actions that must happen before or after a certain action must be
             encoded inside the <seealso cref="!:#process(IndexWriter, boolean, boolean)"/> method.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Event.Process(Lucene.Net.Index.IndexWriter,System.Boolean,System.Boolean)">
            <summary>
            Processes the event. this method is called by the <seealso cref="T:Lucene.Net.Index.IndexWriter"/>
            passed as the first argument.
            </summary>
            <param name="writer">
                     the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> that executes the event. </param>
            <param name="triggerMerge">
                     <code>false</code> iff this event should not trigger any segment merges </param>
            <param name="clearBuffers">
                     <code>true</code> iff this event should clear all buffers associated with the event. </param>
            <exception cref="T:System.IO.IOException">
                      if an <seealso cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DocumentsWriterDeleteQueue" -->
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.Add(Lucene.Net.Index.Term,Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)">
            <summary>
            invariant for document update
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice.IsTailItem(System.Object)">
            <summary>
            Returns <code>true</code> iff the given item is identical to the item
            hold by the slices tail, otherwise <code>false</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DocumentsWriterFlushControl" -->
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AllActiveThreadStates">
            <summary>
            Returns an iterator that provides access to all currently active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.PruneBlockedQueue(Lucene.Net.Index.DocumentsWriterDeleteQueue)">
            <summary>
            Prunes the blockedQueue by removing all DWPT that are associated with the given flush queue.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.NumQueuedFlushes">
            <summary>
            Returns the number of flushes that are already checked out but not yet
            actively flushing
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.NumBlockedFlushes">
            <summary>
            Returns the number of flushes that are checked out but not yet available
            for flushing. this only applies during a full flush if a DWPT needs
            flushing but must not be flushed until the full flush has finished.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.WaitIfStalled">
            <summary>
            this method will block if too many DWPT are currently flushing and no
            checked out DWPT are available
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AnyStalledThreads">
            <summary>
            Returns <code>true</code> iff stalled
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.FlushPending">
            <summary>
            Sets flush pending state on the given <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. The
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> must have indexed at least on Document and must not be
            already pending.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumGlobalTermDeletes">
            <summary>
            Returns the number of delete terms in the global pool
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.FullFlush">
            <summary>
            Returns <code>true</code> if a full flush is currently running
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.InfoStream">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> <seealso cref="P:Lucene.Net.Index.DocumentsWriterFlushControl.InfoStream"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterFlushQueue">
            <summary>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushQueue.FlushTicket.PublishFlushedSegment(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Publishes the flushed segment, segment private deletes (if any) and its
            associated global delete (if present) to IndexWriter.  The actual
            publishing operation is synced on IW -&gt; BDS so that the <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>'s
            delete generation is always GlobalPacket_deleteGeneration + 1
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Abort(System.Collections.Generic.ISet{System.String})">
            <summary>
            Called if we hit an exception at a bad time (when
             updating the index files) and must discard all
             currently buffered docs.  this resets our state,
             discarding any docs added since last flush.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.NumDeleteTerms">
            <summary>
            Returns the number of delete terms in this <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.PrepareFlush">
            <summary>
            Prepares this DWPT for flushing. this method will freeze and return the
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/>s global buffer and apply all pending
            deletes to this DWPT.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Flush">
            <summary>
            Flush all pending docs to a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.SealFlushedSegment(Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment)">
            <summary>
            Seals the <seealso cref="P:Lucene.Net.Index.DocumentsWriterPerThread.SegmentInfo"/> for the new flushed segment and persists
            the deleted documents <seealso cref="T:Lucene.Net.Util.MutableBits"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDocsInRAM">
            <summary>
            Returns the number of RAM resident documents in this <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.SegmentInfo">
            <summary>
            Get current segment info we are writing. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain">
            <summary>
            The IndexingChain must define the <seealso cref="!:#getChain(DocumentsWriterPerThread)"/> method
            which returns the DocConsumer that the DocumentsWriter calls to process the
            documents.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IntBlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing int
             blocks.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IntBlockPool">
            <summary>
            A pool for int blocks similar to <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/>
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.Buffers">
            <summary>
            array of buffers currently used in the pool. Buffers are allocated if needed don't modify this outside of this class </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.BufferUpto">
            <summary>
            index into the buffers array pointing to the current buffer used as the head </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.IntUpto">
            <summary>
            Pointer to the current position in head buffer </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.Buffer">
            <summary>
            Current head buffer </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.IntOffset">
            <summary>
            Current head offset </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntBlockPool.#ctor" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntBlockPool.#ctor(Lucene.Net.Util.IntBlockPool.Allocator)" -->
        <member name="M:Lucene.Net.Util.IntBlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer. Calling
            <seealso cref="!:IntBlockPool#nextBuffer()"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. </summary>
            <param name="zeroFillBuffers"> if <code>true</code> the buffers are filled with <tt>0</tt>.
                   this should be set to <code>true</code> if this pool is used with
                   <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceWriter"/>. </param>
            <param name="reuseFirst"> if <code>true</code> the first buffer will be reused and calling
                   <seealso cref="!:IntBlockPool#nextBuffer()"/> is not needed after reset iff the
                   block pool was used before ie. <seealso cref="!:IntBlockPool#nextBuffer()"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. this method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <seealso cref="!:IntBlockPool#reset()"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntBlockPool.NewSlice(System.Int32)" -->
        <member name="F:Lucene.Net.Util.IntBlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <seealso cref="!:IntBlockPool#LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for int slices.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntBlockPool.FIRST_LEVEL_SIZE">
            <summary>
            The first level size for new slices
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.AllocSlice(System.Int32[],System.Int32)">
            <summary>
            Allocates a new slice from the given offset
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IntBlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing int
             blocks.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IntBlockPool.DirectAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.IntBlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.DirectAllocator.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.IntBlockPool.DirectAllocator"/> with a default block size
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.IntBlockPool.SliceWriter" -->
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceWriter.Reset(System.Int32)">
            
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceWriter.WriteInt(System.Int32)">
            <summary>
            Writes the given value into the slice and resizes the slice if needed
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceWriter.StartNewSlice">
            <summary>
            starts a new slice and returns the start offset. The returned value
            should be used as the start offset to initialize a <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceReader"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.IntBlockPool.SliceWriter.CurrentOffset">
            <summary>
            Returns the offset of the currently written slice. The returned value
            should be used as the end offset to initialize a <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceReader"/> once
            this slice is fully written or to reset the this writer if another slice
            needs to be written.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IntBlockPool.SliceReader">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceReader"/> that can read int slices written by a <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceWriter"/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceReader.#ctor(Lucene.Net.Util.IntBlockPool)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.IntBlockPool.SliceReader"/> on the given pool
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceReader.Reset(System.Int32,System.Int32)">
            <summary>
            Resets the reader to a slice give the slices absolute start and end offset in the pool
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntBlockPool.SliceReader.EndOfSlice">
            <summary>
            Returns <code>true</code> iff the current slice is fully read. If this
            method returns <code>true</code> <seealso cref="!:SliceReader#readInt()"/> should not
            be called again on this slice.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntBlockPool.SliceReader.ReadInt" -->
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThreadPool">
            <summary>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> controls <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances
            and their thread assignments during indexing. Each <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> holds
            a reference to a <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> that is once a
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is obtained from the pool exclusively used for indexing a
            single document by the obtaining thread. Each indexing thread must obtain
            such a <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> to make progress. Depending on the
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            assignments might differ from document to document.
            <p>
            Once a <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is selected for flush the thread pool
            is reusing the flushing <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>s ThreadState with a
            new <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> instance.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> with a given maximum of <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NewThreadState" -->
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateUnreleasedStates">
            <summary>
            Deactivate all unreleased threadstates
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.GetThreadState(System.Int32)">
            <summary>
            Returns the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
            given ord.
            </summary>
            <param name="ord">
                     the ordinal of the <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> </param>
            <returns> the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
                    given ord. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.MinContendedThreadState">
            <summary>
            Returns the ThreadState with the minimum estimated number of threads
            waiting to acquire its lock or <code>null</code> if no <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            is yet visible to the calling thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NumDeactivatedThreadStates">
            <summary>
            Returns the number of currently deactivated <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            A deactivated <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> should not be used for indexing anymore.
            </summary>
            <returns> the number of currently deactivated <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateThreadState(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Deactivates an active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Inactive <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> can
            not be used for indexing anymore once they are deactivated. this method should only be used
            if the parent <seealso cref="T:Lucene.Net.Index.DocumentsWriter"/> is closed or aborted.
            </summary>
            <param name="threadState"> the state to deactivate </param>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.MaxThreadStates">
            <summary>
            Returns the max number of <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances available in this
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ActiveThreadState">
            <summary>
            Returns the active number of <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.Deactivate" -->
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.Active">
            <summary>
            Returns <code>true</code> if this ThreadState is still open. this will
            only return <code>false</code> iff the DW has been closed and this
            ThreadState is already checked out for flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.BytesUsedPerThread">
            <summary>
            Returns the number of currently active bytes in this ThreadState's
            <seealso cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread">
            <summary>
            Returns this <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s <seealso cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.FlushPending">
            <summary>
            Returns <code>true</code> iff this <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is marked as flush
            pending otherwise <code>false</code>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DocumentsWriterStallControl" -->
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.UpdateStalled(System.Boolean)">
            <summary>
            Update the stalled flag status. this method will set the stalled flag to
            <code>true</code> iff the number of flushing
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is greater than the number of active
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>. Otherwise it will reset the
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterStallControl"/> to healthy and release all threads
            waiting on <seealso cref="!:#waitIfStalled()"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.WaitIfStalled">
             <summary>
             Blocks if documents writing is currently in a stalled state.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValues">
            <summary>
            this class contains utility methods and constants for DocValues
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_BINARY">
            <summary>
            An empty BinaryDocValues which returns <seealso cref="!:BytesRef#EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_NUMERIC">
            <summary>
            An empty NumericDocValues which returns zero for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED">
            <summary>
            An empty SortedDocValues which returns <seealso cref="!:BytesRef#EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED_SET">
            <summary>
            An empty SortedDocValues which returns <seealso cref="!:SortedSetDocValues#NO_MORE_ORDS"/> for every document
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.Singleton(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Returns a multi-valued view over the provided SortedDocValues
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.UnwrapSingleton(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Returns a single-valued view of the SortedSetDocValues, if it was previously
            wrapped with <seealso cref="!:#singleton"/>, or null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedDocValues,System.Int32)">
            <summary>
            Returns a Bits representing all documents from <code>dv</code> that have a value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedSetDocValues,System.Int32)">
            <summary>
            Returns a Bits representing all documents from <code>dv</code> that have a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate">
            <summary>
            An in-place update to a DocValues field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesUpdate.#ctor(Lucene.Net.Index.DocValuesFieldUpdates.Type_e,Lucene.Net.Index.Term,System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="term"> the <seealso cref="F:Lucene.Net.Index.DocValuesUpdate.Term"/> which determines the documents that will be updated </param>
            <param name="field"> the <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/> to update </param>
            <param name="value"> the updated value </param>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.BinaryDocValuesUpdate">
            <summary>
            An in-place update to a binary DocValues field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.NumericDocValuesUpdate">
            <summary>
            An in-place update to a numeric DocValues field </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfo">
             <summary>
              Access to the Field Info file that describes document fields and whether or
              not they are indexed. Each segment has a separate Field Info file. Objects
              of this class are thread-safe for multiple readers, but only one thread can
              be adding documents at a time, with no other reader or writer threads
              accessing this object.
            
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.Name">
            <summary>
            Field's name </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.Number">
            <summary>
            Internal field number </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.#ctor(System.String,System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Lucene.Net.Index.FieldInfo.IndexOptions},System.Nullable{Lucene.Net.Index.FieldInfo.DocValuesType_e},System.Nullable{Lucene.Net.Index.FieldInfo.DocValuesType_e},System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>
             Sole Constructor.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.HasDocValues">
            <summary>
            Returns true if this field has any docValues.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.OmitsNorms">
            <summary>
            Returns true if norms are explicitly omitted for this field
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.HasNorms">
            <summary>
            Returns true if this field actually has any norms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.HasPayloads">
            <summary>
            Returns true if any payloads exist for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.HasVectors">
            <summary>
            Returns true if any term vectors exist for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or null if it does not exist
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FieldInfo.PutAttribute(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.FieldInfo.Attributes">
            <summary>
            Returns internal codec attributes map. May be null if no mappings exist.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.FieldIndexOptions">
            <summary>
            Returns IndexOptions for the field, or null if the field is not indexed </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.DocValuesGen">
            <summary>
            Sets the docValues generation of this field. </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.NormType">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.FieldInfo.DocValuesType_e"/> of the norm. this may be null if the field has no norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Indexed">
            <summary>
            Returns true if this field is indexed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfo.IndexOptions">
            <summary>
            Controls how much information is stored in the postings lists.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.IndexOptions.DOCS_ONLY">
            <summary>
            Only documents are indexed: term frequencies and positions are omitted.
            Phrase and other positional queries on the field will throw an exception, and scoring
            will behave as if any term in the document appears only once.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.IndexOptions.DOCS_AND_FREQS">
            <summary>
            Only documents and term frequencies are indexed: positions are omitted.
            this enables normal scoring, except Phrase and other positional queries
            will throw an exception.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS">
            <summary>
            Indexes documents, frequencies and positions.
            this is a typical default for full-text search: full scoring is enabled
            and positional queries are supported.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS">
            <summary>
            Indexes documents, frequencies, positions and offsets.
            Character offsets are encoded alongside the positions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfo.DocValuesType_e">
            <summary>
            DocValues types.
            Note that DocValues is strongly typed, so a field cannot have different types
            across different documents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.DocValuesType_e.NUMERIC">
            <summary>
            A per-document Number
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FieldInfo.DocValuesType_e.BINARY">
            <summary>
            A per-document byte[].  Values may be larger than
            32766 bytes, but different codecs may enforce their own limits.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.FieldInfo.DocValuesType_e.SORTED" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.FieldInfo.DocValuesType_e.SORTED_SET" -->
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>
            Collection of <seealso cref="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.String)"/>s (accessible by number or by name).
             @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Index.FieldInfo[])">
            <summary>
            Constructs a new FieldInfos from an array of FieldInfo objects
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasFreq">
            <summary>
            Returns true if any fields have freqs </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasProx">
            <summary>
            Returns true if any fields have positions </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasPayloads">
            <summary>
            Returns true if any fields have payloads </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasOffsets">
            <summary>
            Returns true if any fields have offsets </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasVectors">
            <summary>
            Returns true if any fields have vectors </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasNorms">
            <summary>
            Returns true if any fields have norms </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasDocValues">
            <summary>
            Returns true if any fields have DocValues </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Size">
            <summary>
            Returns the number of fields </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.GetEnumerator">
            <summary>
            Returns an iterator over all the fieldinfo objects present,
            ordered by ascending field number
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.String)">
            <summary>
            Return the fieldinfo object referenced by the field name </summary>
            <returns> the FieldInfo object or null when the given fieldName
            doesn't exist. </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary>
            Return the fieldinfo object referenced by the fieldNumber. </summary>
            <param name="fieldNumber"> field's number. </param>
            <returns> the FieldInfo object or null when the given fieldNumber
            doesn't exist. </returns>
            <exception cref="!:IllegalArgumentException"> if fieldNumber is negative </exception>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.AddOrGet(System.String,System.Int32,System.Nullable{Lucene.Net.Index.FieldInfo.DocValuesType_e})">
            <summary>
            Returns the global field number for the given field name. If the name
            does not exist yet it tries to add it with the given preferred field
            number assigned if possible otherwise the first unassigned field number
            is used as the field number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.Contains(System.String,System.Nullable{Lucene.Net.Index.FieldInfo.DocValuesType_e})">
            <summary>
            Returns true if the {@code fieldName} exists in the map and is of the
            same {@code dvType}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.#ctor(Lucene.Net.Index.FieldInfos.FieldNumbers)">
            <summary>
            Creates a new instance with the given <seealso cref="T:Lucene.Net.Index.FieldInfos.FieldNumbers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.AddOrUpdate(System.String,Lucene.Net.Index.IndexableFieldType)">
            <summary>
            NOTE: this method does not carry over termVector
             booleans nor docValuesType; the indexer chain
             (TermVectorsConsumerPerField, DocFieldProcessor) must
             set these fields when they succeed in consuming
             the document
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInvertState">
             <summary>
             this class tracks the number and position / offset parameters of terms
             being added to the index. The information collected in this class is
             also used to calculate the normalization factor for a field.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String)">
            <summary>
            Creates {code FieldInvertState} for the specified
             field name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Creates {code FieldInvertState} for the specified
             field name and values for all fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.Reset">
            <summary>
            Re-initialize the state
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Position">
            <summary>
            Get the last processed term position. </summary>
            <returns> the position </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Length">
            <summary>
            Get total number of terms in this field. </summary>
            <returns> the length </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.NumOverlap">
            <summary>
            Get the number of terms with <code>positionIncrement == 0</code>. </summary>
            <returns> the numOverlap </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Offset">
            <summary>
            Get end offset of the last processed term. </summary>
            <returns> the offset </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Boost">
            <summary>
            Get boost value. this is the cumulative product of
            document boost and field boost for all field instances
            sharing the same field name. </summary>
            <returns> the boost </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.MaxTermFrequency">
            <summary>
            Get the maximum term-frequency encountered for any term in the field.  A
            field containing "the quick brown fox jumps over the lazy dog" would have
            a value of 2, because "the" appears twice.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.UniqueTermCount">
            <summary>
            Return the number of unique terms encountered in this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.AttributeSource">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.FieldInvertState.AttributeSource"/> from the {@link
             TokenStream} that provided the indexed tokens for this
             field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Name">
            <summary>
            Return the field's name
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FilterAtomicReader" -->
        <member name="M:Lucene.Net.Index.FilterAtomicReader.Unwrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Get the wrapped instance by <code>reader</code> as long as this reader is
             an intance of <seealso cref="T:Lucene.Net.Index.FilterAtomicReader"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.in">
            <summary>
            The underlying AtomicReader. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FilterAtomicReader.#ctor(Lucene.Net.Index.AtomicReader)" -->
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterFields">
            <summary>
            Base class for filtering <seealso cref="P:Lucene.Net.Index.FilterAtomicReader.Fields"/>
             implementations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterFields.input">
            <summary>
            The underlying Fields instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterFields.#ctor(Lucene.Net.Index.Fields)">
            <summary>
            Creates a new FilterFields. </summary>
            <param name="in"> the underlying Fields instance. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FilterAtomicReader.FilterTerms" -->
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTerms.in">
            <summary>
            The underlying Terms instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTerms.#ctor(Lucene.Net.Index.Terms)">
            <summary>
            Creates a new FilterTerms </summary>
            <param name="in"> the underlying Terms instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum">
            <summary>
            Base class for filtering <seealso cref="T:Lucene.Net.Index.TermsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.in">
            <summary>
            The underlying TermsEnum instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a new FilterTermsEnum </summary>
            <param name="in"> the underlying TermsEnum instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum">
            <summary>
            Base class for filtering <seealso cref="P:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.DocsEnum"/> implementations. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.#ctor(Lucene.Net.Index.DocsEnum)">
            <summary>
            Create a new FilterDocsEnum </summary>
            <param name="in"> the underlying DocsEnum instance. </param>
        </member>
        <member name="P:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.DocsEnum">
            <summary>
            The underlying DocsEnum instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum">
            <summary>
            Base class for filtering <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.in">
            <summary>
            The underlying DocsAndPositionsEnum instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.#ctor(Lucene.Net.Index.DocsAndPositionsEnum)">
            <summary>
            Create a new FilterDocsAndPositionsEnum </summary>
            <param name="in"> the underlying DocsAndPositionsEnum instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader">
             <summary>
             A FilterDirectoryReader wraps another DirectoryReader, allowing implementations
             to transform or extend it.
            
             Subclasses should implement doWrapDirectoryReader to return an instance of the
             subclass.
            
             If the subclass wants to wrap the DirectoryReader's subreaders, it should also
             implement a SubReaderWrapper subclass, and pass an instance to its super
             constructor.
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterDirectoryReader.in">
            <summary>
            The filtered DirectoryReader </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader)">
            <summary>
            Create a new FilterDirectoryReader that filters a passed in DirectoryReader. </summary>
            <param name="in"> the DirectoryReader to filter </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper)">
            <summary>
            Create a new FilterDirectoryReader that filters a passed in DirectoryReader,
            using the supplied SubReaderWrapper to wrap its subreader. </summary>
            <param name="in"> the DirectoryReader to filter </param>
            <param name="wrapper"> the SubReaderWrapper to use to wrap subreaders </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.DoWrapDirectoryReader(Lucene.Net.Index.DirectoryReader)">
             <summary>
             Called by the doOpenIfChanged() methods to return a new wrapped DirectoryReader.
            
             Implementations should just return an instantiation of themselves, wrapping the
             passed in DirectoryReader.
             </summary>
             <param name="in"> the DirectoryReader to wrap </param>
             <returns> the wrapped DirectoryReader </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper">
            <summary>
            Factory class passed to FilterDirectoryReader constructor that allows
            subclasses to wrap the filtered DirectoryReader's subreaders.  You
            can use this to, e.g., wrap the subreaders with specialised
            FilterAtomicReader implementations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.Wrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Wrap one of the parent DirectoryReader's subreaders </summary>
            <param name="reader"> the subreader to wrap </param>
            <returns> a wrapped/filtered AtomicReader </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper">
            <summary>
            A no-op SubReaderWrapper that simply returns the parent
            DirectoryReader's original subreaders.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FlushByRamOrCountsPolicy" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.FlushPolicy" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FlushPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FlushPolicy.OnUpdate(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FlushPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)" -->
        <member name="M:Lucene.Net.Index.FlushPolicy.Init(Lucene.Net.Index.LiveIndexWriterConfig)">
            <summary>
            Called by DocumentsWriter to initialize the FlushPolicy
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FlushPolicy.FindLargestNonPendingWriter(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)" -->
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.MarkLargestWriterPending(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState,System.Int64)">
            <summary>
            Marks the most ram consuming active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flush
            pending
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDocCount">
            <summary>
            Returns <code>true</code> if this <seealso cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <seealso cref="!:IndexWriterConfig#getMaxBufferedDocs()"/>, otherwise
            <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDeleteTerms">
            <summary>
            Returns <code>true</code> if this <seealso cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <seealso cref="!:IndexWriterConfig#getMaxBufferedDeleteTerms()"/>, otherwise
            <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnRAM">
            <summary>
            Returns <code>true</code> if this <seealso cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <seealso cref="!:IndexWriterConfig#getRAMBufferSizeMB()"/>, otherwise
            <code>false</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermsHashConsumerPerField" -->
        <member name="T:Lucene.Net.Index.FrozenBufferedUpdates">
            <summary>
            Holds buffered deletes and updates by term or query, once pushed. Pushed
            deletes/updates are write-once, so we shift to more memory efficient data
            structure to hold them. We don't hold docIDs because these are applied on
            flush.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexCommit">
             <summary>
             <p>Expert: represents a single commit into an index as seen by the
             <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> or <seealso cref="T:Lucene.Net.Index.IndexReader"/>.</p>
            
             <p> Changes to the content of an index are made visible
             only after the writer who made that change commits by
             writing a new segments file
             (<code>segments_N</code>). this point in time, when the
             action of writing of a new segments file to the directory
             is completed, is an index commit.</p>
            
             <p>Each index commit point has a unique segments file
             associated with it. The segments file associated with a
             later index commit point would have a larger N.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexCommit.Delete" -->
        <member name="M:Lucene.Net.Index.IndexCommit.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Equals(System.Object)">
            <summary>
            Two IndexCommits are equal if both their Directory and versions are equal. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentsFileName">
            <summary>
            Get the segments file (<code>segments_N</code>) associated
            with this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.FileNames">
            <summary>
            Returns all index files referenced by this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Directory">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.IndexCommit.Directory"/> for the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Deleted">
            <summary>
            Returns true if this commit should be deleted; this is
             only used by <seealso cref="T:Lucene.Net.Index.IndexWriter"/> after invoking the
             <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentCount">
            <summary>
            Returns number of segments referenced by this commit. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Generation">
            <summary>
            Returns the generation (the _N in segments_N) for this
             IndexCommit
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.UserData">
            <summary>
            Returns userData, previously passed to {@link
             IndexWriter#setCommitData(Map)} for this commit.  Map is
             String -> String.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexDeletionPolicy" -->
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.#ctor">
            <summary>
            Sole constructor, typically called by sub-classes constructors. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})" -->
        <member name="F:Lucene.Net.Index.IndexFileDeleter.VERBOSE_REF_COUNTS">
            <summary>
            Change to true to see details of reference counts when
             infoStream is enabled
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.SegmentInfos,Lucene.Net.Util.InfoStream,Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Initialize the deleter: find all previous commits in
            the Directory, incref the files they reference, call
            the policy to let it delete commits.  this will remove
            any files not referenced by any of the commits. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteCommits">
            <summary>
            Remove the CommitPoints in the commitsToDelete List by
            DecRef'ing all files from each SegmentInfos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)">
            <summary>
            Writer calls this when it has hit an error and had to
            roll back, to tell us that there may now be
            unreferenced files in the filesystem.  So we re-list
            the filesystem and delete such files.  If segmentName
            is non-null, we will only delete files corresponding to
            that segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.RevisitPolicy">
            <summary>
            Revisits the <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> by calling its
            <seealso cref="!:IndexDeletionPolicy#onCommit(List)"/> again with the known commits.
            this is useful in cases where a deletion policy which holds onto index
            commits is used. The application may know that some commits are not held by
            the deletion policy anymore and call
            <seealso cref="!:IndexWriter#deleteUnusedFiles()"/>, which will attempt to delete the
            unused commits again.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Checkpoint(Lucene.Net.Index.SegmentInfos,System.Boolean)">
             <summary>
             For definition of "check point" see IndexWriter comments:
             "Clarification: Check Points (and commits)".
            
             Writer calls this when it has made a "consistent
             change" to the index, meaning new files are written to
             the index and the in-memory SegmentInfos have been
             modified to point to those files.
            
             this may or may not be a commit (segments_N may or may
             not have been written).
            
             We simply incref the files referenced by the new
             SegmentInfos and decref the files we had previously
             seen (if any).
            
             If this is a commit, we also call the policy to give it
             a chance to remove other commits.  If any commits are
             removed, we decref their files as well.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Deletes the specified files, but only if they are new
             (have not yet been incref'd).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.RefCount">
            <summary>
            Tracks the reference count for a single index file:
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.CommitPoint">
            <summary>
            Holds details for each commit point.  this class is
            also passed to the deletion policy.  Note: this class
            has a natural ordering that is inconsistent with
            equals.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.Delete">
            <summary>
            Called only be the deletion policy, to remove this
            commit point from the index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexFileNames" -->
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS">
            <summary>
            Name of the index segment file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.GEN_EXTENSION">
            <summary>
            Extension of gen file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_EXTENSION">
            <summary>
            Extension of compound file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION">
            <summary>
            Extension of compound file entries </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN">
            <summary>
            Name of the generation reference file name </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS">
            <summary>
            this array contains all filename extensions used by
            Lucene's index files, with one exception, namely the
            extension made up from  <code>.s</code> + a number.
            Also note that Lucene's <code>segments_N</code> files
            do not have any filename extension.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.IndexFileNames.MatchesExtension(System.String,System.String)">
            <summary>
            Returns true if the given filename ends with the given extension. One
            should provide a <i>pure</i> extension, without '.'.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.IndexOfSegmentName(System.String)">
            <summary>
            locates the boundary of the segment name, or -1 </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripSegmentName(System.String)">
            <summary>
            Strips the segment name out of the given file name. If you used
            <seealso cref="!:#segmentFileName"/> or <seealso cref="!:#fileNameFromGeneration"/> to create your
            files, then this method simply removes whatever comes before the first '.',
            or the second '_' (excluding both).
            </summary>
            <returns> the filename with the segment name removed, or the given filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.ParseSegmentName(System.String)">
            <summary>
            Parses the segment name out of the given file name.
            </summary>
            <returns> the segment name only, or filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripExtension(System.String)">
            <summary>
            Removes the extension (anything after the first '.'),
            otherwise returns the original filename.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.GetExtension(System.String)">
            <summary>
            Return the extension (anything after the first '.'),
            or null if there is no '.' in the file name.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.CODEC_FILE_PATTERN">
            <summary>
            All files created by codecs much match this pattern (checked in
            SegmentInfo).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooNewException">
            <summary>
            this exception is thrown when Lucene detects
            an index that is newer than this Lucene version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates an {@code IndexFormatTooNewException}
             </summary>
              <param name="resourceDesc"> describes the file that was too old </param>
              <param name="version"> the version of the file that was too old </param>
              <param name="minVersion"> the minimum version accepted </param>
              <param name="maxVersion"> the maxium version accepted
            
             @lucene.internal  </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates an {@code IndexFormatTooNewException}
             </summary>
              <param name="in"> the open file that's too old </param>
              <param name="version"> the version of the file that was too old </param>
              <param name="minVersion"> the minimum version accepted </param>
              <param name="maxVersion"> the maxium version accepted
            
             @lucene.internal  </param>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooOldException">
            <summary>
            this exception is thrown when Lucene detects
            an index that is too old for this Lucene version
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.String)">
             <summary>
             Creates an {@code IndexFormatTooOldException}.
             </summary>
              <param name="resourceDesc"> describes the file that was too old </param>
              <param name="version"> the version of the file that was too old
            
             @lucene.internal  </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.String)">
             <summary>
             Creates an {@code IndexFormatTooOldException}.
             </summary>
              <param name="in"> the open file that's too old </param>
              <param name="version"> the version of the file that was too old
            
             @lucene.internal  </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates an {@code IndexFormatTooOldException}.
             </summary>
              <param name="resourceDesc"> describes the file that was too old </param>
              <param name="version"> the version of the file that was too old </param>
              <param name="minVersion"> the minimum version accepted </param>
              <param name="maxVersion"> the maxium version accepted
            
             @lucene.internal  </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
             <summary>
             Creates an {@code IndexFormatTooOldException}.
             </summary>
              <param name="in"> the open file that's too old </param>
              <param name="version"> the version of the file that was too old </param>
              <param name="minVersion"> the minimum version accepted </param>
              <param name="maxVersion"> the maxium version accepted
            
             @lucene.internal  </param>
        </member>
        <member name="T:Lucene.Net.Index.IndexNotFoundException">
            <summary>
            Signals that no index was found in the Directory. Possibly because the
            directory is empty, however can also indicate an index corruption.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexNotFoundException.#ctor(System.String)">
            <summary>
            Creates IndexFileNotFoundException with the
             description message.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexUpgrader" -->
        <member name="M:Lucene.Net.Index.IndexUpgrader.ParseArgs(System.String[])">
            <summary>
            Main method to run {code IndexUpgrader} from the
             command-line.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion)">
            <summary>
            Creates index upgrader on the given directory, using an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            {@code matchVersion}. The tool refuses to upgrade indexes with multiple commit points.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            {@code matchVersion}. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones. If {@code infoStream} is not {@code null}, all logging output will be sent to this stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            config. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.Upgrade">
            <summary>
            Perform the upgrade. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexWriterConfig" -->
        <member name="T:Lucene.Net.Index.LiveIndexWriterConfig">
             <summary>
             Holds all the configuration used by <seealso cref="T:Lucene.Net.Index.IndexWriter"/> with few setters for
             settings that can be changed on an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> instance "live".
            
             @since 4.0
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.delPolicy">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.DelPolicy"/> controlling when commit
             points are deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.Commit">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit"/> that <seealso cref="T:Lucene.Net.Index.IndexWriter"/> is
             opened on.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.openMode">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.OpenMode"/> that <seealso cref="T:Lucene.Net.Index.IndexWriter"/> is opened
             with.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.similarity">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.Similarity"/> to use when encoding norms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergeScheduler">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergeScheduler"/> to use for running merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.writeLockTimeout">
            <summary>
            Timeout when trying to obtain the write lock on init. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexingChain">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexingChain"/> that determines how documents are
             indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.codec">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.Codec"/> used to write new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.infoStream">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.InfoStream"/> for debugging messages. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergePolicy">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergePolicy"/> for selecting merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexerThreadPool">
            <summary>
            {@code DocumentsWriterPerThreadPool} to control how
             threads are allocated to {@code DocumentsWriterPerThread}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.readerPooling">
            <summary>
            True if readers should be pooled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.flushPolicy">
            <summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy"/> to control when segments are
             flushed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.PerThreadHardLimitMB">
            <summary>
            Sets the hard upper bound on RAM usage for a single
             segment, after which the segment is forced to flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.MatchVersion">
            <summary>
            <seealso cref="T:Lucene.Net.Util.LuceneVersion"/> that <seealso cref="T:Lucene.Net.Index.IndexWriter"/> should emulate. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.useCompoundFile">
            <summary>
            True if segment flushes should use compound file format </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.checkIntegrityAtMerge">
            <summary>
            True if merging should check integrity of segments before merge </summary>
        </member>
        <member name="M:Lucene.Net.Index.LiveIndexWriterConfig.#ctor(Lucene.Net.Index.IndexWriterConfig)">
            <summary>
            Creates a new config that that handles the live <seealso cref="T:Lucene.Net.Index.IndexWriter"/>
            settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetTermIndexInterval(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetMaxBufferedDeleteTerms(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetRAMBufferSizeMB(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetMaxBufferedDocs(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetMergedSegmentWarmer(Lucene.Net.Index.IndexWriter.IndexReaderWarmer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LiveIndexWriterConfig.SetReaderTermsIndexDivisor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.LiveIndexWriterConfig.SetUseCompoundFile(System.Boolean)">
            <summary>
            Sets if the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> should pack newly written segments in a
            compound file. Default is <code>true</code>.
            <p>
            Use <code>false</code> for batch indexing with very large ram buffer
            settings.
            </p>
            <p>
            <b>Note: To control compound file usage during segment merges see
            <seealso cref="!:MergePolicy#setNoCFSRatio(double)"/> and
            <seealso cref="!:MergePolicy#setMaxCFSSegmentSizeMB(double)"/>. this setting only
            applies to newly created segments.</b>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LiveIndexWriterConfig.SetCheckIntegrityAtMerge(System.Boolean)">
            <summary>
            Sets if <seealso cref="T:Lucene.Net.Index.IndexWriter"/> should call <seealso cref="!:AtomicReader#checkIntegrity()"/>
            on existing segments before merging them into a new one.
            <p>
            Use <code>true</code> to enable this safety check, which can help
            reduce the risk of propagating index corruption from older segments
            into new ones, at the expense of slower merging.
            </p>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Analyzer">
            <summary>
            Returns the default analyzer to use for indexing documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB">
            <summary>
            Returns the value set by <seealso cref="!:#setRAMBufferSizeMB(double)"/> if enabled. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer">
            <summary>
            Returns the current merged segment warmer. See <seealso cref="T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.OpenMode">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.OpenMode"/> set by <seealso cref="!:IndexWriterConfig#setOpenMode(OpenMode)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.DelPolicy">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.DelPolicy"/> specified in
            <seealso cref="!:IndexWriterConfig#setIndexDeletionPolicy(IndexDeletionPolicy)"/> or
            the default <seealso cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>/
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit"/> as specified in
            <seealso cref="!:IndexWriterConfig#setIndexCommit(IndexCommit)"/> or the default,
            {@code null} which specifies to open the latest index commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Similarity">
            <summary>
            Expert: returns the <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.Similarity"/> implementation used by this
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergeScheduler">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergeScheduler"/> that was set by
            <seealso cref="!:IndexWriterConfig#setMergeScheduler(MergeScheduler)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.WriteLockTimeout" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Codec">
            <summary>
            Returns the current <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.Codec"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.MergePolicy" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.IndexerThreadPool" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxThreadStates">
            <summary>
            Returns the max number of simultaneous threads that may be indexing
            documents at once in IndexWriter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderPooling">
            <summary>
            Returns {@code true} if <seealso cref="T:Lucene.Net.Index.IndexWriter"/> should pool readers even if
            <seealso cref="!:DirectoryReader#open(IndexWriter, boolean)"/> has not been called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexingChain">
            <summary>
            Returns the indexing chain set on
            <seealso cref="!:IndexWriterConfig#setIndexingChain(IndexingChain)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.RAMPerThreadHardLimitMB" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LiveIndexWriterConfig.InfoStream" -->
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile">
            <summary>
            Returns <code>true</code> iff the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> packs
            newly written segments in a compound file. Default is <code>true</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge">
            <summary>
            Returns true if <seealso cref="!:AtomicReader#checkIntegrity()"/> is called before
             merging segments.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL">
            <summary>
            Default value is 32. Change using <seealso cref="!:#setTermIndexInterval(int)"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH">
            <summary>
            Denotes a flush trigger is disabled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DELETE_TERMS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DOCS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB">
            <summary>
            Default value is 16 MB (which means flush when buffered docs consume
            approximately 16 MB RAM).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_POOLING">
            <summary>
            Default setting for <seealso cref="!:#setReaderPooling"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_TERMS_INDEX_DIVISOR">
            <summary>
            Default value is 1. Change using <seealso cref="!:#setReaderTermsIndexDivisor(int)"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB">
            <summary>
            Default value is 1945. Change using <seealso cref="!:#setRAMPerThreadHardLimitMB(int)"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES">
            <summary>
            The maximum number of simultaneous threads that may be
             indexing documents at once in IndexWriter; if more
             than this many threads arrive they will wait for
             others to finish. Default value is 8.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_USE_COMPOUND_FILE_SYSTEM">
            <summary>
            Default value for compound file system for newly written segments
             (set to <code>true</code>). For batch indexing with very large
             ram buffers use <code>false</code>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_CHECK_INTEGRITY_AT_MERGE">
            <summary>
            Default value for calling <seealso cref="!:AtomicReader#checkIntegrity()"/> before
             merging segments (set to <code>false</code>). You can set this
             to <code>true</code> for additional safety.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.IndexWriterConfig.WRITE_LOCK_TIMEOUT" -->
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetIndexWriter(Lucene.Net.Index.IndexWriter)">
            <summary>
            Sets the <seealso cref="T:Lucene.Net.Index.IndexWriter"/> this config is attached to.
            </summary>
            <exception cref="!:AlreadySetException">
                      if this config is already attached to a writer. </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new config that with defaults that match the specified
            <seealso cref="T:Lucene.Net.Util.LuceneVersion"/> as well as the default {@link
            Analyzer}. If matchVersion is &gt;= {@link
            Version#LUCENE_32}, <seealso cref="T:Lucene.Net.Index.TieredMergePolicy"/> is used
            for merging; else <seealso cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.
            Note that <seealso cref="T:Lucene.Net.Index.TieredMergePolicy"/> is free to select
            non-contiguous merges, which means docIDs may not
            remain monotonic over time.  If this is a problem you
            should switch to <seealso cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> or
            <seealso cref="T:Lucene.Net.Index.LogDocMergePolicy"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetOpenMode(System.Nullable{Lucene.Net.Index.IndexWriterConfig.OpenMode_e})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(Lucene.Net.Index.IndexDeletionPolicy)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetIndexCommit(Lucene.Net.Index.IndexCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetSimilarity(Lucene.Net.Search.Similarities.Similarity)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetMergeScheduler(Lucene.Net.Index.MergeScheduler)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetWriteLockTimeout(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetMergePolicy(Lucene.Net.Index.MergePolicy)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetCodec(Lucene.Net.Codecs.Codec)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetIndexerThreadPool(Lucene.Net.Index.DocumentsWriterPerThreadPool)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetMaxThreadStates(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetReaderPooling(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetIndexingChain(Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetFlushPolicy(Lucene.Net.Index.FlushPolicy)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriterConfig.SetRAMPerThreadHardLimitMB(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)">
            <summary>
            Information about merges, deletes and a
            message when maxFieldLength is reached will be printed
            to this. Must not be null, but <seealso cref="!:InfoStream#NO_OUTPUT"/>
            may be used to supress output.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(System.IO.TextWriter)">
            <summary>
            Convenience method that uses <seealso cref="T:Lucene.Net.Util.PrintStreamInfoStream"/>.  Must not be null.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout">
            <summary>
            Sets the default (for any instance) maximum time to wait for a write lock
            (in milliseconds).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriterConfig.OpenMode_e">
            <summary>
            Specifies the open mode for <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.OpenMode_e.CREATE">
            <summary>
            Creates a new index or overwrites an existing one.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.OpenMode_e.APPEND">
            <summary>
            Opens an existing index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.OpenMode_e.CREATE_OR_APPEND">
            <summary>
            Creates a new index if one does not exist,
            otherwise it opens the index and documents will be appended.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Abort">
            <summary>
            Abort (called after hitting AbortException) </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.InvertedDocConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Flush a new segment </summary>
        </member>
        <member name="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy">
            <summary>
            this <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation that
            keeps only the most recent commit and immediately removes
            all prior commits after a new commit is done.  this is
            the default deletion policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogByteSizeMergePolicy">
            <summary>
            this is a <seealso cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
             segment as the total byte size of the segment's files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogMergePolicy">
             <summary>
             <p>this class implements a <seealso cref="T:Lucene.Net.Index.MergePolicy"/> that tries
             to merge segments into levels of exponentially
             increasing size, where each level has fewer segments than
             the value of the merge factor. Whenever extra segments
             (beyond the merge factor upper bound) are encountered,
             all segments within the level are merged. You can get or
             set the merge factor using <seealso cref="!:#getMergeFactor()"/> and
             <seealso cref="!:#setMergeFactor(int)"/> respectively.</p>
            
             <p>this class is abstract and requires a subclass to
             define the <seealso cref="!:#size"/> method which specifies how a
             segment's size is determined.  <seealso cref="T:Lucene.Net.Index.LogDocMergePolicy"/>
             is one subclass that measures size by document count in
             the segment.  <seealso cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> is another
             subclass that measures size as the total byte size of the
             file(s) for the segment.</p>
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy">
             <summary>
             <p>Expert: a MergePolicy determines the sequence of
             primitive merge operations.</p>
            
             <p>Whenever the segments in an index have been altered by
             <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/>, either the addition of a newly
             flushed segment, addition of many segments from
             addIndexes* calls, or a previous merge that may now need
             to cascade, <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/> invokes {@link
             #findMerges} to give the MergePolicy a chance to pick
             merges that are now required.  this method returns a
             <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> instance describing the set of
             merges that should be done, or null if no merges are
             necessary.  When IndexWriter.forceMerge is called, it calls
             <seealso cref="!:#findForcedMerges(SegmentInfos,int,Map)"/> and the MergePolicy should
             then return the necessary merges.</p>
            
             <p>Note that the policy can return more than one merge at
             a time.  In this case, if the writer is using {@link
             SerialMergeScheduler}, the merges will be run
             sequentially but if it is using {@link
             ConcurrentMergeScheduler} they will be run concurrently.</p>
            
             <p>The default MergePolicy is {@link
             TieredMergePolicy}.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default ratio for compound file system usage. Set to <tt>1.0</tt>, always use
            compound file system.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_MAX_CFS_SEGMENT_SIZE">
            <summary>
            Default max segment size in order to use compound file system. Set to <seealso cref="!:Long#MAX_VALUE"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.Writer">
            <summary>
            <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/> that contains this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.NoCFSRatio_Renamed">
            <summary>
            If the size of the merge segment exceeds this ratio of
             the total index size then it will remain in
             non-compound format
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSize">
            <summary>
            If the size of the merged segment exceeds
             this value then it will not use compound file format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor">
            <summary>
            Creates a new merge policy instance. Note that if you intend to use it
            without passing it to <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/>, you should call
            <seealso cref="!:#setIndexWriter(IndexWriter)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor(System.Double,System.Int64)">
            <summary>
            Creates a new merge policy instance with default settings for noCFSRatio
            and maxCFSSegmentSize. this ctor should be used by subclasses using different
            defaults than the <seealso cref="T:Lucene.Net.Index.MergePolicy"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMerges(System.Nullable{Lucene.Net.Index.MergeTrigger},Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations are now necessary on the index.
            <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/> calls this whenever there is a change to the segments.
            this call is always synchronized on the <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/> instance so
            only one thread at a time will call this method. </summary>
            <param name="mergeTrigger"> the event that triggered the merge </param>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})" -->
        <member name="M:Lucene.Net.Index.MergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations is necessary in order to expunge all
            deletes from the index.
            </summary>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Dispose">
            <summary>
            Release all resources for the policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundFile(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns true if a new segment (regardless of its origin) should use the
            compound file format. The default implementation returns <code>true</code>
            iff the size of the given mergedInfo is less or equal to
            <seealso cref="!:#getMaxCFSSegmentSizeMB()"/> and the size is less or equal to the
            TotalIndexSize * <seealso cref="!:#getNoCFSRatio()"/> otherwise <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Size(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided {@link
             SegmentCommitInfo}, pro-rated by percentage of
             non-deleted documents is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns true if this single info is already fully merged (has no
             pending deletes, is in the same dir as the
             writer, and matches the current compound file setting
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MergePolicy.IndexWriter" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MergePolicy.NoCFSRatio" -->
        <member name="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB">
            <summary>
            Returns the largest size allowed for a compound file segment </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.DocMap">
            <summary>
            A map of doc IDs. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.#ctor">
            <summary>
            Sole constructor, typically invoked from sub-classes constructors. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.Map(System.Int32)">
            <summary>
            Return the new doc ID according to its old value. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.IsConsistent(System.Int32)">
            <summary>
            Useful from an assert. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.OneMerge">
            <summary>
            OneMerge provides the information necessary to perform
             an individual primitive merge operation, resulting in
             a single new segment.  The merge spec includes the
             subset of segments to be merged as well as whether the
             new segment should use the compound file format.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.OneMerge.EstimatedMergeBytes">
            <summary>
            Estimated size in bytes of the merged segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.OneMerge.Segments">
            <summary>
            Segments to be merged. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.OneMerge.TotalDocCount">
            <summary>
            Number of documents in the merged segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Sole constructor. </summary>
            <param name="segments"> List of <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s
                   to be merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetDocMap(Lucene.Net.Index.MergeState)">
            <summary>
            Expert: If <seealso cref="!:#getMergeReaders()"/> reorders document IDs, this method
             must be overridden to return a mapping from the <i>natural</i> doc ID
             (the doc ID that would result from a natural merge) to the actual doc
             ID. this mapping is used to apply deletions that happened during the
             merge to the new segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.Abort">
            <summary>
            Mark this merge as aborted.  If this is called
             before the merge is committed then the merge will
             not be committed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.CheckAborted(Lucene.Net.Store.Directory)">
            <summary>
            Called periodically by <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/> while
             merging to see if the merge is aborted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a readable description of the current merge
             state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.TotalBytesSize">
            <summary>
            Returns the total size in bytes of this merge. Note that this does not
            indicate the size of the merged segment, but the
            input total size. this is only set once the merge is
            initialized by IndexWriter.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.TotalNumDocs">
             <summary>
             Returns the total number of documents that are included with this merge.
             Note that this does not indicate the number of documents after the merge.
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeReaders">
            <summary>
            Expert: Get the list of readers to merge. Note that this list does not
             necessarily match the list of segments to merge and should only be used
             to feed SegmentMerger to initialize a merge. When a <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>
             reorders doc IDs, it must override <seealso cref="!:#getDocMap"/> too so that
             deletes that happened during the merge can be applied to the newly
             merged segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Info">
            <summary>
            Expert: Sets the <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> of this <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>.
            Allows sub-classes to e.g. set diagnostics properties.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Exception">
            <summary>
            Record that an exception occurred while executing
             this merge
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Aborted">
            <summary>
            Returns true if this merge was aborted. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Pause">
            <summary>
            Set or clear whether this merge is paused paused (for example
             <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/> will pause merges
             if too many are running).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeInfo">
            <summary>
            Return <seealso cref="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeInfo"/> describing this merge. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeSpecification">
            <summary>
            A MergeSpecification instance provides the information
            necessary to perform multiple merges.  It simply
            contains a list of <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.MergeSpecification.Merges">
            <summary>
            The subset of segments to be included in the primitive merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.#ctor">
            <summary>
            Sole constructor.  Use {@link
             #add(MergePolicy.OneMerge)} to add merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.Add(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Adds the provided <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> to this
             specification.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a description of the merges in this
             specification.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeException">
            <summary>
            Exception thrown if there are any problems while
             executing a merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.String,Lucene.Net.Store.Directory)">
            <summary>
            Create a {@code MergeException}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.Exception,Lucene.Net.Store.Directory)">
            <summary>
            Create a {@code MergeException}. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MergeException.Directory">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.MergePolicy.MergeException.Directory"/> of the index that hit
             the exception.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeAbortedException">
            <summary>
            Thrown when a merge was explicity aborted because
             <seealso cref="!:IndexWriter#close(boolean)"/> was called with
             <code>false</code>.  Normally this exception is
             privately caught and suppresed by <seealso cref="P:Lucene.Net.Index.MergePolicy.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor(System.String)">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/> with a
             specified message.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.LEVEL_LOG_SPAN">
            <summary>
            Defines the allowed range of log(size) for each
             level.  A level is computed by taking the max segment
             log size, minus LEVEL_LOG_SPAN, and finding all
             segments falling within that range.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            <summary>
            Default merge factor, which is how many segments are
             merged at a time
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogMergePolicy.DEFAULT_NO_CFS_RATIO" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MAX_MERGE_DOCS" -->
        <member name="F:Lucene.Net.Index.LogMergePolicy.MergeFactor_Renamed">
            <summary>
            How many segments to merge at a time. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.MinMergeSize">
            <summary>
            Any segments whose size is smaller than this value
             will be rounded up to this value.  this ensures that
             tiny segments are aggressively merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.MaxMergeSize">
            <summary>
            If the size of a segment exceeds this value then it
             will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.MaxMergeSizeForForcedMerge">
            <summary>
            If the size of a segment exceeds this value then it
            will never be merged during <seealso cref="!:IndexWriter#forceMerge"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs_Renamed">
            <summary>
            If a segment has more than this many documents then it
             will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes_Renamed">
            <summary>
            If true, we pro-rate a segment's size by the
             percentage of non-deleted documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.Verbose">
            <summary>
            Returns true if {@code LMP} is enabled in {@link
             IndexWriter}'s {@code infoStream}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.Message(System.String)">
            <summary>
            Print a debug message to <seealso cref="T:Lucene.Net.Index.IndexWriter"/>'s {@code
             infoStream}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the number of documents in the provided {@link
             SegmentCommitInfo}, pro-rated by percentage of
             non-deleted documents if {@link
             #setCalibrateSizeByDeletes} is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeBytes(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided {@link
             SegmentCommitInfo}, pro-rated by percentage of
             non-deleted documents if {@link
             #setCalibrateSizeByDeletes} is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns true if the number of segments eligible for
             merging is less than or equal to the specified {@code
             maxNumSegments}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesSizeLimit(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to merge the index, taking the max merge
            size or max merge docs into consideration. this method attempts to respect
            the {@code maxNumSegments} parameter, however it might be, due to size
            constraints, that more than that number of segments will remain in the
            index. Also, this method does not guarantee that exactly {@code
            maxNumSegments} will remain, but &lt;= that number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesMaxNumSegments(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to forceMerge the index. this method constraints
            the returned merges only by the {@code maxNumSegments} parameter, and
            guaranteed that exactly that number of segments will remain in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns the merges necessary to merge the index down
             to a specified number of segments.
             this respects the <seealso cref="!:#maxMergeSizeForForcedMerge"/> setting.
             By default, and assuming {@code maxNumSegments=1}, only
             one segment will be left in the index, where that segment
             has no deletions pending nor separate norms, and it is in
             compound file format if the current useCompoundFile
             setting is true.  this method returns multiple merges
             (mergeFactor at a time) so the <seealso cref="T:Lucene.Net.Index.MergeScheduler"/>
             in use may make use of concurrency.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Finds merges necessary to force-merge all deletes from the
            index.  We simply merge adjacent segments that have
            deletes, up to mergeFactor at a time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMerges(System.Nullable{Lucene.Net.Index.MergeTrigger},Lucene.Net.Index.SegmentInfos)">
            <summary>
            Checks if any merges are now necessary and returns a
             <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> if so.  A merge
             is necessary when there are more than {@link
             #setMergeFactor} segments at a given level.  When
             multiple levels have too many segments, this method
             will return multiple merges, allowing the {@link
             MergeScheduler} to use concurrency.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MergeFactor">
            <summary>
            <p>Returns the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.</p>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes">
            <summary>
            Sets whether the segment size should be calibrated by
             the number of deletes when choosing segments for merge.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs">
             <summary>
             <p>Determines the largest segment (measured by
             document count) that may be merged with other segments.
             Small values (e.g., less than 10,000) are best for
             interactive indexing, as this limits the length of
             pauses while indexing to a few seconds.  Larger values
             are best for batched indexing and speedier
             searches.</p>
            
             <p>The default value is <seealso cref="!:Integer#MAX_VALUE"/>.</p>
            
             <p>The default merge policy ({@link
             LogByteSizeMergePolicy}) also allows you to set this
             limit by net size (in MB) of the segment, using {@link
             LogByteSizeMergePolicy#setMaxMergeMB}.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB_FOR_FORCED_MERGE" -->
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
             defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB">
             <summary>
             <p>Determines the largest segment (measured by total
              byte size of the segment's files, in MB) that may be
              merged with other segments.  Small values (e.g., less
              than 50 MB) are best for interactive indexing, as this
              limits the length of pauses while indexing to a few
              seconds.  Larger values are best for batched indexing
              and speedier searches.</p>
            
              <p>Note that <seealso cref="!:#setMaxMergeDocs"/> is also
              used to check whether a segment is too large for
              merging (it's either or).</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMBForForcedMerge" -->
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MinMergeMB">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  this effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogDocMergePolicy">
            <summary>
            this is a <seealso cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
             segment as the number of documents (not taking deletions
             into account).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS" -->
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
             defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogDocMergePolicy.MinMergeDocs">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  this effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState">
             <summary>
             Holds common state used during segment merging.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.SegmentInfo">
            <summary>
            <seealso cref="F:Lucene.Net.Index.MergeState.SegmentInfo"/> of the newly merged segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.FieldInfos">
            <summary>
            <seealso cref="F:Lucene.Net.Index.MergeState.FieldInfos"/> of the newly merged segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.Readers">
            <summary>
            Readers being merged. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.DocMaps">
            <summary>
            Maps docIDs around deletions. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.DocBase">
            <summary>
            New docID base per reader. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.checkAbort">
            <summary>
            Holds the CheckAbort instance, which is invoked
             periodically to see if the merge has been aborted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.InfoStream">
            <summary>
            InfoStream for debugging messages. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.MatchingSegmentReaders">
            <summary>
            <seealso cref="T:Lucene.Net.Index.SegmentReader"/>s that have identical field
            name/number mapping, so their stored fields and term
            vectors may be bulk merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.MatchedCount">
            <summary>
            How many <seealso cref="!:#matchingSegmentReaders"/> are set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReader},Lucene.Net.Index.SegmentInfo,Lucene.Net.Util.InfoStream,Lucene.Net.Index.MergeState.CheckAbort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState.DocMap">
            <summary>
            Remaps docids around deletes during merge
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Get(System.Int32)">
            <summary>
            Returns the mapped docID corresponding to the provided one. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.HasDeletions">
            <summary>
            Returns true if there are any deletions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Build(Lucene.Net.Index.AtomicReader)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.MergeState.DocMap"/> instance appropriate for
             this reader.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.MaxDoc">
            <summary>
            Returns the total number of documents, ignoring
             deletions.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDocs">
            <summary>
            Returns the number of not-deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState.CheckAbort">
            <summary>
            Class for recording units of work when merging segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.CheckAbort.#ctor(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Store.Directory)">
            <summary>
            Creates a #CheckAbort instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.CheckAbort.Work(System.Double)">
            <summary>
            Records the fact that roughly units amount of work
            have been done since this method was last called.
            When adding time-consuming code into SegmentMerger,
            you should test different values for units to ensure
            that the time in between calls to merge.checkAborted
            is up to ~ 1 second.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeState.CheckAbort.NONE">
            <summary>
            If you use this: IW.close(false) cannot abort your merge!
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeTrigger">
            <summary>
            MergeTrigger is passed to
            <seealso cref="!:Lucene.Net.Index.MergePolicy#findMerges(MergeTrigger, Lucene.Net.Index.SegmentInfos)"/> to indicate the
            event that triggered the merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.SEGMENT_FLUSH">
            <summary>
            Merge was triggered by a segment flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.FULL_FLUSH">
            <summary>
            Merge was triggered by a full flush. Full flushes
            can be caused by a commit, NRT reader reopen or a close call on the index writer.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.EXPLICIT">
            <summary>
            Merge has been triggered explicitly by the user.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.MERGE_FINISHED">
            <summary>
            Merge was triggered by a successfully finished merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.CLOSING">
            <summary>
            Merge was triggered by a closing IndexWriter.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiBits" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiBits.GetMatchingSub(Lucene.Net.Index.ReaderSlice)" -->
        <member name="T:Lucene.Net.Index.MultiBits.SubResult">
            <summary>
            Represents a sub-Bits from
            <seealso cref="!:MultiBits#getMatchingSub(Lucene.Net.Index.ReaderSlice) getMatchingSub()"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns {@code true} if this instance can be reused by
             the provided <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.Reset(Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice[],System.Int32)">
            <summary>
            Rre-use and reset this instance on the provided slices. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiDocsAndPositionsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice">
            <summary>
            Holds a <seealso cref="F:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum"/> along with the
             corresponding <seealso cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum">
            <summary>
            <seealso cref="F:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum"/> for this sub-reader. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.Slice">
            <summary>
            <seealso cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
             fits into the composite reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum">
             <summary>
             Exposes <seealso cref="T:Lucene.Net.Index.DocsEnum"/>, merged from <seealso cref="T:Lucene.Net.Index.DocsEnum"/>
             API of sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor </summary>
            <param name="parent"> The <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/> that created us. </param>
            <param name="subReaderCount"> How many sub-readers are being merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns {@code true} if this instance can be reused by
             the provided <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiDocsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Index.MultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice">
            <summary>
            Holds a <seealso cref="F:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum"/> along with the
             corresponding <seealso cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum">
            <summary>
            <seealso cref="F:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum"/> of this sub-reader. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.Slice">
            <summary>
            <seealso cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
             fits into the composite reader.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiDocValues" -->
        <member name="M:Lucene.Net.Index.MultiDocValues.#ctor">
            <summary>
            No instantiation </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNormValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a NumericDocValues for a reader's norms (potentially merging on-the-fly).
            <p>
            this is a slow way to access normalization values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getNormValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNumericValues(Lucene.Net.Index.IndexReader,System.String)">
             <summary>
             Returns a NumericDocValues for a reader's docvalues (potentially merging on-the-fly)
             <p>
             this is a slow way to access numeric values. Instead, access them per-segment
             with <seealso cref="!:AtomicReader#getNumericDocValues(String)"/>
             </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetDocsWithField(Lucene.Net.Index.IndexReader,System.String)">
             <summary>
             Returns a Bits for a reader's docsWithField (potentially merging on-the-fly)
             <p>
             this is a slow way to access this bitset. Instead, access them per-segment
             with <seealso cref="!:AtomicReader#getDocsWithField(String)"/>
             </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetBinaryValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)
            <p>
            this is a slow way to access binary values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getBinaryDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).
            <p>
            this is an extremely slow way to access sorted values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getSortedDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedSetValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).
            <p>
            this is an extremely slow way to access sorted values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getSortedSetDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.OrdinalMap">
            <summary>
            maps per-segment ordinals to/from global ordinal space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.#ctor(System.Object,Lucene.Net.Index.TermsEnum[])">
            <summary>
            Creates an ordinal map that allows mapping ords to/from a merged
            space from <code>subs</code>. </summary>
            <param name="owner"> a cache key </param>
            <param name="subs"> TermsEnums that support <seealso cref="!:TermsEnum#ord()"/>. They need
                        not be dense (e.g. can be FilteredTermsEnums}. </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetGlobalOrd(System.Int32,System.Int64)">
            <summary>
            Given a segment number and segment ordinal, returns
            the corresponding global ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentOrd(System.Int64)">
            <summary>
            Given global ordinal, returns the ordinal of the first segment which contains
            this ordinal (the corresponding to the segment return <seealso cref="!:#getFirstSegmentNumber"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentNumber(System.Int64)">
            <summary>
            Given a global ordinal, returns the index of the first
            segment that contains this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.RamBytesUsed">
            <summary>
            Returns total byte size used by this ordinal map.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.OrdinalMap.ValueCount">
            <summary>
            Returns the total number of unique terms in global ord space.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues">
            <summary>
            Implements SortedDocValues over n subs, using an OrdinalMap
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <seealso cref="!:#values"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <code>values</code> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.#ctor(Lucene.Net.Index.SortedDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new MultiSortedDocValues over <code>values</code> </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues">
            <summary>
            Implements MultiSortedSetDocValues over n subs, using an OrdinalMap
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <seealso cref="!:#values"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="F:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <code>values</code> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.#ctor(Lucene.Net.Index.SortedSetDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new MultiSortedSetDocValues over <code>values</code> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiFields" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetFields(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetLiveDocs(Lucene.Net.Index.IndexReader)" -->
        <member name="M:Lucene.Net.Index.MultiFields.GetTerms(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
             this method may return null if the field does not exist. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.Bits,System.String,Lucene.Net.Util.BytesRef,System.Int32)" -->
        <member name="M:Lucene.Net.Index.MultiFields.#ctor(Lucene.Net.Index.Fields[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Expert: construct a new MultiFields instance directly.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetMergedFieldInfos(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetIndexedFields(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiReader" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[],System.Boolean)" -->
        <member name="T:Lucene.Net.Index.MultiTerms">
             <summary>
             Exposes flex API, merged from flex API of
             sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTerms.#ctor(Lucene.Net.Index.Terms[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor.
            </summary>
            <param name="subs"> The <seealso cref="T:Lucene.Net.Index.Terms"/> instances of all sub-readers. </param>
            <param name="subSlices"> A parallel array (matching {@code
                   subs}) describing the sub-reader slices. </param>
        </member>
        <member name="T:Lucene.Net.Index.MultiTermsEnum">
             <summary>
             Exposes <seealso cref="T:Lucene.Net.Index.TermsEnum"/> API, merged from <seealso cref="T:Lucene.Net.Index.TermsEnum"/> API of sub-segments.
             this does a merge sort, by term text, of the sub-readers.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.#ctor(Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor. </summary>
             <param name="slices"> Which sub-reader slices we should
             merge.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.Reset(Lucene.Net.Index.MultiTermsEnum.TermsEnumIndex[])">
            <summary>
            The terms array must be newly created TermsEnum, ie
             <seealso cref="!:TermsEnum#next"/> has not yet been called.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiTermsEnum.MatchCount" -->
        <member name="P:Lucene.Net.Index.MultiTermsEnum.MatchArray">
            <summary>
            Returns sub-reader slices positioned to the current term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.PriorityQueue`1" -->
        <member name="M:Lucene.Net.Util.PriorityQueue`1.LessThan(`0,`0)">
            <summary>
            Determines the ordering of objects in this priority queue.  Subclasses
             must define this one method. </summary>
             <returns> <code>true</code> iff parameter <tt>a</tt> is less than parameter <tt>b</tt>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Add(`0)">
            <summary>
            Adds an Object to a PriorityQueue in log(size) time. If one tries to add
            more objects than maxSize from initialize an
            <seealso cref="T:System.IndexOutOfRangeException"/> is thrown.
            </summary>
            <returns> the new 'top' element in the queue. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.InsertWithOverflow(`0)">
            <summary>
            Adds an Object to a PriorityQueue in log(size) time.
            It returns the object (if any) that was
            dropped off the heap because it was full. this can be
            the given parameter (in case it is smaller than the
            full heap's minimum, and couldn't be added), or another
            object that was previously the smallest value in the
            heap and now has been replaced by a larger one, or null
            if the queue wasn't yet full with maxSize elements.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Top">
            <summary>
            Returns the least element of the PriorityQueue in constant time.
            Returns null if the queue is empty. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Pop">
            <summary>
            Removes and returns the least element of the PriorityQueue in log(size)
             time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.UpdateTop">
             <summary>
             Should be called when the Object at top changes values. Still log(n) worst
             case, but it's at least twice as fast to
            
             <pre class="prettyprint">
             pq.top().change();
             pq.updateTop();
             </pre>
            
             instead of
            
             <pre class="prettyprint">
             o = pq.pop();
             o.change();
             pq.push(o);
             </pre>
             </summary>
             <returns> the new 'top' element. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Size">
            <summary>
            Returns the number of elements currently stored in the PriorityQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Clear">
            <summary>
            Removes all entries from the PriorityQueue. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.PriorityQueue`1.SentinelObject" -->
        <member name="P:Lucene.Net.Util.PriorityQueue`1.HeapArray">
            <summary>
            this method returns the internal heap array as Object[].
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoDeletionPolicy">
            <summary>
            An <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> which keeps all index commits around, never
            deleting them. this class is a singleton and can be accessed by referencing
            <seealso cref="!:#INSTANCE"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoDeletionPolicy.INSTANCE">
            <summary>
            The single instance of this class. </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergePolicy">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.MergePolicy"/> which never returns merges to execute (hence it's
            name). It is also a singleton and can be accessed through
            <seealso cref="!:NoMergePolicy#NO_COMPOUND_FILES"/> if you want to indicate the index
            does not use compound files, or through <seealso cref="!:NoMergePolicy#COMPOUND_FILES"/>
            otherwise. Use it if you want to prevent an <seealso cref="P:Lucene.Net.Index.NoMergePolicy.IndexWriter"/> from ever
            executing merges, without going through the hassle of tweaking a merge
            policy's settings to achieve that, such as changing its merge factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.NO_COMPOUND_FILES">
            <summary>
            A singleton <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index does not use
            compound files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.COMPOUND_FILES">
            <summary>
            A singleton <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index uses compound
            files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergeScheduler">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> which never executes any merges. It is also a
            singleton and can be accessed through <seealso cref="!:NoMergeScheduler#INSTANCE"/>. Use
            it if you want to prevent an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> from ever executing merges,
            regardless of the <seealso cref="T:Lucene.Net.Index.MergePolicy"/> used. Note that you can achieve the
            same thing by using <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/>, however with
            <seealso cref="T:Lucene.Net.Index.NoMergeScheduler"/> you also ensure that no unnecessary code of any
            <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> implementation is ever executed. Hence it is
            recommended to use both if you want to disable merges from ever happening.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergeScheduler.INSTANCE">
            <summary>
            The single instance of <seealso cref="T:Lucene.Net.Index.NoMergeScheduler"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.NormsConsumer">
            <summary>
            Writes norms.  Each thread X field accumulates the norms
             for the doc/fields it saw, then the flush method below
             merges all of these together into a single _X.nrm file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesFieldUpdates">
             <summary>
             A <seealso cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesWriter">
            <summary>
            Buffers up pending long per doc, then flushes when
             segment flushes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelAtomicReader" -->
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a ParallelAtomicReader based on the provided
             readers; auto-closes the given readers on <seealso cref="!:#close()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a ParallelAtomicReader based on the provided
             readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: create a ParallelAtomicReader based on the provided
             readers and storedFieldReaders; when a document is
             loaded, only storedFieldsReaders will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.ParallelAtomicReader.FieldInfos" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelCompositeReader" -->
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a ParallelCompositeReader based on the provided
             readers; auto-closes the given readers on <seealso cref="!:#close()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a ParallelCompositeReader based on the provided
             readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[],Lucene.Net.Index.CompositeReader[])">
            <summary>
            Expert: create a ParallelCompositeReader based on the provided
             readers and storedFieldReaders; when a document is
             loaded, only storedFieldsReaders will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SnapshotDeletionPolicy" -->
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.RefCounts">
            <summary>
            Records how many snapshots are held against each
             commit generation
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.IndexCommits">
            <summary>
            Used to map gen to IndexCommit. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.Primary">
            <summary>
            Wrapped <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.LastCommit">
            <summary>
            Most recently committed <seealso cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.InitCalled">
            <summary>
            Used to detect misuse </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Sole constructor, taking the incoming {@link
             IndexDeletionPolicy} to wrap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)">
            <summary>
            Release a snapshotted commit.
            </summary>
            <param name="commit">
                     the commit previously returned by <seealso cref="!:#snapshot"/> </param>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.ReleaseGen(System.Int64)">
            <summary>
            Release a snapshot by generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.IncRef(Lucene.Net.Index.IndexCommit)">
            <summary>
            Increments the refCount for this <seealso cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot" -->
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.GetIndexCommit(System.Int64)">
            <summary>
            Retrieve an <seealso cref="T:Lucene.Net.Index.IndexCommit"/> from its generation;
             returns null if this IndexCommit is not currently
             snapshotted
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.WrapCommits``1(System.Collections.Generic.IList{``0})">
            <summary>
            Wraps each <seealso cref="T:Lucene.Net.Index.IndexCommit"/> as a {@link
             SnapshotCommitPoint}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshots">
            <summary>
            Returns all IndexCommits held by at least one snapshot. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCount">
            <summary>
            Returns the total number of snapshots currently held. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint">
            <summary>
            Wraps a provided <seealso cref="T:Lucene.Net.Index.IndexCommit"/> and prevents it
             from being deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.Cp">
            <summary>
            The <seealso cref="T:Lucene.Net.Index.IndexCommit"/> we are preventing from deletion. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.#ctor(Lucene.Net.Index.SnapshotDeletionPolicy,Lucene.Net.Index.IndexCommit)">
            <summary>
            Creates a {@code SnapshotCommitPoint} wrapping the provided
             <seealso cref="T:Lucene.Net.Index.IndexCommit"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.SNAPSHOTS_PREFIX">
            <summary>
            Prefix used for the save file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory)">
            <summary>
            <seealso cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible
            snapshotting, passing <seealso cref="!:OpenMode#CREATE_OR_APPEND"/>
            by default.
            </summary>
            <param name="primary">
                     the <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <seealso cref="!:#release"/>. </param>
            <param name="dir">
                     the <seealso cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig.OpenMode_e)">
            <summary>
            <seealso cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible snapshotting.
            </summary>
            <param name="primary">
                     the <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <seealso cref="!:#release"/>. </param>
            <param name="dir">
                     the <seealso cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
            <param name="mode">
                     specifies whether a new index should be created, deleting all
                     existing snapshots information (immediately), or open an existing
                     index, initializing the class with the snapshots information. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Snapshot" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(System.Int64)" -->
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LoadPriorSnapshots">
            <summary>
            Reads the snapshots information from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. this
            method can be used if the snapshots information is needed, however you
            cannot instantiate the deletion policy (because e.g., some other process
            keeps a lock on the snapshots directory).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LastSaveFile">
            <summary>
            Returns the file name the snapshots are currently
             saved to, or null if no snapshots have been saved.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms">
            <summary>
            Prefix codes term instances (prefixes are shared)
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.GetEnumerator">
            <returns> iterator over the bytes </returns>
        </member>
        <member name="P:Lucene.Net.Index.PrefixCodedTerms.SizeInBytes">
            <returns> size in bytes </returns>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms.Builder">
            <summary>
            Builds a PrefixCodedTerms: call add repeatedly, then finish. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Add(Lucene.Net.Index.Term)">
            <summary>
            add a term </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Finish">
            <summary>
            return finalized form </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ReaderManager" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReferenceManager`1" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.DecRef(`0)">
            <summary>
            Decrement reference counting on the given reference. </summary>
            <exception cref="!:IOException"> if reference decrement on the given resource failed.
             </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RefreshIfNeeded(`0)">
            <summary>
            Refresh the given reference if needed. Returns {@code null} if no refresh
            was needed, otherwise a new refreshed reference. </summary>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the reference manager has been <seealso cref="!:#close() closed"/>. </exception>
            <exception cref="!:IOException"> if the refresh operation failed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.TryIncRef(`0)">
            <summary>
            Try to increment reference counting on the given reference. Return true if
            the operation was successful. </summary>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the reference manager has been <seealso cref="!:#close() closed"/>.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Acquire">
            <summary>
            Obtain the current reference. You must match every call to acquire with one
            call to <seealso cref="!:#release"/>; it's best to do so in a finally clause, and set
            the reference to {@code null} to prevent accidental usage after it has been
            released. </summary>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the reference manager has been <seealso cref="!:#close() closed"/>.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Dispose">
            <summary>
            <p>
            Closes this ReferenceManager to prevent future <seealso cref="!:#acquire() acquiring"/>. A
            reference manager should be closed if the reference to the managed resource
            should be disposed or the application using the <seealso cref="T:Lucene.Net.Search.ReferenceManager"/>
            is shutting down. The managed resource might not be released immediately,
            if the <seealso cref="T:Lucene.Net.Search.ReferenceManager"/> user is holding on to a previously
            <seealso cref="!:#acquire() acquired"/> reference. The resource will be released once
            when the last reference is <seealso cref="!:#release(Object) released"/>. Those
            references can still be used as if the manager was still active.
            </p>
            <p>
            Applications should not <seealso cref="!:#acquire() acquire"/> new references from this
            manager once this method has been called. <seealso cref="!:#acquire() Acquiring"/> a
            resource on a closed <seealso cref="T:Lucene.Net.Search.ReferenceManager"/> will throw an
            <seealso cref="T:Lucene.Net.Store.AlreadyClosedException"/>.
            </p>
            </summary>
            <exception cref="!:IOException">
                      if the underlying reader of the current reference could not be closed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.GetRefCount(`0)">
            <summary>
            Returns the current reference count of the given reference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AfterClose">
            <summary>
             Called after close(), so subclass can free any resources. </summary>
             <exception cref="!:IOException"> if the after close operation in a sub-class throws an <seealso cref="!:IOException"/>
             </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.MaybeRefreshBlocking" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AfterMaybeRefresh">
            <summary>
            Called after a refresh was attempted, regardless of
             whether a new reference was in fact created. </summary>
             <exception cref="!:IOException"> if a low level I/O exception occurs
             </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.Release(`0)" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AddListener(Lucene.Net.Search.ReferenceManager.RefreshListener)">
            <summary>
            Adds a listener, to be notified when a reference is refreshed/swapped.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RemoveListener(Lucene.Net.Search.ReferenceManager.RefreshListener)">
            <summary>
            Remove a listener added with <seealso cref="!:#addListener(RefreshListener)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Creates and returns a new ReaderManager from the given
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     the IndexWriter to open the IndexReader from. </param>
            <param name="applyAllDeletes">
                     If <code>true</code>, all buffered deletes will be applied (made
                     visible) in the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> / <seealso cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <code>false</code>, the deletes may or may not be applied, but
                     remain buffered (in IndexWriter) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <code>false</code>. See
                     <seealso cref="!:DirectoryReader#openIfChanged(DirectoryReader, IndexWriter, boolean)"/>.
            </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Creates and returns a new ReaderManager from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> the directory to open the DirectoryReader on.
            </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReader(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.SegmentReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a ref to a clone. NOTE: you should decRef() the reader when you're
            dont (ie do not call close()).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReaderForMerge(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a reader for merge. this method applies field updates if there are
            any and marks that this segment is currently merging.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.DropMergingUpdates">
            <summary>
            Drops all merging updates. Called from IndexWriter after this segment
            finished merging (whether successfully or not).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReadersAndUpdates.MergingFieldUpdates">
            <summary>
            Returns updates that came in while this segment was merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderSlice">
             <summary>
             Subreader slice from a parent composite reader.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.EMPTY_ARRAY">
            <summary>
            Zero-length {@code ReaderSlice} array. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.Start">
            <summary>
            Document ID this slice starts from. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.Length">
            <summary>
            Number of documents in this slice. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.ReaderIndex">
            <summary>
            Sub-reader index for this slice. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderSlice.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderUtil">
             <summary>
             Common util methods for dealing with <seealso cref="T:Lucene.Net.Index.IndexReader"/>s and <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>s.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.GetTopLevelContext(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Walks up the reader tree and return the given context's top level reader
            context, or in other words the reader tree's root context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Int32[])">
            <summary>
            Returns index of the searcher/reader for document <code>n</code> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Returns index of the searcher/reader for document <code>n</code> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCommitInfo">
             <summary>
             Embeds a [read-only] SegmentInfo and adds per-commit
              fields.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentCommitInfo.Info">
            <summary>
            The <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.#ctor(Lucene.Net.Index.SegmentInfo,System.Int32,System.Int64,System.Int64)">
            <summary>
            Sole constructor.
            </summary>
            <param name="info">
                     <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap </param>
            <param name="delCount">
                     number of deleted documents in this segment </param>
            <param name="delGen">
                     deletion generation number (used to name deletion files) </param>
            <param name="fieldInfosGen">
                     FieldInfos generation number (used to name field-infos files)
             </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceDelGen">
            <summary>
            Called when we succeed in writing deletes </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteDelGen">
            <summary>
            Called if there was an exception while writing
             deletes, so that we don't try to write to the same
             file more than once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceFieldInfosGen">
            <summary>
            Called when we succeed in writing a new FieldInfos generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteFieldInfosGen">
            <summary>
            Called if there was an exception while writing a new generation of
            FieldInfos, so that we don't try to write to the same file more than once.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentCommitInfo.SizeInBytes" -->
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.Files">
            <summary>
            Returns all files in use by this segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.HasDeletions">
            <summary>
            Returns true if there are any deletions for the
            segment at this commit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.HasFieldUpdates">
            <summary>
            Returns true if there are any field updates for the segment in this commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Returns a description of this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.UpdatesFiles">
            <summary>
            Returns the per generation updates files. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.GenUpdatesFiles">
            <summary>
            Sets the updates file names per generation. Does not deep clone the map. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextFieldInfosGen">
            <summary>
            Returns the next available generation number of the FieldInfos files. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.FieldInfosGen">
            <summary>
            Returns the generation number of the field infos file or -1 if there are no
            field updates yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextDelGen">
            <summary>
            Returns the next available generation number
            of the live docs file.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelGen">
            <summary>
            Returns generation number of the live docs file
            or -1 if there are no deletes yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelCount">
            <summary>
            Returns the number of deleted docs in the segment.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCoreReaders">
            <summary>
            Holds core readers that are shared (unchanged) when
            SegmentReader is cloned or reopened
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCoreReaders.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="T:Lucene.Net.Util.IDisposableThreadLocal`1">
             <summary>
             Java's builtin ThreadLocal has a serious flaw:
              it can take an arbitrarily long amount of time to
              dereference the things you had stored in it, even once the
              ThreadLocal instance itself is no longer referenced.
              this is because there is single, master map stored for
              each thread, which all ThreadLocals share, and that
              master map only periodically purges "stale" entries.
            
              While not technically a memory leak, because eventually
              the memory will be reclaimed, it can take a long time
              and you can easily hit OutOfMemoryError because from the
              GC's standpoint the stale entries are not reclaimable.
            
              this class works around that, by only enrolling
              WeakReference values into the ThreadLocal, and
              separately holding a hard reference to each stored
              value.  When you call <seealso cref="!:#close"/>, these hard
              references are cleared and then GC is freely able to
              reclaim space by objects stored in it.
            
              We can not rely on <seealso cref="!:ThreadLocal#remove()"/> as it
              only removes the value for the caller thread, whereas
              <seealso cref="!:#close"/> takes care of all
              threads.  You should not call <seealso cref="!:#close"/> until all
              threads are done using the instance.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentDocValues">
            <summary>
            Manages the <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/> held by <seealso cref="T:Lucene.Net.Index.SegmentReader"/> and
            keeps track of their reference counting.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.GetDocValuesProducer(System.Nullable{System.Int64},Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext,Lucene.Net.Store.Directory,Lucene.Net.Codecs.DocValuesFormat,System.Collections.Generic.IList{Lucene.Net.Index.FieldInfo},System.Int32)">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/> for the given generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.DecRef(System.Collections.Generic.IList{System.Nullable{System.Int64}})">
            <summary>
            Decrement the reference count of the given <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/>
            generations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RefCount`1">
            <summary>
            Manages reference counting for a given object. Extensions can override
            <seealso cref="!:#release()"/> to do custom logic when reference counting hits 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.Release">
            <summary>
            Called when reference counting hits 0. By default this method does nothing,
            but extensions can override to e.g. release resources attached to object
            that is managed by this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.DecRef">
            <summary>
            Decrements the reference counting of this object. When reference counting
            hits 0, calls <seealso cref="!:#release()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.IncRef">
            <summary>
            Increments the reference count. Calls to this method must be matched with
            calls to <seealso cref="!:#decRef()"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RefCount`1.GetRefCount">
            <summary>
            Returns the current reference count. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfo">
             <summary>
             Information about a segment such as it's name, directory, and files related
             to the segment.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.NO">
            <summary>
            Used by some member fields to mean not present (e.g.,
             norms, deletions).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.YES">
            <summary>
            Used by some member fields to mean present (e.g.,
             norms, deletions).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.Name">
            <summary>
            Unique segment name in the directory. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.Dir">
            <summary>
            Where this segment resides. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.Attributes_Renamed">
            @deprecated not used anymore
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete SegmentInfo instance from input.
            <p>Note: this is public only to allow access from
            the codecs package.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete SegmentInfo instance from input.
            <p>Note: this is public only to allow access from
            the codecs package.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.HasSeparateNorms">
            @deprecated separate norms are not supported in >= 4.0
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.ToString">
            <summary>
            Return all files referenced by this SegmentInfo. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
             <summary>
             Used for debugging.  Format may suddenly change.
            
              <p>Current format looks like
              <code>_a(3.1):c45/4</code>, which means the segment's
              name is <code>_a</code>; it was created with Lucene 3.1 (or
              '?' if it's unknown); it's using compound file
              format (would be <code>C</code> if not compound); it
              has 45 documents; it has 4 deletions (this part is
              left off when there are no deletions).</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Equals(System.Object)">
            <summary>
            We consider another SegmentInfo instance equal if it
             has the same dir and same name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Add these files to the set of files written for this
             segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFile(System.String)">
            <summary>
            Add this file to the set of files written for this
             segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or null if it does not exist
            </summary>
            @deprecated no longer supported
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfo.PutAttribute(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.SegmentInfo.Attributes">
            <summary>
            Returns the internal codec attributes map.
            </summary>
            <returns> internal codec attributes map. May be null if no mappings exist.
            </returns>
            @deprecated no longer supported
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.UseCompoundFile">
            <summary>
            Mark whether this segment is stored as a compound file.
            </summary>
            <param name="isCompoundFile"> true if this is a compound file;
            else, false </param>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Codec">
            <summary>
            Can only be called once. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.DocCount">
            <summary>
            Returns number of documents in this segment (deletions
             are not taken into account).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentInfo.Version" -->
        <member name="P:Lucene.Net.Index.SegmentInfo.Files">
            <summary>
            Sets the files written for this segment. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentInfos" -->
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_40">
            <summary>
            The file format version for the segments_N codec header, up to 4.5. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_46">
            <summary>
            The file format version for the segments_N codec header, since 4.6+. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_48">
            <summary>
            The file format version for the segments_N codec header, since 4.8+ </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SEGMENTS_GEN_CURRENT">
            <summary>
            Current format of segments.gen </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.Counter">
            <summary>
            Used to name new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos._userData">
            <summary>
            Opaque Map&lt;String, String&gt; that user can specify during IndexWriter.commit </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.SegmentInfos.infoStream" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.#ctor">
            <summary>
            Sole constructor. Typically you call this and then
             use {@link #read(Directory) or
             #read(Directory,String)} to populate each {@link
             SegmentCommitInfo}.  Alternatively, you can add/remove your
             own <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Info(System.Int32)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> at the provided
             index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(System.String[])">
            <summary>
            Get the generation of the most recent commit to the
            list of index files (N in the segments_N file).
            </summary>
            <param name="files"> -- array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(Lucene.Net.Store.Directory)">
            <summary>
            Get the generation of the most recent commit to the
            index in this directory (N in the segments_N file).
            </summary>
            <param name="directory"> -- directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(System.String[])">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit in the list of index files.
            </summary>
            <param name="files"> -- array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(Lucene.Net.Store.Directory)">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit to the index in this Directory.
            </summary>
            <param name="directory"> -- directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GenerationFromSegmentsFileName(System.String)">
            <summary>
            Parse the generation off the segments file name and
            return it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.WriteSegmentsGen(Lucene.Net.Store.Directory,System.Int64)" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Read a particular segmentFileName.  Note that this may
            throw an IOException if a commit is in process.
            </summary>
            <param name="directory"> -- directory containing the segments file </param>
            <param name="segmentFileName"> -- segment file to load </param>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)">
            <summary>
            Find the latest commit ({@code segments_N file}) and
             load all <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clone">
            <summary>
            Returns a copy of this instance, also copying each
            SegmentInfo.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Message(System.String)">
            <summary>
            Prints the given message to the infoStream. Note, this method does not
            check for null infoStream. It assumes this check has been performed by the
            caller, which is recommended to avoid the (usually) expensive message
            creation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.PrepareCommit(Lucene.Net.Store.Directory)">
             <summary>
             Call this to start a commit.  this writes the new
              segments file, but writes an invalid checksum at the
              end, so that it is not visible to readers.  Once this
              is called you must call <seealso cref="!:#finishCommit"/> to complete
              the commit or <seealso cref="!:#rollbackCommit"/> to abort it.
              <p>
              Note: <seealso cref="!:#changed()"/> should be called prior to this
              method if changes have been made to this <seealso cref="T:Lucene.Net.Index.SegmentInfos"/> instance
              </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Files(Lucene.Net.Store.Directory,System.Boolean)">
            <summary>
            Returns all file names referenced by SegmentInfo
             instances matching the provided Directory (ie files
             associated with any "external" segments are skipped).
             The returned collection is recomputed on each
             invocation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Commit(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.ToString(Lucene.Net.Store.Directory)">
            <summary>
            Returns readable description of this segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Replace(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Replaces all segments in this instance, but keeps
             generation, version, counter so that future commits
             remain write once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.TotalDocCount">
            <summary>
            Returns sum of all segment's docCounts.  Note that
             this does not include deletions
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Changed">
            <summary>
            Call this before committing if changes have been made to the
             segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ApplyMergeChanges(Lucene.Net.Index.MergePolicy.OneMerge,System.Boolean)">
            <summary>
            applies all changes caused by committing a merge to this SegmentInfos </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AsList">
            <summary>
            Returns all contained segments as an <b>unmodifiable</b> <seealso cref="!:List"/> view. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Size">
            <summary>
            Returns number of <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Add(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Appends the provided <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AddAll(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Appends the provided <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clear">
            <summary>
            Clear all <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Remove(Lucene.Net.Index.SegmentCommitInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Remove(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Contains(Lucene.Net.Index.SegmentCommitInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.IndexOf(Lucene.Net.Index.SegmentCommitInfo)" -->
        <member name="P:Lucene.Net.Index.SegmentInfos.SegmentsFileName">
            <summary>
            Get the segments_N filename in use by this segment infos.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.NextSegmentFileName">
            <summary>
            Get the next segments_N filename that will be written.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Version">
            <summary>
            Counts how often the index has been changed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Generation">
            <summary>
            Returns current generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.LastGeneration">
            <summary>
            Returns last succesfully read or written generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.InfoStream">
            <summary>
            If non-null, information about retries when loading
            the segments file will be printed to this.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.DefaultGenLookaheadCount">
             <summary>
             Advanced: set how many times to try incrementing the
             gen when loading the segments file.  this only runs if
             the primary (listing directory) and secondary (opening
             segments.gen file) methods fail to find the segments
             file.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentInfos.DefaultGenLookahedCount" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentInfos.UserData" -->
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary>
            Utility class for executing code that needs to do
            something with the current segments file.  this is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run">
            <summary>
            Locate the most recent {@code segments} file and
             run <seealso cref="!:#doBody"/> on it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run(Lucene.Net.Index.IndexCommit)">
            <summary>
            Run <seealso cref="!:#doBody"/> on the provided commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)">
            <summary>
            Subclass must implement this.  The assumption is an
            IOException will be thrown if something goes wrong
            during the processing that could have been caused by
            a writer committing.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="M:Lucene.Net.Index.SegmentMerger.ShouldMerge">
            <summary>
            True if any merging should happen </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary>
            Merges the readers into the directory passed to the constructor </summary>
            <returns> The number of documents that were merged </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            
             <returns> The number of documents in all of the readers </returns>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary>
            Merge the TermVectors from each of the segments into the new one. </summary>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentReader" -->
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a new SegmentReader with a new core. </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader)">
            <summary>
            Create new SegmentReader sharing core from a previous
             SegmentReader and loading new live docs from a new
             deletes file.  Used by openIfChanged.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader,Lucene.Net.Util.Bits,System.Int32)">
            <summary>
            Create new SegmentReader sharing core from a previous
             SegmentReader and using the provided in-memory
             liveDocs.  Used by IndexWriter to provide a new NRT
             reader
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.ReadFieldInfos(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Reads the most recent <seealso cref="P:Lucene.Net.Index.SegmentReader.FieldInfos"/> of the given segment info.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.AddCoreClosedListener(Lucene.Net.Index.SegmentReader.CoreClosedListener)">
            <summary>
            Expert: adds a CoreClosedListener to this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RemoveCoreClosedListener(Lucene.Net.Index.SegmentReader.CoreClosedListener)">
            <summary>
            Expert: removes a CoreClosedListener from this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RamBytesUsed">
            <summary>
            Returns approximate RAM Bytes used </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.FieldsReader">
            <summary>
            Expert: retrieve thread-private {@link
             StoredFieldsReader}
             @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermVectorsReader">
            <summary>
            Expert: retrieve thread-private {@link
             TermVectorsReader}
             @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentName">
            <summary>
            Return the name of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentInfo">
            <summary>
            Return the SegmentInfoPerCommit of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermInfosIndexDivisor">
            <summary>
            Returns term infos index divisor originally passed to
             <seealso cref="!:#SegmentReader(SegmentCommitInfo, int, IOContext)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader.CoreClosedListener">
             <summary>
             Called when the shared core for this SegmentReader
             is closed.
             <p>
             this listener is called only once all SegmentReaders
             sharing the same core are closed.  At this point it
             is safe for apps to evict this reader from any caches
             keyed on <seealso cref="!:#getCoreCacheKey"/>.  this is the same
             interface that <seealso cref="T:Lucene.Net.Search.IFieldCache"/> uses, internally,
             to evict entries.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.CoreClosedListener.OnClose(System.Object)">
            <summary>
            Invoked when the shared core of the original {@code
             SegmentReader} has closed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReadState">
            <summary>
            Holder class for common parameters used during read.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReadState.Directory">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentReadState.Directory"/> where this segment is read from. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReadState.SegmentInfo">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentReadState.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReadState.FieldInfos">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentReadState.FieldInfos"/> describing all fields in this
             segment.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReadState.Context">
            <summary>
            <seealso cref="T:Lucene.Net.Store.IOContext"/> to pass to {@link
             Directory#openInput(String,IOContext)}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.SegmentReadState.TermsIndexDivisor" -->
        <member name="F:Lucene.Net.Index.SegmentReadState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files read for this
             segment.  <seealso cref="T:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat"/> sets this for
             each of the postings formats it wraps.  If you create
             a new <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
             write/read must be derived using this suffix (use
             <seealso cref="!:IndexFileNames#segmentFileName(String,String,String)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32,System.String)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Index.SegmentReadState,System.String)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentWriteState">
            <summary>
            Holder class for common parameters used during write.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.InfoStream">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentWriteState.InfoStream"/> used for debugging messages. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.Directory">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentWriteState.Directory"/> where this segment will be written
             to.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.SegmentInfo">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentWriteState.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.FieldInfos">
            <summary>
            <seealso cref="F:Lucene.Net.Index.SegmentWriteState.FieldInfos"/> describing all fields in this
             segment.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.DelCountOnFlush">
            <summary>
            Number of deleted documents set while flushing the
             segment.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.SegUpdates">
            <summary>
            Deletes and updates to apply while we are flushing the segment. A Term is
            enrolled in here if it was deleted/updated at one point, and it's mapped to
            the docIDUpto, meaning any docID &lt; docIDUpto containing this term should
            be deleted/updated.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.LiveDocs">
            <summary>
            <seealso cref="T:Lucene.Net.Util.MutableBits"/> recording live documents; this is
             only set if there is one or more deleted documents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files written for this
             segment.  <seealso cref="T:Lucene.Net.Codecs.Perfield.PerFieldPostingsFormat"/> sets this for
             each of the postings formats it wraps.  If you create
             a new <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
             write/read must be derived using this suffix (use
             <seealso cref="!:IndexFileNames#segmentFileName(String,String,String)"/>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.TermIndexInterval">
            <summary>
            Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentWriteState.Context">
            <summary>
            <seealso cref="T:Lucene.Net.Store.IOContext"/> for all writes; you should pass this
             to <seealso cref="!:Directory#createOutput(String,IOContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext,System.String)" -->
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Index.SegmentWriteState,System.String)">
            <summary>
            Create a shallow copy of <seealso cref="T:Lucene.Net.Index.SegmentWriteState"/> with a new segment suffix. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SerialMergeScheduler">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> that simply does each merge
             sequentially, using the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Just do the merges in sequence. We do this
            "synchronized" so that even if the application is using
            multiple threads, only one merge may run at a time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SimpleMergedSegmentWarmer">
            <summary>
            A very simple merged segment warmer that just ensures
            data structures are initialized.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SimpleMergedSegmentWarmer.#ctor(Lucene.Net.Util.InfoStream)">
            <summary>
            Creates a new SimpleMergedSegmentWarmer </summary>
            <param name="infoStream"> InfoStream to log statistics about warming. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SingleTermsEnum" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SingleTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SingletonSortedSetDocValues" -->
        <member name="M:Lucene.Net.Index.SingletonSortedSetDocValues.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a multi-valued view over the provided SortedDocValues </summary>
        </member>
        <member name="P:Lucene.Net.Index.SingletonSortedSetDocValues.SortedDocValues">
            <summary>
            Return the wrapped <seealso cref="P:Lucene.Net.Index.SingletonSortedSetDocValues.SortedDocValues"/> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SlowCompositeReaderWrapper" -->
        <member name="M:Lucene.Net.Index.SlowCompositeReaderWrapper.Wrap(Lucene.Net.Index.IndexReader)">
            <summary>
            this method is sugar for getting an <seealso cref="T:Lucene.Net.Index.AtomicReader"/> from
            an <seealso cref="T:Lucene.Net.Index.IndexReader"/> of any kind. If the reader is already atomic,
            it is returned unchanged, otherwise wrapped by this class.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesTermsEnum">
            <summary>
            Implements a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <seealso cref="T:Lucene.Net.Index.SortedDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a new TermsEnum over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesWriter">
            <summary>
            Buffers up pending byte[] per doc, deref and sorting via
             int ord, then flushes when segment flushes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesTermsEnum">
            <summary>
            Implements a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Creates a new TermsEnum over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesWriter">
            <summary>
            Buffers up pending byte[]s per doc, deref and sorting via
             int ord, then flushes when segment flushes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Int32,System.Boolean)">
            <summary>
            called only from static open() methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            called from DirectoryReader.open(...) methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>
            Used by near real-time search </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Collections.Generic.IList{Lucene.Net.Index.AtomicReader},System.Int32)">
            <summary>
            this constructor is only used for <seealso cref="!:#doOpenIfChanged(SegmentInfos)"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldsProcessor">
            <summary>
            this is a StoredFieldsConsumer that writes stored fields. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldsProcessor.Fill(System.Int32)">
            <summary>
            Fills in any hole in the docIDs </summary>
        </member>
        <member name="T:Lucene.Net.Index.Term">
             <summary>
              A Term represents a word from text.  this is the unit of search.  It is
              composed of two elements, the text of the word, as a string, and the name of
              the field that the text occurred in.
            
              Note that terms may represent more than words from text fields, but also
              things like dates, email addresses, urls, etc.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String)">
            <summary>
            Constructs a Term with the given field and empty text.
            this serves two purposes: 1) reuse of a Term with the same field.
            2) pattern for a query.
            </summary>
            <param name="fld"> field's name </param>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>
            Returns the text of this term.  In the case of words, this is simply the
             text of the word.  In the case of dates and other types, this is an
             encoding of the object as a string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.ToString(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns human-readable form of the term text. If the term is not unicode,
            the raw bytes will be printed instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
             <summary>
             Compares two terms, returning a negative integer if this
              term belongs before the argument, zero if this term is equal to the
              argument, and a positive integer if this term belongs after the argument.
            
              The ordering of terms is first by field, then by text.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.Set(System.String,Lucene.Net.Util.BytesRef)" -->
        <member name="P:Lucene.Net.Index.Term.Field">
            <summary>
            Returns the field of this term.   The field indicates
             the part of a document which this term came from.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Term.Bytes">
            <summary>
            Returns the bytes of this term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermContext">
             <summary>
             Maintains a <seealso cref="T:Lucene.Net.Index.IndexReader"/> <seealso cref="T:Lucene.Net.Index.TermState"/> view over
             <seealso cref="T:Lucene.Net.Index.IndexReader"/> instances containing a single term. The
             <seealso cref="T:Lucene.Net.Index.TermContext"/> doesn't track if the given <seealso cref="T:Lucene.Net.Index.TermState"/>
             objects are valid, neither if the <seealso cref="T:Lucene.Net.Index.TermState"/> instances refer to the
             same terms in the associated readers.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermContext.TopReaderContext">
             <summary>
             Holds the <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/> of the top-level
              <seealso cref="T:Lucene.Net.Index.IndexReader"/>, used internally only for
              asserting.
            
              @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Creates an empty <seealso cref="T:Lucene.Net.Index.TermContext"/> from a <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.TermContext"/> with an initial <seealso cref="T:Lucene.Net.Index.TermState"/>,
            <seealso cref="T:Lucene.Net.Index.IndexReader"/> pair.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermContext.Build(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.TermContext.Clear">
            <summary>
            Clears the <seealso cref="T:Lucene.Net.Index.TermContext"/> internal state and removes all
            registered <seealso cref="T:Lucene.Net.Index.TermState"/>s
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Register(Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Registers and associates a <seealso cref="T:Lucene.Net.Index.TermState"/> with an leaf ordinal. The leaf ordinal
            should be derived from a <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>'s leaf ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Get(System.Int32)">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Index.TermState"/> for an leaf ordinal or <code>null</code> if no
            <seealso cref="T:Lucene.Net.Index.TermState"/> for the ordinal was registered.
            </summary>
            <param name="ord">
                     the readers leaf ordinal to get the <seealso cref="T:Lucene.Net.Index.TermState"/> for. </param>
            <returns> the <seealso cref="T:Lucene.Net.Index.TermState"/> for the given readers ord or <code>null</code> if no
                    <seealso cref="T:Lucene.Net.Index.TermState"/> for the reader was registered </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.TotalTermFreq">
            <summary>
             Returns the accumulated term frequency of all <seealso cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <seealso cref="!:#register(TermState, int, int, long)"/>. </summary>
            <returns> the accumulated term frequency of all <seealso cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <seealso cref="!:#register(TermState, int, int, long)"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.DocFreq">
            <summary>
            expert: only available for queries that want to lie about docfreq
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsHash">
            <summary>
            this class implements <seealso cref="T:Lucene.Net.Index.InvertedDocConsumer"/>, which
             is passed each token produced by the analyzer on each
             field.  It stores these tokens in a hash table, and
             allocates separate byte streams per token.  Consumers of
             this class, eg <seealso cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and {@link
             TermVectorsConsumer}, write their own byte streams
             under each term.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsHashPerField.SortPostings(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})" -->
        <member name="T:Lucene.Net.Util.BytesRefHash.BytesStartArray">
            <summary>
            Manages allocation of the per-term addresses. </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash">
             <summary>
             <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> is a special purpose hash-map like data-structure
             optimized for <seealso cref="T:Lucene.Net.Util.BytesRef"/> instances. BytesRefHash maintains mappings of
             byte arrays to ids (Map&lt;BytesRef,int&gt;) storing the hashed bytes
             efficiently in continuous storage. The mapping to the id is
             encapsulated inside <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> and is guaranteed to be increased
             for each added <seealso cref="T:Lucene.Net.Util.BytesRef"/>.
            
             <p>
             Note: The maximum capacity <seealso cref="T:Lucene.Net.Util.BytesRef"/> instance passed to
             <seealso cref="!:#add(BytesRef)"/> must not be longer than <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>-2.
             The internal storage is limited to 2GB total byte storage.
             </p>
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> with a <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> using a
            <seealso cref="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool,System.Int32,Lucene.Net.Util.BytesRefHash.BytesStartArray)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Size">
            <summary>
            Returns the number of <seealso cref="T:Lucene.Net.Util.BytesRef"/> values in this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>.
            </summary>
            <returns> the number of <seealso cref="T:Lucene.Net.Util.BytesRef"/> values in this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRefHash.Get(System.Int32,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.BytesRefHash.Compact">
            <summary>
            Returns the ids array in arbitrary order. Valid ids start at offset of 0
            and end at a limit of <seealso cref="!:#size()"/> - 1
            <p>
            Note: this is a destructive operation. <seealso cref="!:#clear()"/> must be called in
            order to reuse this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Sort(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns the values array sorted by the referenced byte values.
            <p>
            Note: this is a destructive operation. <seealso cref="!:#clear()"/> must be called in
            order to reuse this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </p>
            </summary>
            <param name="comp">
                     the <seealso cref="!:Comparator"/> used for sorting </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Clear(System.Boolean)">
            <summary>
            Clears the <seealso cref="T:Lucene.Net.Util.BytesRef"/> which maps to the given <seealso cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Close">
            <summary>
            Closes the BytesRefHash and releases all internally used memory
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Add(Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <seealso cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
            <param name="bytes">
                     the bytes to hash </param>
            <returns> the id the given bytes are hashed if there was no mapping for the
                    given bytes, otherwise <code>(-(id)-1)</code>. this guarantees
                    that the return value will always be &gt;= 0 if the given bytes
                    haven't been hashed before.
            </returns>
            <exception cref="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
                      if the given bytes are &gt; 2 +
                      <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/> </exception>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Find(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the id of the given <seealso cref="T:Lucene.Net.Util.BytesRef"/>.
            </summary>
            <param name="bytes">
                     the bytes to look for
            </param>
            <returns> the id of the given bytes, or {@code -1} if there is no mapping for the
                    given bytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.AddByPoolOffset(System.Int32)">
            <summary>
            Adds a "arbitrary" int offset instead of a BytesRef
             term.  this is used in the indexer to hold the hash for term
             vectors, because they do not redundantly store the byte[] term
             directly and instead reference the byte[] term
             already stored by the postings BytesRefHash.  See
             add(int textStart) in TermsHashPerField.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRefHash.Rehash(System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Util.BytesRefHash.Reinit">
            <summary>
            reinitializes the <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> after a previous <seealso cref="!:#clear()"/>
            call. If <seealso cref="!:#clear()"/> has not been called previously this method has no
            effect.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.ByteStart(System.Int32)">
            <summary>
            Returns the bytesStart offset into the internally used
            <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given bytesID
            </summary>
            <param name="bytesID">
                     the id to look up </param>
            <returns> the bytesStart offset into the internally used
                    <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given id </returns>
        </member>
        <member name="T:Lucene.Net.Util.IntroSorter">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Sorter"/> implementation based on a variant of the quicksort algorithm
            called <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>: when
            the recursion level exceeds the log of the length of the array to sort, it
            falls back to heapsort. this prevents quicksort from running into its
            worst-case quadratic runtime. Small arrays are sorted with
            insertion sort.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.#ctor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.IntroSorter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.ComparePivot(System.Int32)">
            <summary>
            Compare the pivot with the slot at <code>j</code>, similarly to
             <seealso cref="!:#compare(int, int) compare(i, j)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.IntroSorter.Pivot">
            <summary>
            Save the value at slot <code>i</code> so that it can later be used as a
            pivot, see <seealso cref="!:#comparePivot(int)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
            <summary>
            Thrown if a <seealso cref="T:Lucene.Net.Util.BytesRef"/> exceeds the <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> limit of
            <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>-2.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.BytesStartArray">
            <summary>
            Manages allocation of the per-term addresses. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Init">
            <summary>
            Initializes the BytesStartArray. this call will allocate memory
            </summary>
            <returns> the initialized bytes start array </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Grow">
            <summary>
            Grows the <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>
            </summary>
            <returns> the grown array </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Clear">
            <summary>
            clears the <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> and returns the cleared instance.
            </summary>
            <returns> the cleared instance, this might be <code>null</code> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.BytesUsed">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Counter"/> reference holding the number of bytes used by this
            <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. The <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> uses this reference to
            track it memory usage
            </summary>
            <returns> a <seealso cref="T:Lucene.Net.Support.AtomicLong"/> reference holding the number of bytes used
                    by this <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. </returns>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.DirectBytesStartArray">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> that tracks
             memory allocation using a private <seealso cref="T:Lucene.Net.Util.Counter"/>
             instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumer.Fill(System.Int32)">
            <summary>
            Fills in no-term-vectors for all docs we haven't seen
             since the last doc that had term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumerPerField.Finish">
            <summary>
            Called once per field per document if term vectors
             are enabled, to write the vectors to
             RAMOutputStream, which is then quickly flushed to
             the real term vectors files in the Directory. 	  /// </summary>
        </member>
        <member name="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation that tries to assign an
            indexing thread to the same <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> each time the thread tries to
            obtain a <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Once a new <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is created it is
            associated with the creating thread. Subsequently, if the threads associated
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is not in use it will be associated with the requesting
            thread. Otherwise, if the <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is used by another thread
            <seealso cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> tries to find the currently
            minimal contended <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> with a given maximum of <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TieredMergePolicy" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.TieredMergePolicy.DEFAULT_NO_CFS_RATIO" -->
        <member name="M:Lucene.Net.Index.TieredMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
             defaults.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetMaxMergeAtOnce(System.Int32)">
            <summary>
            Maximum number of segments to be merged at a time
             during "normal" merging.  For explicit merging (eg,
             forceMerge or forceMergeDeletes was called), see {@link
             #setMaxMergeAtOnceExplicit}.  Default is 10.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetMaxMergeAtOnceExplicit(System.Int32)">
            <summary>
            Maximum number of segments to be merged at a time,
             during forceMerge or forceMergeDeletes. Default is 30.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetMaxMergedSegmentMB(System.Double)">
            <summary>
            Maximum sized segment to produce during
             normal merging.  this setting is approximate: the
             estimate of the merged segment size is made by summing
             sizes of to-be-merged segments (compensating for
             percent deleted docs).  Default is 5 GB.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetReclaimDeletesWeight(System.Double)">
            <summary>
            Controls how aggressively merges that reclaim more
             deletions are favored.  Higher values will more
             aggressively target merges that reclaim deletions, but
             be careful not to go so high that way too much merging
             takes place; a value of 3.0 is probably nearly too
             high.  A value of 0.0 means deletions don't impact
             merge selection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetFloorSegmentMB(System.Double)">
            <summary>
            Segments smaller than this are "rounded up" to this
             size, ie treated as equal (floor) size for merge
             selection.  this is to prevent frequent flushing of
             tiny segments from allowing a long tail in the index.
             Default is 2 MB.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetForceMergeDeletesPctAllowed(System.Double)">
            <summary>
            When forceMergeDeletes is called, we only merge away a
             segment if its delete percentage is over this
             threshold.  Default is 10%.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.SetSegmentsPerTier(System.Double)">
             <summary>
             Sets the allowed number of segments per tier.  Smaller
              values mean more merging but fewer segments.
            
              <p><b>NOTE</b>: this value should be >= the {@link
              #setMaxMergeAtOnce} otherwise you'll force too much
              merging to occur.</p>
            
              <p>Default is 10.0.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.Score(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo},System.Boolean,System.Int64)">
            <summary>
            Expert: scores one merge; subclasses can override. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnceExplicit" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.MaxMergedSegmentMB" -->
        <member name="P:Lucene.Net.Index.TieredMergePolicy.ReclaimDeletesWeight">
            <summary>
            See <seealso cref="!:#setReclaimDeletesWeight"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.FloorSegmentMB" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.ForceMergeDeletesPctAllowed" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TieredMergePolicy.SegmentsPerTier" -->
        <member name="T:Lucene.Net.Index.TieredMergePolicy.MergeScore">
            <summary>
            Holds score and explanation for a single candidate
             merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.MergeScore.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Score">
            <summary>
            Returns the score for this merge candidate; lower
             scores are better.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Explanation">
            <summary>
            Human readable explanation of how the merge got this
             score.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TrackingIndexWriter">
             <summary>
             Class that tracks changes to a delegated
              IndexWriter, used by {@link
              ControlledRealTimeReopenThread} to ensure specific
              changes are visible.   Create this class (passing your
              IndexWriter), and then pass this class to {@link
              ControlledRealTimeReopenThread}.
              Be sure to make all changes via the
              TrackingIndexWriter, otherwise {@link
              ControlledRealTimeReopenThread} won't know about the changes.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.#ctor(Lucene.Net.Index.IndexWriter)">
            <summary>
            Create a {@code TrackingIndexWriter} wrapping the
             provided <seealso cref="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#updateDocument(Term,Iterable,Analyzer)}
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField})">
            <summary>
            Calls {@link
             IndexWriter#updateDocument(Term,Iterable)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#updateDocuments(Term,Iterable,Analyzer)}
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}})">
            <summary>
            Calls {@link
             IndexWriter#updateDocuments(Term,Iterable)} and returns
             the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Term)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Term...)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Query)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Query...)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteAll">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteAll"/> and returns the
             generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#addDocument(Iterable,Analyzer)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#addDocuments(Iterable,Analyzer)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField})">
            <summary>
            Calls <seealso cref="!:IndexWriter#addDocument(Iterable)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IndexableField}})">
            <summary>
            Calls <seealso cref="!:IndexWriter#addDocuments(Iterable)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#addIndexes(Directory...)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#addIndexes(IndexReader...)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>
            Cals {@link
             IndexWriter#tryDeleteDocument(IndexReader,int)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.Generation">
            <summary>
            Return the current generation being indexed. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter">
            <summary>
            Return the wrapped <seealso cref="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.AndIncrementGeneration">
             <summary>
             Return and increment current gen.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TwoPhaseCommitTool" -->
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.Rollback(Lucene.Net.Index.TwoPhaseCommit[])">
            <summary>
            rollback all objects, discarding any exceptions that occur. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TwoPhaseCommitTool.Execute(Lucene.Net.Index.TwoPhaseCommit[])" -->
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException">
            <summary>
            Thrown by <seealso cref="!:TwoPhaseCommitTool#execute(TwoPhaseCommit...)"/> when an
            object fails to prepareCommit().
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException.#ctor(System.Exception,Lucene.Net.Index.TwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException">
            <summary>
            Thrown by <seealso cref="!:TwoPhaseCommitTool#execute(TwoPhaseCommit...)"/> when an
            object fails to commit().
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException.#ctor(System.Exception,Lucene.Net.Index.TwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoStoredFieldsConsumers">
            <summary>
            Just switches between two <seealso cref="T:Lucene.Net.Index.DocFieldConsumer"/>s. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.UpgradeIndexMergePolicy" -->
        <member name="F:Lucene.Net.Index.UpgradeIndexMergePolicy.base">
            <summary>
            Wrapped <seealso cref="T:Lucene.Net.Index.MergePolicy"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.#ctor(Lucene.Net.Index.MergePolicy)">
            <summary>
            Wrap the given <seealso cref="T:Lucene.Net.Index.MergePolicy"/> and intercept forceMerge requests to
            only upgrade segments written with previous Lucene versions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.ShouldUpgradeSegment(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns if the given segment should be upgraded. The default implementation
            will return {@code !Constants.LUCENE_MAIN_VERSION.equals(si.getVersion())},
            so all segments created with a different version number than this Lucene version will
            get upgraded.
            </summary>
        </member>
        <member name="T:Lucene.Net.LucenePackage">
            <summary>
            Lucene's package information, including version. * </summary>
        </member>
        <member name="T:Simplicit.Net.Lzo.LZOCompressor">
            <summary>
            Wrapper class for the highly performant LZO compression library
            </summary>
        </member>
        <member name="M:Simplicit.Net.Lzo.LZOCompressor.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Simplicit.Net.Lzo.LZOCompressor.Compress(System.Byte[])">
            <summary>
            Compresses a byte array and returns the compressed data in a new
            array. You need the original length of the array to decompress it.
            </summary>
            <param name="src">Source array for compression</param>
            <returns>Byte array containing the compressed data</returns>
        </member>
        <member name="M:Simplicit.Net.Lzo.LZOCompressor.Decompress(System.Byte[])">
            <summary>
            Decompresses compressed data to its original state.
            </summary>
            <param name="src">Source array to be decompressed</param>
            <returns>Decompressed data</returns>
        </member>
        <member name="P:Simplicit.Net.Lzo.LZOCompressor.Version">
            <summary>
            Version string of the compression library.
            </summary>
        </member>
        <member name="P:Simplicit.Net.Lzo.LZOCompressor.VersionDate">
            <summary>
            Version date of the compression library
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.AutomatonQuery">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Query"/> that will match terms against a finite-state machine.
            <p>
            this query will match documents that contain terms accepted by a given
            finite-state machine. The automaton can be constructed with the
            <seealso cref="N:Lucene.Net.Util.Automaton"/> API. Alternatively, it can be
            created from a regular expression with <seealso cref="T:Lucene.Net.Search.RegexpQuery"/> or from
            the standard Lucene wildcard syntax with <seealso cref="T:Lucene.Net.Search.WildcardQuery"/>.
            </p>
            <p>
            When the query is executed, it will create an equivalent DFA of the
            finite-state machine, and will enumerate the term dictionary in an
            intelligent way to reduce the number of comparisons. For example: the regular
            expression of <code>[dl]og?</code> will make approximately four comparisons:
            do, dog, lo, and log.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="M:Lucene.Net.Search.Query.ToString(System.String)">
            <summary>
            Prints a query to a string, with <code>field</code> assumed to be the
            default field and omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>
            Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.IndexSearcher)" -->
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: called to re-write queries into primitive queries. For example,
            a PrefixQuery will be rewritten into a BooleanQuery that consists
            of TermQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its <seealso cref="!:#rewrite rewritten"/> form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>
            Returns a clone of this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Query.Boost">
            <summary>
            Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE" -->
        <member name="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT">
            <summary>
            Read-only default instance of {@link
             ConstantScoreAutoRewrite}, with {@link
             ConstantScoreAutoRewrite#setTermCountCutoff} set to
             {@link
             ConstantScoreAutoRewrite#DEFAULT_TERM_COUNT_CUTOFF}
             and {@link
             ConstantScoreAutoRewrite#setDocCountPercent} set to
             {@link
             ConstantScoreAutoRewrite#DEFAULT_DOC_COUNT_PERCENT}.
             Note that you cannot alter the configuration of this
             instance; you'll need to create a private instance
             instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(System.String)">
            <summary>
            Constructs a query matching terms that cannot be represented with a single
            Term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)">
            <summary>
            Construct the enumeration to be used, expanding the
             pattern term.  this method should only be called if
             the field exists (ie, implementations can assume the
             field does exist).  this method should not return null
             (should instead return <seealso cref="!:TermsEnum#EMPTY"/> if no
             terms match).  The TermsEnum must already be
             positioned to the first matching term.
            The given <seealso cref="T:Lucene.Net.Util.AttributeSource"/> is passed by the <seealso cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/> to
            provide attributes, the rewrite method uses to inform about e.g. maximum competitive boosts.
            this is currently only used by <seealso cref="!:TopTermsRewrite"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms)">
            <summary>
            Convenience method, if no attributes are needed:
            this simply passes empty attributes and is equal to:
            <code>getTermsEnum(terms, new AttributeSource())</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            To rewrite to a simpler form, instead return a simpler
            enum from <seealso cref="!:#getTermsEnum(Terms, AttributeSource)"/>.  For example,
            to rewrite to a single term, return a <seealso cref="T:Lucene.Net.Index.SingleTermsEnum"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQuery.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.RewriteMethod.GetTermsEnum(Lucene.Net.Search.MultiTermQuery,Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite" -->
        <member name="T:Lucene.Net.Search.TopTermsRewrite`1">
            <summary>
            Base rewrite method for collecting only the top terms
            via a priority queue.
            @lucene.internal Only public to be accessible by spans package.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.AddClause(`0,Lucene.Net.Index.Term,System.Int32,System.Single)">
            <summary>
            Add a MultiTermQuery term to the top-level query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermCollectingRewrite`1.TopLevelQuery">
            <summary>
            Return a suitable top-level Query for holding all expanded terms. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Attributes">
            <summary>
            attributes used for communication with the enum </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Collect(Lucene.Net.Util.BytesRef)">
            <summary>
            return false to stop collecting </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.NextEnum">
            <summary>
            the next segment's <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that is used to collect terms </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopTermsRewrite`1.#ctor(System.Int32)" -->
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.Size">
            <summary>
            return the maximum priority queue size </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.MaxSize">
            <summary>
            return the maximum size of the priority queue (for boolean rewrites this is BooleanQuery#getMaxClauseCount). </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite.#ctor(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite.#ctor(System.Int32)" -->
        <member name="T:Lucene.Net.Search.MultiTermQuery.ConstantScoreAutoRewrite">
            <summary>
            A rewrite method that tries to pick the best
             constant-score rewrite method based on term and
             document counts from the query.  If both the number of
             terms and documents is small enough, then {@link
             #CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE} is used.
             Otherwise, <seealso cref="!:#CONSTANT_SCORE_FILTER_REWRITE"/> is
             used.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.TermCountCutoff">
            <summary>
            If the number of terms in this query is equal to or
             larger than this setting then {@link
             MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE} is used.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.DocCountPercent">
            <summary>
            If the number of documents to be visited in the
             postings exceeds this specified percentage of the
             maxDoc() for the index, then {@link
             MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE} is used. </summary>
             <param name="percent"> 0.0 to 100.0  </param>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreAutoRewrite.TermStateByteStart">
            <summary>
            Special implementation of BytesStartArray that keeps parallel arrays for <seealso cref="T:Lucene.Net.Index.TermContext"/> </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.Automaton_Renamed">
            <summary>
            the automaton to match index terms against </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.Term">
            <summary>
            term containing the field, and possibly some pattern structure </summary>
        </member>
        <member name="M:Lucene.Net.Search.AutomatonQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Create a new AutomatonQuery from an <seealso cref="P:Lucene.Net.Search.AutomatonQuery.Automaton"/>.
            </summary>
            <param name="term"> Term containing field and possibly some pattern structure. The
                   term text is ignored. </param>
            <param name="automaton"> Automaton to run, terms that are accepted are considered a
                   match. </param>
        </member>
        <member name="P:Lucene.Net.Search.AutomatonQuery.Automaton">
            <summary>
            Returns the automaton used to create this query </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BitsFilteredDocIdSet" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredDocIdSet" -->
        <member name="T:Lucene.Net.Search.DocIdSet">
            <summary>
            A DocIdSet contains a set of doc ids. Implementing classes must
            only implement <seealso cref="!:#iterator"/> to provide access to the set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.GetIterator">
            <summary>
            Provides a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access the set.
            this implementation can return <code>null</code> if there
            are no docs that match.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.GetBits">
            <summary>
            Optionally provides a <seealso cref="M:Lucene.Net.Search.DocIdSet.GetBits"/> interface for random access
            to matching documents. </summary>
            <returns> {@code null}, if this {@code DocIdSet} does not support random access.
            In contrast to <seealso cref="!:#iterator()"/>, a return value of {@code null}
            <b>does not</b> imply that no documents match the filter!
            The default implementation does not provide random access, so you
            only need to implement this method if your DocIdSet can
            guarantee random access to every docid in O(1) time without
            external disk access (as <seealso cref="M:Lucene.Net.Search.DocIdSet.GetBits"/> interface cannot throw
            <seealso cref="!:IOException"/>). this is generally true for bit sets
            like <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>, which return
            itself if they are used as {@code DocIdSet}. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSet.Cacheable">
            <summary>
            this method is a hint for <seealso cref="T:Lucene.Net.Search.CachingWrapperFilter"/>, if this <code>DocIdSet</code>
            should be cached without copying it. The default is to return
            <code>false</code>. If you have an own <code>DocIdSet</code> implementation
            that does its iteration very effective and fast without doing disk I/O,
            override this method and return <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying DocIdSet </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.Match(System.Int32)">
            <summary>
            Validation method to determine whether a docid should be in the result set. </summary>
            <param name="docid"> docid to be tested </param>
            <returns> true if input docid should be in the result set, false otherwise. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredDocIdSet.GetIterator" -->
        <member name="P:Lucene.Net.Search.FilteredDocIdSet.Cacheable">
            <summary>
            this DocIdSet implementation is cacheable if the inner set is cacheable. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredDocIdSetIterator">
            <summary>
            Abstract decorator class of a DocIdSetIterator
            implementation that provides on-demand filter/validation
            mechanism on an underlying DocIdSetIterator.  See {@link
            FilteredDocIdSet}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSetIterator.#ctor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Constructor. </summary>
            <param name="innerIter"> Underlying DocIdSetIterator. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredDocIdSetIterator.Match(System.Int32)" -->
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.Wrap(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.Bits)">
            <summary>
            Convenience wrapper method: If {@code acceptDocs == null} it returns the original set without wrapping. </summary>
            <param name="set"> Underlying DocIdSet. If {@code null}, this method returns {@code null} </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this DocIdSet.
            If {@code null}, this method returns the original set without wrapping. </param>
        </member>
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.Bits)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying DocIdSet </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this DocIdSet </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>
            A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>
            The query whose matching documents are combined by the boolean query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>
            Constructs a BooleanClause.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause.Occur">
            <summary>
            Specifies how clauses are to occur in matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST">
            <summary>
            Use this operator for clauses that <i>must</i> appear in the matching documents.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.BooleanClause.Occur.SHOULD" -->
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST_NOT">
            <summary>
            Use this operator for clauses that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <code>MUST_NOT</code> clause.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>
            A Query that matches documents matching boolean combinations of other
            queries, e.g. <seealso cref="T:Lucene.Net.Search.TermQuery"/>s, <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>s or other
            BooleanQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>
            Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
             <summary>
             Constructs an empty boolean query.
            
             <seealso cref="!:Similarity#coord(int,int)"/> may be disabled in scoring, as
             appropriate. For example, this score factor does not make sense for most
             automatically generated queries, like <seealso cref="T:Lucene.Net.Search.WildcardQuery"/> and {@link
             FuzzyQuery}.
             </summary>
             <param name="disableCoord"> disables <seealso cref="!:Similarity#coord(int,int)"/> in scoring. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>
            Returns the list of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetEnumerator">
            <summary>
            Returns an iterator on the clauses in this query. It implements the <seealso cref="!:Iterable"/> interface to
            make it possible to do:
            <pre class="prettyprint">for (BooleanClause clause : booleanQuery) {}</pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.BooleanQuery.MaxClauseCount" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.BooleanQuery.CoordDisabled" -->
        <member name="P:Lucene.Net.Search.BooleanQuery.MinimumNumberShouldMatch">
             <summary>
             Specifies a minimum number of the optional BooleanClauses
             which must be satisfied.
            
             <p>
             By default no optional clauses are necessary for a match
             (unless there are no required clauses).  If this method is used,
             then the specified number of clauses is required.
             </p>
             <p>
             Use of this method is totally independent of specifying that
             any specific clauses are required (or prohibited).  this number will
             only be compared against the number of matching optional clauses.
             </p>
             </summary>
             <param name="min"> the number of optional clauses that must match </param>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.Clauses">
            <summary>
            Returns the set of clauses in this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClauses">
            <summary>
            Thrown when an attempt is made to add more than {@link
            #getMaxClauseCount()} clauses. this typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery
            is expanded to many terms during search.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.BooleanWeight">
             <summary>
             Expert: the Weight for BooleanQuery, used to
             normalize, score and explain these queries.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            An explanation of the score computation for the named document.
            </summary>
            <param name="context"> the readers context to create the <seealso cref="T:Lucene.Net.Search.Explanation"/> for. </param>
            <param name="doc"> the document's id relative to the given context's reader </param>
            <returns> an Explanation for the score </returns>
            <exception cref="T:System.IO.IOException"> if an <seealso cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single,System.Single)">
            <summary>
            Assigns the query normalization factor and boost from parent queries to this. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)" -->
        <member name="M:Lucene.Net.Search.Weight.BulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.Bits)">
            <summary>
            Optional method, to return a <seealso cref="M:Lucene.Net.Search.Weight.BulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.Bits)"/> to
            score the query and send hits to a <seealso cref="T:Lucene.Net.Search.Collector"/>.
            Only queries that have a different top-level approach
            need to override this; the default implementation
            pulls a normal <seealso cref="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)"/> and iterates and
            collects the resulting hits.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)"/>. </param>
            <param name="scoreDocsInOrder">
                     specifies whether in-order scoring of documents is required. Note
                     that if set to false (i.e., out-of-order scoring is required),
                     this method can return whatever scoring mode it supports, as every
                     in-order scorer is also an out-of-order one. However, an
                     out-of-order scorer may not support <seealso cref="!:Scorer#nextDoc()"/>
                     and/or <seealso cref="!:Scorer#advance(int)"/>, therefore it is recommended to
                     request an in-order scorer if use of these
                     methods is required. </param>
            <param name="acceptDocs">
                     Bits that represent the allowable docs to match (typically deleted docs
                     but possibly filtering other documents)
            </param>
            <returns> a <seealso cref="M:Lucene.Net.Search.Weight.BulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.Bits)"/> which scores documents and
            passes them to a collector. </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Weight.ScoresDocsOutOfOrder" -->
        <member name="P:Lucene.Net.Search.Weight.Query">
            <summary>
            The query that this concerns. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Weight.ValueForNormalization">
            <summary>
            The value for normalization of contained query clauses (e.g. sum of squared weights). </summary>
        </member>
        <member name="T:Lucene.Net.Search.Weight.DefaultBulkScorer">
            <summary>
            Just wraps a Scorer and performs top scoring using it. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BulkScorer">
            <summary>
            this class is used to score a range of documents at
             once, and is returned by <seealso cref="!:Weight#bulkScorer"/>.  Only
             queries that have a more optimized means of scoring
             across a range of documents need to override this.
             Otherwise, a default implementation is wrapped around
             the <seealso cref="T:Lucene.Net.Search.Scorer"/> returned by <seealso cref="!:Weight#scorer"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.Collector)">
            <summary>
            Scores and collects all matching documents. </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.Collector,System.Int32)">
            <summary>
            Collects matching documents in a range.
            </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
            <param name="max"> Score up to, but not including, this doc </param>
            <returns> true if more matching documents may remain. </returns>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.BooleanWeight.similarity">
            <summary>
            The Similarity implementation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Collector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Collector.Collect(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Collector.AcceptsDocsOutOfOrder" -->
        <member name="P:Lucene.Net.Search.Collector.Scorer">
            <summary>
            Called before successive calls to <seealso cref="!:#collect(int)"/>. Implementations
            that need the score of the current document (passed-in to
            <seealso cref="!:#collect(int)"/>), should save the passed-in Scorer and call
            scorer.score() when needed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Collector.NextReader">
             <summary>
             Called before collecting from each <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All doc ids in
             <seealso cref="!:#collect(int)"/> will correspond to <seealso cref="!:IndexReaderContext#reader"/>.
            
             Add <seealso cref="!:AtomicReaderContext#docBase"/> to the current  <seealso cref="!:IndexReaderContext#reader"/>'s
             internal document id to re-base ids in <seealso cref="!:#collect(int)"/>.
             </summary>
             <param name="context">
                      next atomic reader context </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>
            A simple hash table of document scores within a range. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BooleanScorer2" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Scorer" -->
        <member name="F:Lucene.Net.Search.Scorer.weight">
            <summary>
            the Scorer's parent Weight. in some cases this may be null </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Weight)">
            <summary>
            Constructs a Scorer </summary>
            <param name="weight"> The scorers <code>Weight</code>. </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> or <seealso cref="!:#advance(int)"/>
            is called the first time, or when called from within
            <seealso cref="!:Collector#collect"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.Weight">
            <summary>
            returns parent Weight
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.Children">
            <summary>
            Returns child sub-scorers
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer.ChildScorer">
            <summary>
            A child Scorer and its relationship to its parent.
            the meaning of the relationship depends upon the parent query.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Scorer.ChildScorer.Child">
            <summary>
            Child Scorer. (note this is typically a direct child, and may
            itself also have children).
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Scorer.ChildScorer.Relationship">
            <summary>
            An arbitrary string relating this scorer to the parent.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.ChildScorer.#ctor(Lucene.Net.Search.Scorer,System.String)" -->
        <member name="F:Lucene.Net.Search.BooleanScorer2.CountingSumScorer">
            <summary>
            The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.MinNrShouldMatch">
            <summary>
            The number of optionalScorers that need to match (if there are any) </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.BooleanQuery.BooleanWeight,System.Boolean,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Search.Scorer"/> with the given similarity and lists of required,
            prohibited and optional scorers. In no required scorers are added, at least
            one of the optional scorers will have to match during the search.
            </summary>
            <param name="weight">
                     The BooleanWeight to be used. </param>
            <param name="disableCoord">
                     If this parameter is true, coordination level matching
                     (<seealso cref="!:Similarity#coord(int, int)"/>) is not used. </param>
            <param name="minNrShouldMatch">
                     The minimum number of optional added scorers that should match
                     during the search. In case no required scorers are added, at least
                     one of the optional scorers will have to match during the search. </param>
            <param name="required">
                     the list of required scorers. </param>
            <param name="prohibited">
                     the list of prohibited scorers. </param>
            <param name="optional">
                     the list of optional scorers. </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer(System.Boolean)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.AddProhibitedScorers(Lucene.Net.Search.Scorer)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses the given required scorer and the prohibitedScorers. </summary>
            <param name="requiredCountingSumScorer"> A required scorer already built. </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>
            Count a scorer as a single match. </summary>
        </member>
        <member name="T:Lucene.Net.Search.MinShouldMatchSumScorer">
             <summary>
             A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
             this Scorer implements <seealso cref="!:Scorer#advance(int)"/> and uses advance() on the given Scorers.
            
             this implementation uses the minimumMatch constraint actively to efficiently
             prune the number of candidates, it is hence a mixture between a pure DisjunctionScorer
             and a ConjunctionScorer.
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.NumScorers">
            <summary>
            The overall number of non-finalized scorers </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.Mm">
            <summary>
            The minimum number of scorers that should match </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.SortedSubScorers">
            <summary>
            A static array of all subscorers sorted by decreasing cost </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.SortedSubScorersIdx">
            <summary>
            A monotonically increasing index into the array pointing to the next subscorer that is to be excluded </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.MmStack">
            <summary>
            mmStack is supposed to contain the most costly subScorers that still did
             not run out of docs, sorted by increasing sparsity of docs returned by that subScorer.
             For now, the cost of subscorers is assumed to be inversely correlated with sparsity.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.Doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.NrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)" -->
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer})">
            <summary>
            Construct a <code>DisjunctionScorer</code>, using one as the minimum number
            of matching subscorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.Score">
            <summary>
            Returns the score of the current document matching the query. Initially
            invalid, until <seealso cref="!:#nextDoc()"/> is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MinShouldMatchSumScorer.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapHeapify">
            <summary>
            Organize subScorers into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapSiftDown(System.Int32)">
            <summary>
            The subtree of subScorers at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemoveRoot">
            <summary>
            Remove the root Scorer from subScorers and re-establish it as a heap
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemove(Lucene.Net.Search.Scorer)">
            <summary>
            Removes a given Scorer from the heap by placing end of heap at that
            position and bubbling it either up or down
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>
            A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
            this Scorer implements <seealso cref="!:Scorer#advance(int)"/> and uses advance() on the given Scorers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionScorer">
            <summary>
            Base class for Scorers that score disjunctions.
            Currently this just provides helper methods to manage the heap.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionScorer.Doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.Heapify">
            <summary>
            Organize subScorers into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapAdjust(System.Int32)">
            <summary>
            The subtree of subScorers at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapRemoveRoot">
            <summary>
            Remove the root Scorer from subScorers and re-establish it as a heap
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionScorer.AfterNext" -->
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.NrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Search.Scorer[],System.Single[])">
            <summary>
            Construct a <code>DisjunctionScorer</code>. </summary>
            <param name="weight"> The weight to be used. </param>
            <param name="subScorers"> Array of at least two subscorers. </param>
            <param name="coord"> Table of coordination factors </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>
            Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BoostAttribute" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.CachingCollector" -->
        <member name="M:Lucene.Net.Search.CachingCollector.Create(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Search.CachingCollector"/> which does not wrap another collector.
            The cached documents and scores can later be {@link #replay(Collector)
            replayed}.
            </summary>
            <param name="acceptDocsOutOfOrder">
                     whether documents are allowed to be collected out-of-order </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.Collector,System.Boolean,System.Double)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified RAM threshold.
            </summary>
            <param name="other">
                     the Collector to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc </param>
            <param name="maxRAMMB">
                     the maximum RAM in MB to consume for caching the documents and
                     scores. If the collector exceeds the threshold, no documents and
                     scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.Collector,System.Boolean,System.Int32)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified max docs threshold.
            </summary>
            <param name="other">
                     the Collector to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc </param>
            <param name="maxDocsToCache">
                     the maximum number of documents for caching the documents and
                     possible the scores. If the collector exceeds the threshold,
                     no documents and scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.ReplayInit(Lucene.Net.Search.Collector)">
            <summary>
            Reused by the specialized inner classes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Replay(Lucene.Net.Search.Collector)">
            <summary>
            Replays the cached doc IDs (and scores) to the given Collector. If this
            instance does not cache scores, then Scorer is not set on
            {@code other.setScorer} as well as scores are not replayed.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      if this collector is not cached (i.e., if the RAM limits were too
                      low for the number of documents + scores to cache). </exception>
            <exception cref="!:IllegalArgumentException">
                      if the given Collect's does not support out-of-order collection,
                      while the collector passed to the ctor does. </exception>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary>
            Wraps another <seealso cref="P:Lucene.Net.Search.CachingWrapperFilter.Filter"/>'s result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class
            to add caching.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>
             Abstract base class for restricting which documents may
             be returned during searching.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)" -->
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps another filter's result and caches it. </summary>
            <param name="filter"> Filter to cache results of </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.CachingWrapperFilter.DocIdSetToCache(Lucene.Net.Search.DocIdSet,Lucene.Net.Index.AtomicReader)" -->
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.CacheImpl(Lucene.Net.Search.DocIdSetIterator,Lucene.Net.Index.AtomicReader)">
            <summary>
            Default cache implementation: uses <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.EMPTY_DOCIDSET">
            <summary>
            An empty {@code DocIdSet} instance </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.SizeInBytes">
            <summary>
            Returns total byte size used by cached filters. </summary>
        </member>
        <member name="P:Lucene.Net.Search.CachingWrapperFilter.Filter">
            <summary>
            Gets the contained filter. </summary>
            <returns> the contained filter. </returns>
        </member>
        <member name="T:Lucene.Net.Search.CollectionStatistics">
            <summary>
            Contains statistics for a collection (field)
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CollectionStatistics.Field">
            <summary>
            returns the field name </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.CollectionStatistics.DocCount" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.CollectionStatistics.SumDocFreq" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.CollectionStatistics.MaxDoc" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.CollectionTerminatedException" -->
        <member name="M:Lucene.Net.Search.CollectionTerminatedException.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ComplexExplanation">
            <summary>
            Expert: Describes the score computation for document and query, and
            can distinguish a match independent of a positive value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>
            Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>
            Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>
            Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>
            Render an explanation as HTML. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Explanation.IsMatch" -->
        <member name="P:Lucene.Net.Search.Explanation.Value">
            <summary>
            The value assigned to this explanation node. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Description">
            <summary>
            A description of this explanation node. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Summary">
            <summary>
            A short one line summary which should contain all high level
            information about this Explanation, without the "Details"
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Details">
            <summary>
            The sub-nodes of this explanation node. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ComplexExplanation.Match">
            <summary>
            The match status of this explanation node. </summary>
            <returns> May be null if match status is unknown </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.ComplexExplanation.IsMatch" -->
        <member name="T:Lucene.Net.Search.ConstantScoreQuery">
            <summary>
            A query that wraps another query or a filter and simply returns a constant score equal to the
            query boost for every document that matches the filter or query.
            For queries it therefore simply strips of all scores and returns a constant one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Strips off scores from the passed in Query. The hits will get a constant score
            dependent on the boost factor of this query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps a Filter as a Query. The hits will get a constant score
            dependent on the boost factor of this query.
            If you simply want to strip off scores from a Query, no longer use
            {@code new ConstantScoreQuery(new QueryWrapperFilter(query))}, instead
            use <seealso cref="!:#ConstantScoreQuery(Query)"/>!
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Filter">
            <summary>
            Returns the encapsulated filter, returns {@code null} if a query is wrapped. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Query">
            <summary>
            Returns the encapsulated query, returns {@code null} if a filter is wrapped. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery.ConstantBulkScorer">
            <summary>
            We return this as our <seealso cref="F:Lucene.Net.Search.ConstantScoreQuery.ConstantBulkScorer.BulkScorer"/> so that if the CSQ
             wraps a query with its own optimized top-level
             scorer (e.g. BooleanScorer) we can use that
             top-level scorer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1">
             <summary>
             Utility class that runs a thread to manage periodicc
              reopens of a <seealso cref="T:Lucene.Net.Search.ReferenceManager"/>, with methods to wait for a specific
              index changes to become visible.  To use this class you
              must first wrap your <seealso cref="T:Lucene.Net.Index.IndexWriter"/> with a {@link
              TrackingIndexWriter} and always use it to make changes
              to the index, saving the returned generation.  Then,
              when a given search request needs to see a specific
              index change, call the {#waitForGeneration} to wait for
              that change to be visible.  Note that this will only
              scale well if most searches do not need to wait for a
              specific index generation.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.#ctor(Lucene.Net.Index.TrackingIndexWriter,Lucene.Net.Search.ReferenceManager{`0},System.Double,System.Double)">
            <summary>
            Create ControlledRealTimeReopenThread, to periodically
            reopen the a <seealso cref="T:Lucene.Net.Search.ReferenceManager"/>.
            </summary>
            <param name="targetMaxStaleSec"> Maximum time until a new
                   reader must be opened; this sets the upper bound
                   on how slowly reopens may occur, when no
                   caller is waiting for a specific generation to
                   become visible.
            </param>
            <param name="targetMinStaleSec"> Mininum time until a new
                   reader can be opened; this sets the lower bound
                   on how quickly reopens may occur, when a caller
                   is waiting for a specific generation to
                   become visible. </param>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64)">
            <summary>
            Waits for the target generation to become visible in
            the searcher.
            If the current searcher is older than the
            target generation, this method will block
            until the searcher is reopened, by another via
            <seealso cref="!:ReferenceManager#maybeRefresh"/> or until the <seealso cref="T:Lucene.Net.Search.ReferenceManager"/> is closed.
            </summary>
            <param name="targetGen"> the generation to wait for </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64,System.Int32)" -->
        <member name="T:Lucene.Net.Search.ReferenceManager.RefreshListener">
            <summary>
            Use to receive notification when a refresh has
             finished.  See <seealso cref="!:#addListener"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceManager.RefreshListener">
            <summary>
            Use to receive notification when a refresh has
             finished.  See <seealso cref="!:#addListener"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.RefreshListener.BeforeRefresh">
            <summary>
            Called right before a refresh attempt starts. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.RefreshListener.AfterRefresh(System.Boolean)">
            <summary>
            Called after the attempted refresh; if the refresh
            did open a new reference then didRefresh will be true
            and <seealso cref="!:#acquire()"/> is guaranteed to return the new
            reference.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery">
            <summary>
            A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            this is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as BooleanQuery would give).
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
            each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Single)">
            <summary>
            Creates a new empty DisjunctionMaxQuery.  Use add() to add the subqueries. </summary>
            <param name="tieBreakerMultiplier"> the score of each non-maximum disjunct for a document is multiplied by this weight
                   and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
                   10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
                   word in the lower scored field (i.e., one that is not in any higher scored field. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},System.Single)" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)">
            <summary>
            Add a subquery to this disjunction </summary>
            <param name="query"> the disjunct added </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Add(System.Collections.Generic.ICollection{Lucene.Net.Search.Query})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.GetEnumerator" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Create the Weight used to score us </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Optimize our representation and our subqueries representations </summary>
            <param name="reader"> the IndexReader we query </param>
            <returns> an optimized copy of us (which may not be a copy if there is nothing to optimize)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Clone">
            <summary>
            Create a shallow copy of us -- used in rewriting if necessary </summary>
            <returns> a copy of us (but reuse, don't copy, our subqueries)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ToString(System.String)">
            <summary>
            Prettyprint us. </summary>
            <param name="field"> the field to which we are applied </param>
            <returns> a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost" </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Equals(System.Object)">
            <summary>
            Return true iff we represent the same query as o </summary>
            <param name="o"> another object </param>
            <returns> true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetHashCode">
            <summary>
            Compute a hash code for hashing us </summary>
            <returns> the hash code </returns>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.Disjuncts">
            <returns> the disjuncts. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.TieBreakerMultiplier">
            <returns> tie breaker value for multiple matches. </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight">
             <summary>
             Expert: the Weight for DisjunctionMaxQuery, used to
             normalize, score and explain these queries.
            
             <p>NOTE: this API and implementation is subject to
             change suddenly in the next release.</p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Weights">
            <summary>
            The Weights for our subqueries, in 1-1 correspondence with disjuncts </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.#ctor(Lucene.Net.Search.DisjunctionMaxQuery,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Normalize(System.Single,System.Single)">
            <summary>
            Apply the computed normalization factor to our subqueries </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Scorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            Create the scorer used to score our associated DisjunctionMaxQuery </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            Explain the score we computed for doc </summary>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Query">
            <summary>
            Return our associated DisjunctionMaxQuery </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxScorer">
            <summary>
            The Scorer for DisjunctionMaxQuery.  The union of all documents generated by the the subquery scorers
            is generated in document number order.  The score for each document is the maximum of the scores computed
            by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
            for the other subqueries that generate the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.#ctor(Lucene.Net.Search.Weight,System.Single,Lucene.Net.Search.Scorer[])">
            <summary>
            Creates a new instance of DisjunctionMaxScorer
            </summary>
            <param name="weight">
                     The Weight to be used. </param>
            <param name="tieBreakerMultiplier">
                     Multiplier applied to non-maximum-scoring subqueries for a
                     document as they are summed into the result. </param>
            <param name="subScorers">
                     The sub scorers this Scorer should iterate on </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Score">
            <summary>
            Determine the current document score.  Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> the score of the current generated document </returns>
        </member>
        <member name="T:Lucene.Net.Search.DocTermOrdsRangeFilter">
             <summary>
             A range filter built on top of a cached multi-valued term field (in <seealso cref="T:Lucene.Net.Search.IFieldCache"/>).
            
             <p>Like <seealso cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/>, this is just a specialized range query versus
                using a TermRangeQuery with <seealso cref="T:Lucene.Net.Search.DocTermOrdsRewriteMethod"/>: it will only do
                two ordinal to term lookups.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            this method is implemented for each data type </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a BytesRef range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheDocIdSet">
            <summary>
            Base class for DocIdSet to be used with FieldCache. The implementation
            of its iterator is very stupid and slow if the implementation of the
            <seealso cref="!:#matchDoc"/> method is not optimized, as iterators simply increment
            the document id until {@code matchDoc(int)} returns true. Because of this
            {@code matchDoc(int)} must be as fast as possible and in no case do any
            I/O.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)">
            <summary>
            this method checks, if a doc is a hit
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheDocIdSet.Cacheable">
            <summary>
            this DocIdSet is always cacheable (does not go back
            to the reader for iteration)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.DocTermOrdsRewriteMethod" -->
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="T:Lucene.Net.Search.FakeScorer">
            <summary>
            Used by <seealso cref="T:Lucene.Net.Search.BulkScorer"/>s that need to pass a {@link
             Scorer} to <seealso cref="!:Collector#setScorer"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IFieldCache" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
             reads the terms in <code>field</code> and returns a bit set at the size of
             <code>reader.maxDoc()</code>, with turned on bits for each docid that
             does have a value for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as a single byte and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the single byte values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="T:Lucene.Net.Documents.IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as bytes and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the bytes. </param>
            <param name="parser">  Computes byte for string values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="T:Lucene.Net.Documents.IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetShorts(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as shorts and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the shorts. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="T:Lucene.Net.Documents.IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetShorts(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IShortParser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as shorts and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the shorts. </param>
            <param name="parser">  Computes short for string values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="T:Lucene.Net.Documents.IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetInts(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetInts(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IIntParser,System.Boolean)">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Search.FieldCache.Ints"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as ints and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes int for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <seealso cref="T:Lucene.Net.Documents.IntField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetFloats(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetFloats(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IFloatParser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Floats"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the floats. </param>
            <param name="parser">
                     Computes float for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <seealso cref="T:Lucene.Net.Documents.FloatField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetLongs(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetLongs(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ILongParser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Longs"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as longs and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes long for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <seealso cref="T:Lucene.Net.Documents.LongField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Doubles"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as doubles and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes double for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/> or
                     <seealso cref="T:Lucene.Net.Documents.DoubleField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code>
            and returns a <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> instance, providing a
            method to retrieve the term (as a BytesRef) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean,System.Single)">
            <summary>
            Expert: just like <seealso cref="!:#getTerms(AtomicReader,String,boolean)"/>,
             but you can specify whether more RAM should be consumed in exchange for
             faster lookups (default is "true").  Note that the
             first call for a given reader and field "wins",
             subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code>
            and returns a <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> instance,
            providing methods to retrieve sort ordinals and terms
            (as a ByteRef) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)">
            <summary>
            Expert: just like {@link
             #getTermsIndex(AtomicReader,String)}, but you can specify
             whether more RAM should be consumed in exchange for
             faster lookups (default is "true").  Note that the
             first call for a given reader and field "wins",
             subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocTermOrds(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found, reads the term values
            in <code>field</code> and returns a <seealso cref="T:Lucene.Net.Index.DocTermOrds"/> instance, providing a method to retrieve
            the terms (as ords) per document.
            </summary>
            <param name="reader">  Used to build a <seealso cref="T:Lucene.Net.Index.DocTermOrds"/> instance </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> a <seealso cref="T:Lucene.Net.Index.DocTermOrds"/> instance </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeAllCaches">
            <summary>
            <p>
            EXPERT: Instructs the FieldCache to forcibly expunge all entries
            from the underlying caches.  this is intended only to be used for
            test methods as a way to ensure a known base state of the Cache
            (with out needing to rely on GC to free WeakReferences).
            It should not be relied on for "Cache maintenance" in general
            application code.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeByCacheKey(System.Object)">
            <summary>
            Expert: drops all cache entries associated with this
            reader <seealso cref="!:IndexReader#getCoreCacheKey"/>.  NOTE: this cache key must
            precisely match the reader that the cache entry is
            keyed on. If you pass a top-level reader, it usually
            will have no effect as Lucene now caches at the segment
            reader level.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IFieldCache.CacheEntries">
            <summary>
            EXPERT: Generates an array of CacheEntry objects representing all items
            currently in the FieldCache.
            <p>
            NOTE: These CacheEntry objects maintain a strong reference to the
            Cached Values.  Maintaining references to a CacheEntry the AtomicIndexReader
            associated with it has garbage collected will prevent the Value itself
            from being garbage collected when the Cache drops the WeakReference.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IFieldCache.InfoStream">
            <summary>
            If non-null, FieldCacheImpl will warn whenever
            entries are created that are not sane according to
            <seealso cref="T:Lucene.Net.Util.FieldCacheSanityChecker"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl">
             <summary>
             Expert: The default cache implementation, storing all values in memory.
             A WeakHashMap is used for storage.
            
             @since   lucene 1.4
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Cache">
            <summary>
            Expert: Internal cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.PurgeByCacheKey(System.Object)">
            <summary>
            Remove this reader from the cache, if present. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.Put(Lucene.Net.Index.AtomicReader,Lucene.Net.Search.FieldCacheImpl.CacheKey,System.Object)">
            <summary>
            Sets the key to the value for the provided reader;
             if the key is already set then this doesn't change it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.CacheKey">
            <summary>
            Expert: Every composite-key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.#ctor(System.String,System.Object)">
            <summary>
            Creates one of these objects for a custom comparator/parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.Equals(System.Object)">
            <summary>
            Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.GetHashCode">
            <summary>
            Composes a hashcode based on the field and type. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheRangeFilter" -->
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a string range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a BytesRef range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getBytes(AtomicReader,String,boolean)"/>. this works with all
            byte fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getBytes(AtomicReader,String,FieldCache.ByteParser,boolean)"/>. this works with all
            byte fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewShortRange(System.String,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getShorts(AtomicReader,String,boolean)"/>. this works with all
            short fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewShortRange(System.String,Lucene.Net.Search.FieldCache.IShortParser,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getShorts(AtomicReader,String,FieldCache.ShortParser,boolean)"/>. this works with all
            short fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewIntRange(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getInts(AtomicReader,String,boolean)"/>. this works with all
            int fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewIntRange(System.String,Lucene.Net.Search.FieldCache.IIntParser,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getInts(AtomicReader,String,FieldCache.IntParser,boolean)"/>. this works with all
            int fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewLongRange(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getLongs(AtomicReader,String,boolean)"/>. this works with all
            long fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewLongRange(System.String,Lucene.Net.Search.FieldCache.ILongParser,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getLongs(AtomicReader,String,FieldCache.LongParser,boolean)"/>. this works with all
            long fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewFloatRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getFloats(AtomicReader,String,boolean)"/>. this works with all
            float fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewFloatRange(System.String,Lucene.Net.Search.FieldCache.IFloatParser,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getFloats(AtomicReader,String,FieldCache.FloatParser,boolean)"/>. this works with all
            float fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getDoubles(AtomicReader,String,boolean)"/>. this works with all
            double fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getDoubles(AtomicReader,String,FieldCache.DoubleParser,boolean)"/>. this works with all
            double fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            this method is implemented for each data type </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Parser">
            <summary>
            Returns the current numeric parser ({@code null} for {@code T} is {@code String}} </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheRewriteMethod" -->
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheTermsFilter">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.Filter"/> that only accepts documents whose single
             term value in the specified field is contained in the
             provided set of allowed terms.
            
             <p/>
            
             this is the same functionality as TermsFilter (from
             queries/), except this filter requires that the
             field contains only a single term for all documents.
             Because of drastically different implementations, they
             also have different performance characteristics, as
             described below.
            
             <p/>
            
             The first invocation of this filter on a given field will
             be slower, since a <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> must be
             created.  Subsequent invocations using the same field
             will re-use this cache.  However, as with all
             functionality based on <seealso cref="P:Lucene.Net.Search.FieldCacheTermsFilter.FieldCache"/>, persistent RAM
             is consumed to hold the cache, and is not freed until the
             <seealso cref="T:Lucene.Net.Index.IndexReader"/> is closed.  In contrast, TermsFilter
             has no persistent RAM consumption.
            
            
             <p/>
            
             With each search, this filter translates the specified
             set of Terms into a private <seealso cref="T:Lucene.Net.Util.FixedBitSet"/> keyed by
             term number per unique <seealso cref="T:Lucene.Net.Index.IndexReader"/> (normally one
             reader per segment).  Then, during matching, the term
             number for each docID is retrieved from the cache and
             then checked for inclusion using the <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
             Since all testing is done using RAM resident data
             structures, performance should be very fast, most likely
             fast enough to not require further caching of the
             DocIdSet for each possible combination of terms.
             However, because docIDs are simply scanned linearly, an
             index with a great many small documents may find this
             linear scan too costly.
            
             <p/>
            
             In contrast, TermsFilter builds up an <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>,
             keyed by docID, every time it's created, by enumerating
             through all matching docs using <seealso cref="T:Lucene.Net.Index.DocsEnum"/> to seek
             and scan through each term's docID list.  While there is
             no linear scan of all docIDs, besides the allocation of
             the underlying array in the <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>, this
             approach requires a number of "disk seeks" in proportion
             to the number of terms, which can be exceptionally costly
             when there are cache misses in the OS's IO cache.
            
             <p/>
            
             Generally, this filter will be slower on the first
             invocation for a given field, but subsequent invocations,
             even if you change the allowed set of Terms, should be
             faster than TermsFilter, especially as the number of
             Terms being matched increases.  If you are matching only
             a very small number of terms, and those terms in turn
             match a very small number of documents, TermsFilter may
             perform faster.
            
             <p/>
            
             Which filter is best is very application dependent.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldComparator`1" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator.Compare(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator.CompareBottom(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator.CompareTop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparator.Copy(System.Int32,System.Int32)">
            <summary>
            this method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> which slot to copy the hit to </param>
            <param name="doc"> docID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> current reader context </param>
            <returns> the comparator to use for this segment; most
              comparators can just return "this" to reuse the same
              comparator across segments </returns>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.Value(System.Int32)">
            <summary>
            Return the actual value in the slot.
            </summary>
            <param name="slot"> the value </param>
            <returns> value in this slot </returns>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparator.Bottom">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <seealso cref="!:#compareBottom"/> is
            called, you should compare against this slot.  this
            will always be called before <seealso cref="!:#compareBottom"/>.
            </summary>
            <param name="slot"> the currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparator.TopValue">
            <summary>
            Record the top value, for future calls to {@link
            #compareTop}.  this is only called for searches that
            use searchAfter (deep paging), and is called before any
            calls to <seealso cref="!:#setNextReader"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparator.Scorer">
            <summary>
            Sets the Scorer to use in case a document's score is
             needed.
            </summary>
            <param name="scorer"> Scorer instance that you should use to
            obtain the current hit's score, if necessary.  </param>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.NumericComparator`1">
            <summary>
            Base FieldComparator class for numeric types
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldComparator`1" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator`1.Compare(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator`1.CompareBottom(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparator`1.CompareTop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparator`1.Copy(System.Int32,System.Int32)">
            <summary>
            this method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> which slot to copy the hit to </param>
            <param name="doc"> docID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> current reader context </param>
            <returns> the comparator to use for this segment; most
              comparators can just return "this" to reuse the same
              comparator across segments </returns>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator`1.CompareValues(`0,`0)">
            <summary>
            Returns -1 if first is less than second.  Default
             impl to assume the type implements Comparable and
             invoke .compareTo; be sure to override this method if
             your FieldComparator's type isn't a Comparable or
             if your values may sometimes be null
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparator`1.Bottom">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <seealso cref="!:#compareBottom"/> is
            called, you should compare against this slot.  this
            will always be called before <seealso cref="!:#compareBottom"/>.
            </summary>
            <param name="slot"> the currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparator`1.TopValue">
            <summary>
            Record the top value, for future calls to {@link
            #compareTop}.  this is only called for searches that
            use searchAfter (deep paging), and is called before any
            calls to <seealso cref="!:#setNextReader"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.ByteComparator">
            <summary>
            Parses field's values as byte (using {@link
             FieldCache#getBytes} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.DoubleComparator">
            <summary>
            Parses field's values as double (using {@link
             FieldCache#getDoubles} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.FloatComparator">
            <summary>
            Parses field's values as float (using {@link
             FieldCache#getFloats} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.ShortComparator">
            <summary>
            Parses field's values as short (using {@link
             FieldCache#getShorts} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.IntComparator">
            <summary>
            Parses field's values as int (using {@link
             FieldCache#getInts} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.LongComparator">
            <summary>
            Parses field's values as long (using {@link
             FieldCache#getLongs} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.RelevanceComparator">
            <summary>
            Sorts by descending relevance.  NOTE: if you are
             sorting only by descending relevance and then
             secondarily by ascending docID, performance is faster
             using <seealso cref="T:Lucene.Net.Search.TopScoreDocCollector"/> directly (which {@link
             IndexSearcher#search} uses when no <seealso cref="T:Lucene.Net.Search.Sort"/> is
             specified).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.DocComparator">
            <summary>
            Sorts by ascending docID </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.TermOrdValComparator">
            <summary>
            Sorts by field's natural Term sort order, using
             ordinals.  this is functionally equivalent to {@link
             Lucene.Net.Search.FieldComparator.TermValComparator}, but it first resolves the string
             to their relative ordinal positions (using the index
             returned by <seealso cref="!:IFieldCache#getTermsIndex"/>), and
             does most comparisons using the ordinals.  For medium
             to large results, this comparator will be much faster
             than <seealso cref="T:Lucene.Net.Search.FieldComparator.TermValComparator"/>.  For very small
             result sets it may be slower.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparator.TermOrdValComparator.TopValue_Renamed">
            <summary>
            Set by setTopValue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparator.TermOrdValComparator.MissingSortCmp">
            <summary>
            -1 if missing values are sorted first, 1 if they are
             sorted last
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparator.TermOrdValComparator.MissingOrd">
            <summary>
            Which ordinal to use for a missing value. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.TermOrdValComparator.#ctor(System.Int32,System.String)">
            <summary>
            Creates this, sorting missing values first. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.TermOrdValComparator.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Creates this, with control over how missing values
             are sorted.  Pass sortMissingLast=true to put
             missing values at the end.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.TermOrdValComparator.GetSortedDocValues(Lucene.Net.Index.AtomicReaderContext,System.String)">
            <summary>
            Retrieves the SortedDocValues for the field in this segment </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparator.TermValComparator">
            <summary>
            Sorts by field's natural Term sort order.  All
             comparisons are done using BytesRef.compareTo, which is
             slow for medium to large result sets but possibly
             very fast for very small results sets.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparator.TermValComparator.#ctor(System.Int32,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparatorSource">
             <summary>
             Provides a <seealso cref="T:Lucene.Net.Search.FieldComparator"/> for custom field sorting.
            
             @lucene.experimental
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparatorSource.NewComparator(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a comparator for the field in the given index.
            </summary>
            <param name="fieldname">
                     Name of the field to create comparator for. </param>
            <returns> FieldComparator. </returns>
            <exception cref="!:IOException">
                      If an error occurs reading the index. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDoc" -->
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>
            Holds one hit in <seealso cref="T:Lucene.Net.Search.TopDocs"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.Score">
            <summary>
            The score of this document for the query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.ScoreDoc.Doc" -->
        <member name="F:Lucene.Net.Search.ScoreDoc.ShardIndex">
            <summary>
            Only set by <seealso cref="!:TopDocs#merge"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Constructs a ScoreDoc. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single,System.Int32)">
            <summary>
            Constructs a ScoreDoc. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.FieldDoc.Fields" -->
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[])">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[],System.Int32)">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueFilter">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Filter"/> that accepts all documents that have one or more values in a
            given field. this <seealso cref="T:Lucene.Net.Search.Filter"/> request <seealso cref="T:Lucene.Net.Util.Bits"/> from the
            <seealso cref="T:Lucene.Net.Search.IFieldCache"/> and build the bits if not present.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     the field to filter </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     the field to filter </param>
            <param name="negate">
                     iff <code>true</code> all documents with no value in the given
                     field are accepted.
             </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.Field">
            <summary>
            Returns the field this filter is applied on. </summary>
            <returns> the field this filter is applied on. </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.Negate">
            <summary>
            Returns <code>true</code> iff this filter is negated, otherwise <code>false</code> </summary>
            <returns> <code>true</code> iff this filter is negated, otherwise <code>false</code> </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.Create``1(Lucene.Net.Search.SortField[],System.Int32)">
             <summary> Creates a hit queue sorted by the given list of fields.
            
             <p/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length <c>numHits</c>.
            
             </summary>
             <param name="fields">SortField array we are sorting by in priority order (highest
             priority first); cannot be <c>null</c> or empty
             </param>
             <param name="size">The number of hits to retain. Must be greater than zero.
             </param>
             <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.OneComparatorFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue"/> which is optimized in case
            there is just one comparator.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldValueHitQueue`1" -->
        <member name="F:Lucene.Net.Search.FieldValueHitQueue`1.fields">
            <summary>
            Stores the sort criteria being used. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldValueHitQueue`1.FillFields(Lucene.Net.Search.FieldValueHitQueue.Entry)" -->
        <member name="P:Lucene.Net.Search.FieldValueHitQueue`1.Fields">
            <summary>
            Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.OneComparatorFieldValueHitQueue`1.LessThan(`0,`0)">
            <summary> Returns whether <c>a</c> is less relevant than <c>b</c>.</summary>
            <param name="hitA">ScoreDoc</param>
            <param name="hitB">ScoreDoc</param>
            <returns><c>true</c> if document <c>a</c> should be sorted after document <c>b</c>.</returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.MultiComparatorsFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue"/> which is optimized in case
            there is more than one comparator.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredQuery" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            Constructs a new query which applies a filter to the results of the original query.
            <seealso cref="!:Filter#getDocIdSet"/> will be called every time this query is used in a search. </summary>
            <param name="query">  Query to be filtered, cannot be <code>null</code>. </param>
            <param name="filter"> Filter to apply to query results, cannot be <code>null</code>. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.FilteredQuery.FilterStrategy)" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Returns a Weight that applies the filter to the enclosed query's Weight.
            this is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Rewrites the query. If the wrapped is an instance of
            <seealso cref="T:Lucene.Net.Search.MatchAllDocsQuery"/> it returns a <seealso cref="T:Lucene.Net.Search.ConstantScoreQuery"/>. Otherwise
            it returns a new {@code FilteredQuery} wrapping the rewritten query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
             the given <seealso cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
             from <seealso cref="!:DocIdSet#bits()"/>) and
             <seealso cref="!:RandomAccessFilterStrategy#useRandomAccess(Bits, int)"/> returns
             <code>true</code>. Otherwise this strategy falls back to a "zig-zag join" (
             <seealso cref="!:FilteredQuery#LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy.
            
             <p>
             Note: this strategy is the default strategy in <seealso cref="T:Lucene.Net.Search.FilteredQuery"/>
             </p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <p>
            Note: this strategy uses the filter to lead the iteration.
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <p>
            Note: this strategy uses the query to lead the iteration.
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.QUERY_FIRST_FILTER_STRATEGY">
            <summary>
            A filter strategy that advances the Query or rather its <seealso cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <p>
            Note: this strategy requires a <seealso cref="!:DocIdSet#bits()"/> to return a non-null value. Otherwise
            this strategy falls back to <seealso cref="!:FilteredQuery#LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </p>
            <p>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </p>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Query">
            <summary>
            Returns this FilteredQuery's (unfiltered) Query </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Filter">
            <summary>
            Returns this FilteredQuery's filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Strategy">
            <summary>
            Returns this FilteredQuery's <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstScorer">
            <summary>
            A scorer that consults the filter iff a document was matched by the
            delegate scorer. this is useful if the filter computation is more expensive
            than document scoring or if the filter has a linear running time to compute
            the next matching doc like exact geo distances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.LeapFrogScorer">
            <summary>
            A Scorer that uses a "leap-frog" approach (also called "zig-zag join"). The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.FilterStrategy">
            <summary>
            Abstract class that defines how the filter (<seealso cref="T:Lucene.Net.Search.DocIdSet"/>) applied during document collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <seealso cref="T:Lucene.Net.Search.Scorer"/> based on this strategy.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <seealso cref="T:Lucene.Net.Search.FilteredQuery"/> <seealso cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="docIdSet"> the filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered scorer
            </returns>
            <exception cref="!:IOException"> if an <seealso cref="!:IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredBulkScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,System.Boolean,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <seealso cref="T:Lucene.Net.Search.BulkScorer"/> based on this
            strategy.  this is an optional method: the default
            implementation just calls <seealso cref="!:#filteredScorer"/> and
            wraps that into a BulkScorer.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <seealso cref="T:Lucene.Net.Search.FilteredQuery"/> <seealso cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="docIdSet"> the filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered top scorer </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
            the given <seealso cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
            from <seealso cref="!:DocIdSet#bits()"/>) and
            <seealso cref="!:RandomAccessFilterStrategy#useRandomAccess(Bits, int)"/> returns
            <code>true</code>. Otherwise this strategy falls back to a "zig-zag join" (
            <seealso cref="!:FilteredQuery#LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy.UseRandomAccess(Lucene.Net.Util.Bits,System.Int32)" -->
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstFilterStrategy">
            <summary>
            A filter strategy that advances the <seealso cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <p>
            Note: this strategy requires a <seealso cref="!:DocIdSet#bits()"/> to return a non-null value. Otherwise
            this strategy falls back to <seealso cref="!:FilteredQuery#LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </p>
            <p>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyQuery" -->
        <member name="F:Lucene.Net.Search.FuzzyQuery.DefaultMinSimilarity">
            @deprecated pass integer edit distances instead.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32,System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32)">
            <summary>
            Calls {@link #FuzzyQuery(Term, int, int, int, boolean)
            FuzzyQuery(term, maxEdits, prefixLength, defaultMaxExpansions, defaultTranspositions)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Calls <seealso cref="!:#FuzzyQuery(Term, int, int) FuzzyQuery(term, maxEdits, defaultPrefixLength)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Calls <seealso cref="!:#FuzzyQuery(Term, int) FuzzyQuery(term, defaultMaxEdits)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.FloatToEdits(System.Single,System.Int32)">
            <summary>
            Helper function to convert from deprecated "minimumSimilarity" fractions
            to raw edit distances.
            </summary>
            <param name="minimumSimilarity"> scaled similarity </param>
            <param name="termLen"> length (in unicode codepoints) of the term. </param>
            <returns> equivalent number of maxEdits </returns>
            @deprecated pass integer edit distances instead.
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.MaxEdits">
            <returns> the maximum number of edit distances allowed for this query to match. </returns>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.PrefixLength">
            <summary>
            Returns the non-fuzzy prefix length. this is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Transpositions">
            <summary>
            Returns true if transpositions should be treated as a primitive edit operation.
            If this is false, comparisons will implement the classic Levenshtein algorithm.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum">
             <summary>
             Subclass of TermsEnum for enumerating all terms that are similar
             to the specified filter term.
            
             <p>Term enumerations are always ordered by
             <seealso cref="!:#getComparator"/>.  Each term in the enumeration is
             greater than all that precede it.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermsEnum.#ctor(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource,Lucene.Net.Index.Term,System.Single,System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.GetAutomatonEnum(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            return an automata-based enum for matching up to editDistance from
            lastTerm, if possible
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.InitAutomata(System.Int32)">
            <summary>
            initialize levenshtein DFAs up to maxDistance, if possible </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.BottomChanged(Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            fired when the max non-competitive boost has changed. this is the hook to
            swap in a smarter actualEnum
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.Enum">
            <summary>
            swap in a new actual enum to proxy to </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.MinSimilarity">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.ScaleFactor">
            <summary>
            @lucene.internal </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum" -->
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            finds the smallest Lev(n) DFA that accepts the term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Matches(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            returns true if term is within k edits of the query term </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.ILevenshteinAutomataAttribute">
            <summary>
            reuses compiled automata across different segments,
            because they are independent of the index
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.LevenshteinAutomataAttribute">
            <summary>
            Stores compiled automata as a list (indexed by edit distance)
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitQueue.#ctor(System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="F:Lucene.Net.Search.IndexSearcher.LeafSlices">
            <summary>
            used with executor - each slice holds a set of leafs executed within one thread </summary>
        </member>
        <member name="F:Lucene.Net.Search.IndexSearcher.Similarity_Renamed">
            <summary>
            The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>
            Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader,System.Threading.Tasks.TaskScheduler)">
             <summary>
             Runs searches for each segment separately, using the
              provided ExecutorService.  IndexSearcher will not
              shutdown/awaitTermination this ExecutorService on
              close; you must do so, eventually, on your own.  NOTE:
              if you are using <seealso cref="T:Lucene.Net.Store.NIOFSDirectory"/>, do not use
              the shutdownNow method of ExecutorService as this uses
              Thread.interrupt under-the-hood which can silently
              close file descriptors (see <a href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext,System.Threading.Tasks.TaskScheduler)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Slices(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Expert: Creates an array of leaf slices each holding a subset of the given leaves.
            Each <seealso cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> is executed in a single thread. By default there
            will be one <seealso cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> per leaf (<seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,Lucene.Net.Index.StoredFieldVisitor)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,System.Collections.Generic.ISet{System.String})" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            @deprecated Use <seealso cref="!:#doc(int, Set)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.WrapFilter(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            @lucene.internal </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)">
            <summary>
            Finds the top <code>n</code>
            hits for <code>query</code>.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClauses"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary>
            Finds the top <code>n</code>
            hits for <code>query</code>, applying <code>filter</code> if non-null.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClauses"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.Collector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Collector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)">
            <summary>
            Search implementation with arbitrary sorting, plus
            control over whether hit scores and max score
            should be computed.  Finds
            the top <code>n</code> hits for <code>query</code>, applying
            <code>filter</code> if non-null, and sorting the hits by the criteria in
            <code>sort</code>.  If <code>doDocScores</code> is <code>true</code>
            then the score of each hit will be computed and
            returned.  If <code>doMaxScore</code> is
            <code>true</code> then the maximum score over all
            collected hits will be computed.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClauses"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)">
            <summary>
            Search implementation with arbitrary sorting and no filter. </summary>
            <param name="query"> The query to search for </param>
            <param name="n"> Return only the top n results </param>
            <param name="sort"> The <seealso cref="T:Lucene.Net.Search.Sort"/> object </param>
            <returns> The top docs, sorted according to the supplied <seealso cref="T:Lucene.Net.Search.Sort"/> instance </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <seealso cref="!:#search(Weight, int, Sort, boolean, boolean)"/>, but you choose
            whether or not the fields in the returned <seealso cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying fillFields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <seealso cref="!:#search(Weight, int, Sort, boolean, boolean)"/>, but you choose
            whether or not the fields in the returned <seealso cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying fillFields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.Collector)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Rewrite(Lucene.Net.Search.Query)">
            <summary>
            Expert: called to re-write queries into primitive queries. </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClauses"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Weight,System.Int32)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.CreateNormalizedWeight(Lucene.Net.Search.Query)">
            <summary>
            Creates a normalized weight for a top-level <seealso cref="T:Lucene.Net.Search.Query"/>.
            The query is rewritten by this method and <seealso cref="!:Query#createWeight"/> called,
            afterwards the <seealso cref="T:Lucene.Net.Search.Weight"/> is normalized. The returned {@code Weight}
            can then directly be used to get a <seealso cref="T:Lucene.Net.Search.Scorer"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.TermStatistics(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
             <summary>
             Returns <seealso cref="M:Lucene.Net.Search.IndexSearcher.TermStatistics(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)"/> for a term.
            
             this can be overridden for example, to return a term's statistics
             across a distributed collection.
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.CollectionStatistics(System.String)">
             <summary>
             Returns <seealso cref="M:Lucene.Net.Search.IndexSearcher.CollectionStatistics(System.String)"/> for a field.
            
             this can be overridden for example, to return a field's statistics
             across a distributed collection.
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.DefaultSimilarity">
            <summary>
            Expert: returns a default Similarity instance.
            In general, this method is only called to initialize searchers and writers.
            User code and query implementations should respect
            <seealso cref="!:IndexSearcher#getSimilarity()"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.IndexReader">
            <summary>
            Return the <seealso cref="P:Lucene.Net.Search.IndexSearcher.IndexReader"/> this searches. </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.Similarity">
             <summary>
             Expert: Set the Similarity implementation used by this IndexSearcher.
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.IndexSearcher.TopReaderContext" -->
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableNoSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableWithSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher.ExecutionHelper`1" -->
        <member name="T:Lucene.Net.Search.IndexSearcher.LeafSlice">
             <summary>
             A class holding a subset of the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>s leaf contexts to be
             executed within a single thread.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.LiveFieldValues`2" -->
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Add(System.String,`1)">
            <summary>
            Call this after you've successfully added a document
             to the index, to record what value you just set the
             field to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Delete(System.String)">
            <summary>
            Call this after you've successfully deleted a document
             from the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Size">
            <summary>
            Returns the [approximate] number of id/value pairs
             buffered in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Get(System.String)">
            <summary>
            Returns the current value for this id, or null if the
             id isn't in the index or was deleted.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.LiveFieldValues`2.LookupFromSearcher(`0,System.String)" -->
        <member name="T:Lucene.Net.Search.MatchAllDocsQuery">
             <summary>
             A query that matches all documents.
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute" -->
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.MaxNonCompetitiveBoost">
            <summary>
            this is the maximum boost that would not be competitive. </summary>
        </member>
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.CompetitiveTerm">
            <summary>
            this is the term or <code>null</code> of the term that triggered the boost change. </summary>
        </member>
        <member name="T:Lucene.Net.Search.MaxNonCompetitiveBoostAttribute">
            <summary>
            Implementation class for <seealso cref="T:Lucene.Net.Search.MaxNonCompetitiveBoostAttribute"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiCollector">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Collector"/> which allows running a search with several
            <seealso cref="T:Lucene.Net.Search.Collector"/>s. It offers a static <seealso cref="!:#wrap"/> method which accepts a
            list of collectors and wraps them with <seealso cref="T:Lucene.Net.Search.MultiCollector"/>, while
            filtering out the <code>null</code> null ones.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiCollector.Wrap(Lucene.Net.Search.Collector[])" -->
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
             <summary>
             MultiPhraseQuery is a generalized version of PhraseQuery, with an added
             method <seealso cref="!:#add(Term[])"/>.
             To use this class, to search for the phrase "Microsoft app*" first use
             add(Term) on the term "Microsoft", then find all terms that have "app" as
             prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
             terms) to add them to the query.
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)" -->
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.MultiPhraseQuery.Slop" -->
        <member name="P:Lucene.Net.Search.MultiPhraseQuery.TermArrays">
            <summary>
            Returns a List of the terms in the multiphrase.
            Do not modify the List or its contents.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiPhraseQuery.Positions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.UnionDocsAndPositionsEnum">
            <summary>
            Takes the logical union of multiple DocsEnum iterators.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQueryWrapperFilter`1" -->
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.#ctor(`0)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="T:Lucene.Net.Search.NGramPhraseQuery">
             <summary>
             this is a <seealso cref="T:Lucene.Net.Search.PhraseQuery"/> which is optimized for n-gram phrase query.
             For example, when you query "ABCD" on a 2-gram field, you may want to use
             NGramPhraseQuery rather than <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>, because NGramPhraseQuery
             will <seealso cref="!:#rewrite(IndexReader)"/> the query to "AB/0 CD/2", while <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>
             will query "AB/0 BC/1 CD/2" (where term/position).
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseQuery" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>
            Constructs an empty phrase query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>
            Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
             <summary>
             Adds a term to the end of the query phrase.
             The relative position of the term within the phrase is specified explicitly.
             this allows e.g. phrases with more than one term at the same position
             or phrases with gaps (e.g. in connection with stopwords).
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.PhraseQuery.Slop" -->
        <member name="P:Lucene.Net.Search.PhraseQuery.Terms">
            <summary>
            Returns the set of terms in this phrase. </summary>
        </member>
        <member name="P:Lucene.Net.Search.PhraseQuery.Positions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.#ctor(System.Int32)">
            <summary>
            Constructor that takes gram size. </summary>
            <param name="n"> n-gram size </param>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeFilter`1" -->
        <member name="M:Lucene.Net.Search.NumericRangeFilter`1.IncludesMin">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter`1.IncludesMax">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Min">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Max">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewLongRange(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>long</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewLongRange(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>long</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewIntRange(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>int</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewIntRange(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>int</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>double</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>double</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewFloatRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>float</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewFloatRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>float</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeQuery`1" -->
        <member name="M:Lucene.Net.Search.NumericRangeQuery`1.IncludesMin">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery`1.IncludesMax">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Min">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Max">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeQuery`1.NumericRangeTermsEnum" -->
        <member name="T:Lucene.Net.Util.NumericUtils.LongRangeBuilder">
            <summary>
            Callback for <seealso cref="!:#splitLongRange"/>.
            You need to overwrite only one of the methods.
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.NumericUtils" -->
        <member name="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT">
            <summary>
            The default precision step used by <seealso cref="T:Lucene.Net.Documents.IntField"/>,
            <seealso cref="T:Lucene.Net.Documents.FloatField"/>, <seealso cref="T:Lucene.Net.Documents.LongField"/>, {@link
            DoubleField}, <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream"/>, {@link
            NumericRangeQuery}, and <seealso cref="T:Lucene.Net.Search.NumericRangeFilter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_LONG">
            <summary>
            Longs are stored at lower precision by shifting off lower bits. The shift count is
            stored as <code>SHIFT_START_LONG+shift</code> in the first byte
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.NumericUtils.BUF_SIZE_LONG" -->
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_INT">
            <summary>
            Integers are stored at lower precision by shifting off lower bits. The shift count is
            stored as <code>SHIFT_START_INT+shift</code> in the first byte
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.NumericUtils.BUF_SIZE_INT" -->
        <member name="M:Lucene.Net.Util.NumericUtils.LongToPrefixCoded(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.IntToPrefixCoded(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.LongToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.IntToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="T:Lucene.Net.Analysis.NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedLongShift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded {@code long}. </summary>
            <exception cref="!:NumberFormatException"> if the supplied <seealso cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedIntShift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded {@code int}. </summary>
            <exception cref="!:NumberFormatException"> if the supplied <seealso cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.PrefixCodedToLong(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.PrefixCodedToInt(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.DoubleToSortableLong(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SortableLongToDouble(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.FloatToSortableInt(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SortableIntToFloat(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SplitLongRange(Lucene.Net.Util.NumericUtils.LongRangeBuilder,System.Int32,System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SplitIntRange(Lucene.Net.Util.NumericUtils.IntRangeBuilder,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.NumericUtils.SplitRange(System.Object,System.Int32,System.Int32,System.Int64,System.Int64)">
            <summary>
            this helper does the splitting for both 32 and 64 bit. </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.AddRange(System.Object,System.Int32,System.Int64,System.Int64,System.Int32)">
            <summary>
            Helper that delegates to correct range builder </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedLongs(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <seealso cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 64 bit
            terms with a shift value of <tt>0</tt>.
            </summary>
            <param name="termsEnum">
                     the terms enum to filter </param>
            <returns> a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 64 bit
                    terms with a shift value of <tt>0</tt>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedInts(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <seealso cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 32 bit
            terms with a shift value of <tt>0</tt>.
            </summary>
            <param name="termsEnum">
                     the terms enum to filter </param>
            <returns> a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 32 bit
                    terms with a shift value of <tt>0</tt>. </returns>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.LongRangeBuilder">
            <summary>
            Callback for <seealso cref="!:#splitLongRange"/>.
            You need to overwrite only one of the methods.
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.LongRangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Overwrite this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical (inclusive) range queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.LongRangeBuilder.AddRange(System.Int64,System.Int64,System.Int32)">
            <summary>
            Overwrite this method, if you like to receive the raw long range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.IntRangeBuilder">
            <summary>
            Callback for <seealso cref="!:#splitIntRange"/>.
            You need to overwrite only one of the methods.
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.IntRangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Overwrite this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical range (inclusive) queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.IntRangeBuilder.AddRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Overwrite this method, if you like to receive the raw int range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewLongRange(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>long</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewLongRange(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>long</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewIntRange(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>int</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewIntRange(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>int</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>double</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>double</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewFloatRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>float</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewFloatRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>float</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.AveragePayloadFunction">
             <summary>
             Calculate the final score as the average score of all payloads seen.
             <p/>
             Is thread safe and completely reusable.
            
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadFunction" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadFunction.CurrentScore(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadFunction.DocScore(System.Int32,System.String,System.Int32,System.Single)">
            <summary>
            Calculate the final score for all the payloads seen so far for this doc/field </summary>
            <param name="docId"> The current doc </param>
            <param name="field"> The current field </param>
            <param name="numPayloadsSeen"> The total number of payloads seen on this document </param>
            <param name="payloadScore"> The raw score for those payloads </param>
            <returns> The final score for the payloads </returns>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MaxPayloadFunction">
             <summary>
             Returns the maximum payload score seen, else 1 if there are no payloads on the doc.
             <p/>
             Is thread safe and completely reusable.
            
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MinPayloadFunction">
             <summary>
             Calculates the minimum payload seen
            
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadNearQuery" -->
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>
            Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>
            Base class for span-based queries. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.Bits,System.Collections.Generic.IDictionary{Lucene.Net.Index.Term,Lucene.Net.Index.TermContext})">
            <summary>
            Expert: Returns the matches for this query in an index.  Used internally
            to search for spans.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Spans.SpanQuery.Field" -->
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>
            Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. </summary>
            <param name="clauses"> the clauses to find near each other </param>
            <param name="slop"> The slop value </param>
            <param name="inOrder"> true if order is important
             </param>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.Clauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.Slop">
            <summary>
            Return the maximum number of intervening unmatched positions permitted. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.InOrder">
            <summary>
            Return true if matches are required to be in-order. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanWeight">
            <summary>
            Expert-only.  Public for use by other weight implementations
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanScorer">
            <summary>
            Public for extension only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanScorer.SloppyFreq">
            <summary>
            Returns the intermediate "sloppy freq" adjusted for edit distance
             @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadNearQuery.PayloadNearSpanScorer.ProcessPayloads(System.Collections.Generic.ICollection{System.Byte[]},System.Int32,System.Int32)" -->
        <member name="T:Lucene.Net.Search.Payloads.PayloadSpanUtil">
             <summary>
             Experimental class to get set of payloads for most standard Lucene queries.
             Operates like Highlighter - IndexReader should only contain doc of interest,
             best to use MemoryIndex.
            
             @lucene.experimental
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadSpanUtil.#ctor(Lucene.Net.Index.IndexReaderContext)" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.GetPayloadsForQuery(Lucene.Net.Search.Query)">
            <summary>
            Query should be rewritten for wild/fuzzy support.
            </summary>
            <param name="query"> rewritten query </param>
            <returns> payloads Collection </returns>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadTermQuery" -->
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>
            Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanTermQuery.Term">
            <summary>
            Return the term whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.Score">
            
             <returns> <seealso cref="!:#getSpanScore()"/> * <seealso cref="!:#getPayloadScore()"/> </returns>
             <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.SpanScore" -->
        <member name="P:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.PayloadScore">
            <summary>
            The score for the payload
            </summary>
            <returns> The score, as calculated by
                    <seealso cref="!:PayloadFunction#docScore(int, String, int, float)"/> </returns>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePositions">
            <summary>
            Position of a term in a document that takes into account the term offset within the phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.NextPosition">
            <summary>
            Go to next location of this term current document, and set
            <code>position</code> as <code>location - offset</code>, so that a
            matching exact phrase is easily identified when all PhrasePositions
            have exactly the same <code>position</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.ToString">
            <summary>
            for debug purposes </summary>
        </member>
        <member name="T:Lucene.Net.Search.PositiveScoresOnlyCollector">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Collector"/> implementation which wraps another
            <seealso cref="T:Lucene.Net.Search.Collector"/> and makes sure only documents with
            scores &gt; 0 are collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixFilter">
            <summary>
            A Filter that restricts search results to values that have a matching prefix in a given
            field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixFilter.ToString">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PrefixQuery" -->
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.PrefixQuery.Prefix">
            <summary>
            Returns the prefix of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixTermsEnum">
            <summary>
            Subclass of FilteredTermEnum for enumerating all terms that match the
            specified prefix filter term.
            <p>Term enumerations are always ordered by
            <seealso cref="!:#getComparator"/>.  Each term in the enumeration is
            greater than all that precede it.</p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryRescorer">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.Rescorer"/> that uses a provided Query to assign
              scores to the first-pass hits.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Rescorer" -->
        <member name="M:Lucene.Net.Search.Rescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,System.Int32)">
            <summary>
            Rescore an initial first-pass <seealso cref="T:Lucene.Net.Search.TopDocs"/>.
            </summary>
            <param name="searcher"> <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> used to produce the
              first pass topDocs </param>
            <param name="firstPassTopDocs"> Hits from the first pass
              search.  It's very important that these hits were
              produced by the provided searcher; otherwise the doc
              IDs will not match! </param>
            <param name="topN"> How many re-scored hits to return </param>
        </member>
        <member name="M:Lucene.Net.Search.Rescorer.Explain(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.Explanation,System.Int32)">
            <summary>
            Explains how the score for the specified document was
            computed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Sole constructor, passing the 2nd pass query to
             assign scores to the 1st pass hits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Combine(System.Single,System.Boolean,System.Single)">
            <summary>
            Implement this in a subclass to combine the first pass and
            second pass scores.  If secondPassMatches is false then
            the second pass query failed to match a hit from the
            first pass query, and you should ignore the
            secondPassScore.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,Lucene.Net.Search.Query,System.Double,System.Int32)">
            <summary>
            Sugar API, calling {#rescore} using a simple linear
             combination of firstPassScore + weight * secondPassScore
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryWrapperFilter" -->
        <member name="M:Lucene.Net.Search.QueryWrapperFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.QueryWrapperFilter.Query">
            <summary>
            returns the inner Query </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.RegexpQuery" -->
        <member name="F:Lucene.Net.Search.RegexpQuery.defaultProvider">
            <summary>
            A provider that provides no named automata
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            <p>
            By default, all regular expression features are enabled.
            </p>
            </summary>
            <param name="term"> regular expression. </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
            <param name="term"> regular expression. </param>
            <param name="flags"> optional RegExp features from <seealso cref="T:Lucene.Net.Util.Automaton.RegExp"/> </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.Automaton.AutomatonProvider)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
            <param name="term"> regular expression. </param>
            <param name="flags"> optional RegExp features from <seealso cref="T:Lucene.Net.Util.Automaton.RegExp"/> </param>
            <param name="provider"> custom AutomatonProvider for named automata </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.AutomatonProvider">
             <summary>
             Automaton provider for <code>RegExp.</code>
             <seealso cref="!:RegExp#toAutomaton(AutomatonProvider)"/>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.AutomatonProvider.GetAutomaton(System.String)">
            <summary>
            Returns automaton of the given name.
            </summary>
            <param name="name"> automaton name </param>
            <returns> automaton </returns>
            <exception cref="!:IOException"> if errors occur </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqExclScorer" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Construct a <code>ReqExclScorer</code>. </summary>
            <param name="reqScorer"> The scorer that must match, except where </param>
            <param name="exclDisi"> indicates exclusion. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.Score">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> The score of the required scorer. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqOptSumScorer" -->
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.ReqScorer">
            <summary>
            The scorers passed from the constructor.
            These are set to null as soon as their next() or skipTo() returns false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>
            Construct a <code>ReqOptScorer</code>. </summary>
            <param name="reqScorer"> The required scorer. this must match. </param>
            <param name="optScorer"> The optional scorer. this is used for scoring only. </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Score">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoreCachingWrappingScorer" -->
        <member name="M:Lucene.Net.Search.ScoreCachingWrappingScorer.#ctor(Lucene.Net.Search.Scorer)">
            <summary>
            Creates a new instance by wrapping the given scorer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoringRewrite`1" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.ScoringRewrite`1.SCORING_BOOLEAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.ScoringRewrite`1.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE" -->
        <member name="M:Lucene.Net.Search.ScoringRewrite`1.CheckMaxClauseCount(System.Int32)">
            <summary>
            this method is called after every new term to check if the number of max clauses
            (e.g. in BooleanQuery) is not exceeded. Throws the corresponding <seealso cref="!:RuntimeException"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoringRewrite`1.TermFreqBoostByteStart">
            <summary>
            Special implementation of BytesStartArray that keeps parallel arrays for boost and docFreq </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SearcherFactory" -->
        <member name="M:Lucene.Net.Search.SearcherFactory.NewSearcher(Lucene.Net.Index.IndexReader)">
            <summary>
            Returns a new IndexSearcher over the given reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager">
             <summary>
             Keeps track of current plus old IndexSearchers, closing
             the old ones once they have timed out.
            
             Use it like this:
            
             <pre class="prettyprint">
               SearcherLifetimeManager mgr = new SearcherLifetimeManager();
             </pre>
            
             Per search-request, if it's a "new" search request, then
             obtain the latest searcher you have (for example, by
             using <seealso cref="T:Lucene.Net.Search.SearcherManager"/>), and then record this
             searcher:
            
             <pre class="prettyprint">
               // Record the current searcher, and save the returend
               // token into user's search results (eg as a  hidden
               // HTML form field):
               long token = mgr.record(searcher);
             </pre>
            
             When a follow-up search arrives, for example the user
             clicks next page, drills down/up, etc., take the token
             that you saved from the previous search and:
            
             <pre class="prettyprint">
               // If possible, obtain the same searcher as the last
               // search:
               IndexSearcher searcher = mgr.acquire(token);
               if (searcher != null) {
                 // Searcher is still here
                 try {
                   // do searching...
                 } finally {
                   mgr.release(searcher);
                   // Do not use searcher after this!
                   searcher = null;
                 }
               } else {
                 // Searcher was pruned -- notify user session timed
                 // out, or, pull fresh searcher again
               }
             </pre>
            
             Finally, in a separate thread, ideally the same thread
             that's periodically reopening your searchers, you should
             periodically prune old searchers:
            
             <pre class="prettyprint">
               mgr.prune(new PruneByAge(600.0));
             </pre>
            
             <p><b>NOTE</b>: keeping many searchers around means
             you'll use more resources (open files, RAM) than a single
             searcher.  However, as long as you are using {@link
             DirectoryReader#openIfChanged(DirectoryReader)}, the searchers
             will usually share almost all segments and the added resource usage
             is contained.  When a large merge has completed, and
             you reopen, because that is a large change, the new
             searcher will use higher additional RAM than other
             searchers; but large merges don't complete very often and
             it's unlikely you'll hit two of them in your expiration
             window.  Still you should budget plenty of heap in the
             JVM to have a good safety margin.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Record(Lucene.Net.Search.IndexSearcher)">
             <summary>
             Records that you are now using this IndexSearcher.
              Always call this when you've obtained a possibly new
              <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>, for example from {@link
              SearcherManager}.  It's fine if you already passed the
              same searcher to this method before.
            
              <p>this returns the long token that you can later pass
              to <seealso cref="!:#acquire"/> to retrieve the same IndexSearcher.
              You should record this long token in the search results
              sent to your user, such that if the user performs a
              follow-on action (clicks next page, drills down, etc.)
              the token is returned.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Acquire(System.Int64)">
             <summary>
             Retrieve a previously recorded <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>, if it
              has not yet been closed
            
              <p><b>NOTE</b>: this may return null when the
              requested searcher has already timed out.  When this
              happens you should notify your user that their session
              timed out and that they'll have to restart their
              search.</p>
            
              <p>If this returns a non-null result, you must match
              later call <seealso cref="!:#release"/> on this searcher, best
              from a finally clause.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Release(Lucene.Net.Search.IndexSearcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Prune(Lucene.Net.Search.SearcherLifetimeManager.Pruner)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Dispose" -->
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.Pruner">
            <summary>
            See <seealso cref="!:#prune"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Pruner.DoPrune(System.Double,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Return true if this searcher should be removed. </summary>
             <param name="ageSec"> how much time has passed since this
                    searcher was the current (live) searcher </param>
             <param name="searcher"> Searcher
             </param>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.PruneByAge">
            <summary>
            Simple pruner that drops any searcher older by
             more than the specified seconds, than the newest
             searcher.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SearcherManager" -->
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new SearcherManager from the given
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     the IndexWriter to open the IndexReader from. </param>
            <param name="applyAllDeletes">
                     If <code>true</code>, all buffered deletes will be applied (made
                     visible) in the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> / <seealso cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <code>false</code>, the deletes may or may not be applied, but
                     remain buffered (in IndexWriter) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <code>false</code>. See
                     <seealso cref="!:DirectoryReader#openIfChanged(DirectoryReader, IndexWriter, boolean)"/>. </param>
            <param name="searcherFactory">
                     An optional <seealso cref="F:Lucene.Net.Search.SearcherManager.SearcherFactory"/>. Pass <code>null</code> if you
                     don't require the searcher to be warmed before going live or other
                     custom behavior.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new SearcherManager from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> the directory to open the DirectoryReader on. </param>
            <param name="searcherFactory"> An optional <seealso cref="F:Lucene.Net.Search.SearcherManager.SearcherFactory"/>. Pass
                   <code>null</code> if you don't require the searcher to be warmed
                   before going live or other custom behavior.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.GetSearcher(Lucene.Net.Search.SearcherFactory,Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: creates a searcher from the provided {@link
             IndexReader} using the provided {@link
             SearcherFactory}.  NOTE: this decRefs incoming reader
            on throwing an exception.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.SearcherManager.SearcherCurrent" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.AfterEffect" -->
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the aftereffect score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            after effect formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect">
            <summary>
            Implementation used when there is no aftereffect. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectB">
            <summary>
            Model of the information gain based on the ratio of two Bernoulli processes.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectB.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectL">
            <summary>
            Model of the information gain based on Laplace's law of succession.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModel" -->
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the informative content score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score.
            <p>Most basic models use the number of documents and the total term
            frequency to compute Inf<sub>1</sub>. this method provides a generic
            explanation for such models. Subclasses that use other statistics must
            override this method.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            basic model formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelBE">
            <summary>
            Limiting form of the Bose-Einstein model. The formula used in Lucene differs
            slightly from the one in the original paper: {@code F} is increased by {@code tfn+1}
            and {@code N} is increased by {@code F}
            @lucene.experimental
            NOTE: in some corner cases this model may give poor performance with Normalizations that
            return large values for {@code tfn} such as NormalizationH3. Consider using the
            geometric approximation (<seealso cref="T:Lucene.Net.Search.Similarities.BasicModelG"/>) instead, which provides the same relevance
            but with less practical problems.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.f(System.Double,System.Double)">
            <summary>
            The <em>f</em> helper function defined for <em>B<sub>E</sub></em>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModelD" -->
        <member name="M:Lucene.Net.Search.Similarities.BasicModelD.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelG">
            <summary>
            Geometric as limiting form of the Bose-Einstein model.  The formula used in Lucene differs
            slightly from the one in the original paper: {@code F} is increased by {@code 1}
            and {@code N} is increased by {@code F}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelG.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIF">
            <summary>
            An approximation of the <em>I(n<sub>e</sub>)</em> model.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIn">
            <summary>
            The basic tf-idf model of randomness.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIn.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIne">
            <summary>
            Tf-idf model of randomness, based on a mixture of Poisson and inverse
            document frequency.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIne.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModelP" -->
        <member name="F:Lucene.Net.Search.Similarities.BasicModelP.LOG2_E">
            <summary>
            {@code log2(Math.E)}, precomputed. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelP.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicStats">
            <summary>
            Stores all statistics commonly used ranking methods.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity.SimWeight">
            <summary>
            Stores the weight for a query across the indexed collection. this abstract
            implementation is empty; descendants of {@code Similarity} should
            subclass {@code SimWeight} and define the statistics they require in the
            subclass. Examples include idf, average field length, etc.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Similarity" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.ComputeWeight(System.Single,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])">
            <summary>
            Compute any collection-level weight (e.g. IDF, average document length, etc) needed for scoring a query.
            </summary>
            <param name="queryBoost"> the query-time boost. </param>
            <param name="collectionStats"> collection-level statistics, such as the number of tokens in the collection. </param>
            <param name="termStats"> term-level statistics, such as the document frequency of a term across the collection. </param>
            <returns> SimWeight object with the information this Similarity needs to score a query. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.DoSimScorer(Lucene.Net.Search.Similarities.Similarity.SimWeight,Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.Similarities.Similarity.SimScorer"/> to score matching documents from a segment of the inverted index. </summary>
            <param name="weight"> collection information from <seealso cref="!:#computeWeight(float, CollectionStatistics, TermStatistics...)"/> </param>
            <param name="context"> segment of the inverted index to be scored. </param>
            <returns> SloppySimScorer for scoring documents across <code>context</code> </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Similarity.SimScorer" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Score(System.Int32,System.Single)">
            <summary>
            Score a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> sloppy term frequency </param>
            <returns> document's score </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputeSlopFactor(System.Int32)">
            <summary>
            Computes the amount of a sloppy phrase match, based on an edit distance. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputePayloadFactor(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Explain(System.Int32,Lucene.Net.Search.Explanation)">
            <summary>
            Explain the score for a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> Explanation of how the sloppy term frequency was computed </param>
            <returns> document's score </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity.SimWeight">
            <summary>
            Stores the weight for a query across the indexed collection. this abstract
            implementation is empty; descendants of {@code Similarity} should
            subclass {@code SimWeight} and define the statistics they require in the
            subclass. Examples include idf, average field length, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.SimWeight.Normalize(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.Similarity.SimWeight.ValueForNormalization" -->
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.NumberOfDocuments_Renamed">
            <summary>
            The number of documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.NumberOfFieldTokens_Renamed">
            <summary>
            The total number of tokens in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.AvgFieldLength_Renamed">
            <summary>
            The average field length. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.DocFreq_Renamed">
            <summary>
            The document frequency. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.TotalTermFreq_Renamed">
            <summary>
            The total number of occurrences of this term across all documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.QueryBoost">
            <summary>
            Query's inner boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.TopLevelBoost">
            <summary>
            Any outer query's boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.TotalBoost_Renamed">
            <summary>
            For most Similarities, the immediate and the top level query boosts are
            not handled differently. Hence, this field is just the product of the
            other two.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.#ctor(System.String,System.Single)">
            <summary>
            Constructor. Sets the query boost. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.RawNormalizationValue">
            <summary>
            Computes the raw normalization value. this basic implementation returns
            the query boost. Subclasses may override this method to include other
            factors (such as idf), or to save the value for inclusion in
            <seealso cref="!:#normalize(float, float)"/>, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.Normalize(System.Single,System.Single)">
            <summary>
            No normalization is done. {@code topLevelBoost} is saved in the object,
            however.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.NumberOfDocuments">
            <summary>
            Returns the number of documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BasicStats.NumberOfFieldTokens" -->
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.AvgFieldLength">
            <summary>
            Returns the average field length. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.DocFreq">
            <summary>
            Returns the document frequency. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term across all documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BasicStats.ValueForNormalization" -->
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalBoost">
            <summary>
            Returns the total boost. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity">
            <summary>
            BM25 Similarity. Introduced in Stephen E. Robertson, Steve Walker,
            Susan Jones, Micheline Hancock-Beaulieu, and Mike Gatford. Okapi at TREC-3.
            In Proceedings of the Third <b>T</b>ext <b>RE</b>trieval <b>C</b>onference (TREC 1994).
            Gaithersburg, USA, November 1994.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor(System.Single,System.Single)">
            <summary>
            BM25 with the supplied parameter values. </summary>
            <param name="k1"> Controls non-linear term frequency normalization (saturation). </param>
            <param name="b"> Controls to what degree document length normalizes tf values. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor" -->
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <code>log(1 + (numDocs - docFreq + 0.5)/(docFreq + 0.5))</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <code>1</code> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.AvgFieldLength(Lucene.Net.Search.CollectionStatistics)">
            <summary>
            The default implementation computes the average as <code>sumTotalTermFreq / maxDoc</code>,
            or returns <code>1</code> if the index does not store sumTotalTermFreq (Lucene 3.x indexes
            or any field that omits frequency information).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.EncodeNormValue(System.Single,System.Int32)">
            <summary>
            The default implementation encodes <code>boost / sqrt(length)</code>
            with <seealso cref="!:SmallFloat#floatToByte315(float)"/>.  this is compatible with
            Lucene's default implementation.  If you change this, then you should
            change <seealso cref="!:#decodeNormValue(byte)"/> to match.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.DecodeNormValue(System.SByte)">
            <summary>
            The default implementation returns <code>1 / f<sup>2</sup></code>
            where <code>f</code> is <seealso cref="!:SmallFloat#byte315ToFloat(byte)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.DiscountOverlaps_Renamed">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])" -->
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.DiscountOverlaps">
            <summary>
            Sets whether overlap tokens (Tokens with 0 position increment) are
             ignored when computing norm.  By default this is true, meaning overlap
             tokens do not count when computing norms.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BM25Similarity.K1" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BM25Similarity.B" -->
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats">
            <summary>
            Collection statistics for the BM25 model. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Idf">
            <summary>
            BM25's idf </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Avgdl">
            <summary>
            The average document length. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.QueryBoost">
            <summary>
            query's inner boost </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.TopLevelBoost">
            <summary>
            query's outer boost (only for explain) </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Weight">
            <summary>
            weight (idf * boost) </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Field">
            <summary>
            field name, for pulling norms </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Cache">
            <summary>
            precomputed norm[256] with k1 * ((1 - b) + b * dl / avgdl) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.DefaultSimilarity" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.TFIDFSimilarity" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Idf(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.DecodeNormValue(System.Int64)" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.EncodeNormValue(System.Single)">
            <summary>
            Encodes a normalization factor for storage in an index. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.SloppyFreq(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload.  Implementations
            are responsible for interpreting what is in the payload.  Lucene makes no assumptions about
            what is in the byte array.
            </summary>
            <param name="doc"> The docId currently being scored. </param>
            <param name="start"> The start position of the payload </param>
            <param name="end"> The end position of the payload </param>
            <param name="payload"> The payload byte array to be scored </param>
            <returns> An implementation dependent float to be used as a scoring factor </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats">
            <summary>
            Collection statistics for the TF-IDF model. The only statistic of interest
            to this model is idf.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats.Idf">
            <summary>
            The idf and its explanation </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>
            Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>
            Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DefaultSimilarity.DecodeNormValue(System.Int64)" -->
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)">
             <summary>
             Implemented as
              <code>state.getBoost()*lengthNorm(numTerms)</code>, where
              <code>numTerms</code> is <seealso cref="!:FieldInvertState#getLength()"/> if {@link
              #setDiscountOverlaps} is false, else it's {@link
              FieldInvertState#getLength()} - {@link
              FieldInvertState#getNumOverlap()}.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Tf(System.Single)">
            <summary>
            Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <code>1</code> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.DiscountOverlaps_Renamed">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.DefaultSimilarity.DiscountOverlaps" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.DFRSimilarity" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.SimilarityBase" -->
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.LOG_2">
            <summary>
            For <seealso cref="!:#log2(double)"/>. Precomputed for efficiency reasons. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.DiscountOverlaps_Renamed">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.NewStats(System.String,System.Single)">
            <summary>
            Factory method to return a custom stats object </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Fills all member fields defined in {@code BasicStats} in {@code stats}.
             Subclasses can override this method to fill additional stats.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Scores the document {@code doc}.
            <p>Subclasses must apply their scoring formula in this class.</p> </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
            <returns> the score. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Explanation,Lucene.Net.Search.Similarities.BasicStats,System.Int32,System.Single,System.Single)">
            <summary>
            Subclasses should implement this method to explain the score. {@code expl}
            already contains the score, the name of the class and the doc id, as well
            as the term frequency and its explanation; subclasses can add additional
            clauses to explain details of their scoring formulae.
            <p>The default implementation does nothing.</p>
            </summary>
            <param name="expl"> the explanation to extend with details. </param>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Int32,Lucene.Net.Search.Explanation,System.Single)">
            <summary>
            Explains the score. The implementation here provides a basic explanation
            in the format <em>score(name-of-similarity, doc=doc-id,
            freq=term-frequency), computed from:</em>, and
            attaches the score (computed via the <seealso cref="!:#score(BasicStats, float, float)"/>
            method) and the explanation for the term frequency. Subclasses content with
            this format may add additional details in
            <seealso cref="!:#explain(Explanation, BasicStats, int, float, float)"/>.
            </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency and its explanation. </param>
            <param name="docLen"> the document length. </param>
            <returns> the explanation. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ToString">
            <summary>
            Subclasses must override this method to return the name of the Similarity
            and preferably the values of parameters (if any) as well.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.NORM_TABLE">
            <summary>
            Norm -> document length map. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ComputeNorm(Lucene.Net.Index.FieldInvertState)">
            <summary>
            Encodes the document length in the same way as <seealso cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.SimilarityBase.DecodeNormValue(System.SByte)" -->
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.EncodeNormValue(System.Single,System.Single)">
            <summary>
            Encodes the length to a byte via SmallFloat. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Log2(System.Double)">
            <summary>
            Returns the base two logarithm of {@code x}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.SimilarityBase.DiscountOverlaps" -->
        <member name="T:Lucene.Net.Search.Similarities.SimilarityBase.BasicSimScorer">
            <summary>
            Delegates the <seealso cref="!:#score(int, float)"/> and
            <seealso cref="!:#explain(int, Explanation)"/> methods to
            <seealso cref="!:SimilarityBase#score(BasicStats, float, float)"/> and
            <seealso cref="!:SimilarityBase#explain(BasicStats, int, Explanation, float)"/>,
            respectively.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.BasicModel_Renamed">
            <summary>
            The basic model for information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.AfterEffect_Renamed">
            <summary>
            The first normalization of the information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.Normalization_Renamed">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DFRSimilarity.#ctor(Lucene.Net.Search.Similarities.BasicModel,Lucene.Net.Search.Similarities.AfterEffect,Lucene.Net.Search.Similarities.Normalization)" -->
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.BasicModel">
            <summary>
            Returns the basic model of information content
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.AfterEffect">
            <summary>
            Returns the first normalization
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.Normalization">
            <summary>
            Returns the second normalization
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Distribution" -->
        <member name="M:Lucene.Net.Search.Similarities.Distribution.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Computes the score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Explains the score. Returns the name of the model only, since
            both {@code tfn} and {@code lambda} are explained elsewhere.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.ToString">
            <summary>
            Subclasses must override this method to return the name of the
            distribution.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionLL">
            <summary>
            Log-logistic distribution.
            <p>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionLL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionSPL">
            <summary>
            The smoothed power-law (SPL) distribution for the information-based framework
            that is described in the original paper.
            <p>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionSPL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.IBSimilarity" -->
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.Distribution_Renamed">
            <summary>
            The probabilistic distribution used to model term occurrence. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.IBSimilarity.Lambda_Renamed" -->
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.Normalization_Renamed">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.IBSimilarity.#ctor(Lucene.Net.Search.Similarities.Distribution,Lucene.Net.Search.Similarities.Lambda,Lucene.Net.Search.Similarities.Normalization)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.IBSimilarity.ToString" -->
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Distribution">
            <summary>
            Returns the distribution
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Lambda">
            <summary>
            Returns the distribution's lambda parameter
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Normalization">
            <summary>
            Returns the term frequency normalization
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Lambda" -->
        <member name="M:Lucene.Net.Search.Similarities.Lambda.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.CalculateLambda(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.Explain(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Explains the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.ToString">
            <summary>
            Subclasses must override this method to return the code of the lambda
            formula. Since the original paper is not very clear on this matter, and
            also uses the DFR naming scheme incorrectly, the codes here were chosen
            arbitrarily.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaDF">
            <summary>
            Computes lambda as {@code docFreq+1 / numberOfDocuments+1}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaDF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaTTF">
            <summary>
            Computes lambda as {@code totalTermFreq+1 / numberOfDocuments+1}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaTTF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMDirichletSimilarity">
             <summary>
             Bayesian smoothing using Dirichlet priors. From Chengxiang Zhai and John
             Lafferty. 2001. A study of smoothing methods for language models applied to
             Ad Hoc information retrieval. In Proceedings of the 24th annual international
             ACM SIGIR conference on Research and development in information retrieval
             (SIGIR '01). ACM, New York, NY, USA, 334-342.
             <p>
             The formula as defined the paper assigns a negative score to documents that
             contain the term, but with fewer occurrences than predicted by the collection
             language model. The Lucene implementation returns {@code 0} for such
             documents.
             </p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity">
             <summary>
             Abstract superclass for language modeling Similarities. The following inner
             types are introduced:
             <ul>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats"/>, which defines a new statistic, the probability that
               the collection language model generates the current term;</li>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel"/>, which is a strategy interface for object that
               compute the collection language model {@code p(w|C)};</li>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel"/>, an implementation of the former, that
               computes the term probability as the number of occurrences of the term in the
               collection, divided by the total number of tokens.</li>
             </ul>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.collectionModel">
            <summary>
            The collection model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel)">
            <summary>
            Creates a new instance with the specified collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor">
            <summary>
            Creates a new instance with the default collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Computes the collection probability of the current term in addition to the
            usual statistics.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMSimilarity.ToString" -->
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.Name">
            <summary>
            Returns the name of the LM method. The values of the parameters should be
            included as well.
            <p>Used in <seealso cref="!:#toString()"/></p>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats">
            <summary>
            Stores the collection distribution of the current term. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.CollectionProbability_Renamed">
            <summary>
            The probability that the current term is generated by the collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.#ctor(System.String,System.Single)">
            <summary>
            Creates LMStats for the provided field and query-time boost
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.CollectionProbability">
            <summary>
            Returns the probability that the current term is generated by the
            collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel">
            <summary>
            A strategy for computing the collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel.ComputeProbability(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the probability {@code p(w|C)} according to the language model
            strategy for the current term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel.Name">
            <summary>
            The name of the collection model strategy. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel">
            <summary>
            Models {@code p(w|C)} as the number of occurrences of the term in the
            collection, divided by the total number of tokens {@code + 1}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.LMDirichletSimilarity.Mu_Renamed" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.LMDirichletSimilarity.Mu" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.Lambda_Renamed" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.CollectionModel,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.Lambda" -->
        <member name="T:Lucene.Net.Search.Similarities.MultiSimilarity">
            <summary>
            Implements the CombSUM method for combining evidence from multiple
            similarity values described in: Joseph A. Shaw, Edward A. Fox.
            In Text REtrieval Conference (1993), pp. 243-252
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.MultiSimilarity.Sims">
            <summary>
            the sub-similarities used to create the combined score </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.MultiSimilarity.#ctor(Lucene.Net.Search.Similarities.Similarity[])">
            <summary>
            Creates a MultiSimilarity which will sum the scores
            of the provided <code>sims</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Normalization" -->
        <member name="M:Lucene.Net.Search.Similarities.Normalization.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Tfn(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns the normalized term frequency. </summary>
            <param name="len"> the field length.  </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns an explanation for the normalized term frequency.
            <p>The default normalization methods use the field length of the document
            and the average field length to compute the normalized term frequency.
            this method provides a generic explanation for such methods.
            Subclasses that use other statistics must override this method.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            normalization formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization">
            <summary>
            Implementation used when there is no normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.NoNormalization.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH1">
            <summary>
            Normalization model that assumes a uniform distribution of the term frequency.
            <p>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, <a href="http://dl.acm.org/citation.cfm?id=1835490">
            information-based models</a> (see <seealso cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/>) introduced a
            multiplying factor.
            The default value for the {@code c} parameter is {@code 1}.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor(System.Single)">
            <summary>
            Creates NormalizationH1 with the supplied parameter <code>c</code>. </summary>
            <param name="c"> hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH1(float) NormalizationH1(1)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH1.C" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH2">
            <summary>
            Normalization model in which the term frequency is inversely related to the
            length.
            <p>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, the <a href="http://theses.gla.ac.uk/1570/">thesis</a>
            introduces the parameterized variant.
            The default value for the {@code c} parameter is {@code 1}.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor(System.Single)">
            <summary>
            Creates NormalizationH2 with the supplied parameter <code>c</code>. </summary>
            <param name="c"> hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH2(float) NormalizationH2(1)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH2.C" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH3">
            <summary>
            Dirichlet Priors normalization
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH3(float) NormalizationH3(800)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH3.Mu" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationZ">
            <summary>
            Pareto-Zipf Normalization
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationZ(float) NormalizationZ(0.3)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor(System.Single)">
            <summary>
            Creates NormalizationZ with the supplied parameter <code>z</code>. </summary>
            <param name="z"> represents <code>A/(A+1)</code> where <code>A</code>
                     measures the specificity of the language. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationZ.Z" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper" -->
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.Get(System.String)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Search.Similarities.Similarity"/> for scoring a field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.PhraseFreq" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvancePP(Lucene.Net.Search.PhrasePositions)">
            <summary>
            advance a PhrasePosition and update 'end', return false if exhausted </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRpts(Lucene.Net.Search.PhrasePositions)">
            <summary>
            pp was just advanced. If that caused a repeater collision, resolve by advancing the lesser
            of the two colliding pps. Note that there can only be one collision, as by the initialization
            there were no collisions before pp was advanced.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Lesser(Lucene.Net.Search.PhrasePositions,Lucene.Net.Search.PhrasePositions)">
            <summary>
            compare two pps, but only by position and offset </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Collide(Lucene.Net.Search.PhrasePositions)">
            <summary>
            index of a pp2 colliding with pp, or -1 if none </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitPhrasePositions" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitSimple">
            <summary>
            no repeats: simplest case, and most common. It is important to keep this piece of the code simple and efficient </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitComplex">
            <summary>
            with repeats: not so simple. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PlaceFirstPositions">
            <summary>
            move all PPs to their first position </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.FillQueue">
            <summary>
            Fill the queue (all pps are already placed </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRepeatGroups" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitFirstTime" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.SortRptGroups(System.Collections.Generic.List{System.Collections.Generic.List{Lucene.Net.Search.PhrasePositions}})">
            <summary>
            sort each repetition group by (query) offset.
            Done only once (at first doc) and allows to initialize faster for each doc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.GatherRptGroups(Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            Detect repetition groups. Done once - for first doc </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TpPos(Lucene.Net.Search.PhrasePositions)">
            <summary>
            Actual position in doc of a PhrasePosition, relies on that position = tpPos - offset) </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingTerms">
            <summary>
            find repeating terms and assign them ordinal values </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingPPs(Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            find repeating pps, and for each, if has multi-terms, update this.hasMultiTermRpts </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PpTermsBitSets(Lucene.Net.Search.PhrasePositions[],Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            bit-sets - for each repeating pp, for each of its repeating terms, the term ordinal values is set </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.UnionTermGroups(System.Collections.Generic.List{Lucene.Net.Util.FixedBitSet})">
            <summary>
            union (term group) bit-sets until they are disjoint (O(n^^2)), and each group have different terms </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TermGroups(Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}},System.Collections.Generic.List{Lucene.Net.Util.FixedBitSet})">
            <summary>
            map each term to the single group that contains it </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary>
            Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            <seealso cref="!:IndexSearcher#search(Query,int) IndexSearcher#search()"/>without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>
            Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary>
            Sorts by computed relevance. this is the same sort criteria as calling
            <seealso cref="!:IndexSearcher#search(Query,int) IndexSearcher#search()"/>without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>
            Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>
            Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of SortField objects used in this sort criteria
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites the SortFields in this Sort, returning a new Sort if any of the fields
            changes during their rewriting.
            </summary>
            <param name="searcher"> IndexSearcher to use in the rewriting </param>
            <returns> {@code this} if the Sort/Fields have not changed, or a new Sort if there
                   is a change </returns>
            <exception cref="!:IOException"> Can be thrown by the rewriting
            @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.NeedsScores">
            <summary>
            Returns true if the relevance score is needed to sort documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortField" -->
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>
            Represents sorting by document score (relevance). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>
            Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortField.Type_e)">
            <summary>
            Creates a sort by terms in the given field with the type of term
            values explicitly given. </summary>
            <param name="field">  Name of field to sort by.  Can be <code>null</code> if
                          <code>type</code> is SCORE or DOC. </param>
            <param name="type">   Type of values in the terms. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortField.Type_e,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field with the
            type of term values explicitly given. </summary>
            <param name="field">  Name of field to sort by.  Can be <code>null</code> if
                          <code>type</code> is SCORE or DOC. </param>
            <param name="type">   Type of values in the terms. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser)">
            <summary>
            Creates a sort by terms in the given field, parsed
            to numeric values using a custom <seealso cref="!:IFieldCache.Parser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be null. </param>
            <param name="parser"> Instance of a <seealso cref="!:IFieldCache.Parser"/>,
             which must subclass one of the existing numeric
             parsers from <seealso cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <exception cref="!:IllegalArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is null </exception>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field, parsed
            to numeric values using a custom <seealso cref="!:IFieldCache.Parser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be null. </param>
            <param name="parser"> Instance of a <seealso cref="!:IFieldCache.Parser"/>,
             which must subclass one of the existing numeric
             parsers from <seealso cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
            <exception cref="!:IllegalArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is null </exception>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_FIRST">
            <summary>
            Pass this to <seealso cref="!:#setMissingValue"/> to have missing
             string values sort first.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_LAST">
            <summary>
            Pass this to <seealso cref="!:#setMissingValue"/> to have missing
             string values sort last.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparatorSource)">
            <summary>
            Creates a sort with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <code>null</code>. </param>
            <param name="comparator"> Returns a comparator for sorting hits. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparatorSource,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <code>null</code>. </param>
            <param name="comparator"> Returns a comparator for sorting hits. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this.  If a
             <seealso cref="T:Lucene.Net.Search.FieldComparatorSource"/> or {@link
             FieldCache.Parser} was provided, it must properly
             implement equals (unless a singleton is always used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetHashCode">
            <summary>
            Returns true if <code>o</code> is equal to this.  If a
             <seealso cref="T:Lucene.Net.Search.FieldComparatorSource"/> or {@link
             FieldCache.Parser} was provided, it must properly
             implement hashCode (unless a singleton is always
             used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetComparator(System.Int32,System.Int32)">
             <summary>
             Returns the <seealso cref="T:Lucene.Net.Search.FieldComparator"/> to use for
             sorting.
            
             @lucene.experimental
             </summary>
             <param name="numHits"> number of top hits the queue will store </param>
             <param name="sortPos"> position of this SortField within {@link
               Sort}.  The comparator is primary if sortPos==0,
               secondary if sortPos==1, etc.  Some comparators can
               optimize themselves when they are the primary sort. </param>
             <returns> <seealso cref="T:Lucene.Net.Search.FieldComparator"/> to use when sorting </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites this SortField, returning a new SortField if a change is made.
            Subclasses should override this define their rewriting behavior when this
            SortField is of type <seealso cref="!:SortField.Type#REWRITEABLE"/>
            </summary>
            <param name="searcher"> IndexSearcher to use during rewriting </param>
            <returns> New rewritten SortField, or {@code this} if nothing has changed. </returns>
            <exception cref="!:IOException"> Can be thrown by the rewriting
            @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Search.SortField.NeedsScores">
            <summary>
            Whether the relevance score is needed to sort documents. </summary>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Field">
            <summary>
            Returns the name of the field.  Could return <code>null</code>
            if the sort is by SCORE or DOC. </summary>
            <returns> Name of field, possibly <code>null</code>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Type">
            <summary>
            Returns the type of contents in the field. </summary>
            <returns> One of the constants SCORE, DOC, STRING, INT or FLOAT. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Parser">
            <summary>
            Returns the instance of a <seealso cref="T:Lucene.Net.Search.IFieldCache"/> parser that fits to the given sort type.
            May return <code>null</code> if no parser was specified. Sorting is using the default parser then. </summary>
            <returns> An instance of a <seealso cref="T:Lucene.Net.Search.IFieldCache"/> parser, or <code>null</code>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Reverse">
            <summary>
            Returns whether the sort should be reversed. </summary>
            <returns>  True if natural order should be reversed. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.ComparatorSource">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Search.FieldComparatorSource"/> used for
            custom sorting
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortField.Type_e">
            <summary>
            Specifies the type of the terms to be sorted, or special types such as CUSTOM
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.SCORE">
            <summary>
            Sort by document score (relevance).  Sort values are Float and higher
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.DOC">
            <summary>
            Sort by document number (index order).  Sort values are Integer and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.STRING">
            <summary>
            Sort using term values as Strings.  Sort values are String and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.INT">
            <summary>
            Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.FLOAT">
            <summary>
            Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.LONG">
            <summary>
            Sort using term values as encoded Longs.  Sort values are Long and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.DOUBLE">
            <summary>
            Sort using term values as encoded Doubles.  Sort values are Double and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.SHORT">
            <summary>
            Sort using term values as encoded Shorts.  Sort values are Short and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.CUSTOM">
            <summary>
            Sort using a custom Comparator.  Sort values are any Comparable and
            sorting is done according to natural order.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.BYTE">
            <summary>
            Sort using term values as encoded Bytes.  Sort values are Byte and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.STRING_VAL">
            <summary>
            Sort using term values as Strings, but comparing by
            value (using String.compareTo) for all comparisons.
            this is typically slower than <seealso cref="!:#STRING"/>, which
            uses ordinals to do the sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.BYTES">
            <summary>
            Sort use byte[] index values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.Type_e.REWRITEABLE">
            <summary>
            Force rewriting of SortField using <seealso cref="!:SortField#rewrite(IndexSearcher)"/>
            before it can be used for sorting
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortRescorer">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Rescorer"/> that re-sorts according to a provided
            Sort.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortRescorer.#ctor(Lucene.Net.Search.Sort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.FieldMaskingSpanQuery">
             <summary>
             <p>Wrapper to allow <seealso cref="T:Lucene.Net.Search.Spans.SpanQuery"/> objects participate in composite
             single-field SpanQueries by 'lying' about their search field. That is,
             the masked SpanQuery will function as normal,
             but <seealso cref="!:SpanQuery#getField()"/> simply hands back the value supplied
             in this class's constructor.</p>
            
             <p>this can be used to support Queries like <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> or
             <seealso cref="T:Lucene.Net.Search.Spans.SpanOrQuery"/> across different fields, which is not ordinarily
             permitted.</p>
            
             <p>this can be useful for denormalized relational data: for example, when
             indexing a document with conceptually many 'children': </p>
            
             <pre>
              teacherid: 1
              studentfirstname: james
              studentsurname: jones
            
              teacherid: 2
              studenfirstname: james
              studentsurname: smith
              studentfirstname: sally
              studentsurname: jones
             </pre>
            
             <p>a SpanNearQuery with a slop of 0 can be applied across two
             <seealso cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> objects as follows:
             <pre class="prettyprint">
                SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
                SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
                SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
                Query q = new SpanNearQuery(new SpanQuery[]{q1, q2m}, -1, false);
             </pre>
             to search for 'studentfirstname:james studentsurname:jones' and find
             teacherid 1 without matching teacherid 2 (which has a 'james' in position 0
             and 'jones' in position 1). </p>
            
             <p>Note: as <seealso cref="!:#getField()"/> returns the masked field, scoring will be
             done using the Similarity and collection statistics of the field name supplied,
             but with the term statistics of the real field. this may lead to exceptions,
             poor performance, and unexpected scoring behaviour.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.NearSpansOrdered" -->
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>
            Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>
            Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>
            Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Start">
            <summary>
            Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.End">
            <summary>
            Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.Cost" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Spans.Spans.Payload" -->
        <member name="P:Lucene.Net.Search.Spans.Spans.PayloadAvailable">
            <summary>
            Checks if a payload can be loaded at this position.
            <p/>
            Payloads can only be loaded once per call to
            <seealso cref="!:#next()"/>.
            </summary>
            <returns> true if there is a payload available at this position that can be loaded </returns>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.subSpans">
            <summary>
            The spans in the same order as the SpanNearQuery </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.InSameDoc">
            <summary>
            Indicates that all subSpans have same doc() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.AdvanceAfterOrdered">
            <summary>
            Advances the subSpans to just after an ordered match with a minimum slop
            that is smaller than the slop allowed by the SpanNearQuery. </summary>
            <returns> true iff there is such a match. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ToSameDoc">
            <summary>
            Advance the subSpans to the same document </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)">
            <summary>
            Check whether two Spans in the same document are ordered. </summary>
            <returns> true iff spans1 starts before spans2
                         or the spans start at the same position,
                         and spans1 ends before spans2. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like <seealso cref="!:#docSpansOrdered(Spans,Spans)"/>, but use the spans
            starts and ends as parameters.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.StretchToOrder">
            <summary>
            Order the subSpans within the same document by advancing all later spans
            after the previous one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ShrinkToAfterShortestMatch">
            <summary>
            The subSpans are ordered in the same doc, so there is a possible match.
            Compute the slop while making the match as short as possible by advancing
            all subSpans except the last one in reverse order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered">
             <summary>
             Similar to <seealso cref="T:Lucene.Net.Search.Spans.NearSpansOrdered"/>, but for the unordered case.
            
             Expert:
             Only public for subclassing.  Most implementations should not need this class
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered.SpansCell">
            <summary>
            Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
             <summary>
             Matches spans near the beginning of a field.
             <p/>
             this class is a simple extension of <seealso cref="T:Lucene.Net.Search.Spans.SpanPositionRangeQuery"/> in that it assumes the
             start to be zero and only checks the end boundary.
            
            
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanPositionRangeQuery" -->
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery">
             <summary>
             Base class for filtering a SpanQuery based on the position of a match.
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptPosition(Lucene.Net.Search.Spans.Spans)" -->
        <member name="P:Lucene.Net.Search.Spans.SpanPositionCheckQuery.Match">
             <returns> the SpanQuery whose matches are filtered.
            
              </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus">
            <summary>
            Return value for <seealso cref="!:SpanPositionCheckQuery#acceptPosition(Spans)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.YES">
            <summary>
            Indicates the match should be accepted </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO">
            <summary>
            Indicates the match should be rejected </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO_AND_ADVANCE">
            <summary>
            Indicates the match should be rejected, and the enumeration should advance
            to the next document.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.Start">
            <returns> The minimum position permitted in a match </returns>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.End">
            <returns> the maximum end position permitted in a match. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.#ctor(`0)" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.SCORING_SPAN_QUERY_REWRITE" -->
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.RewriteMethod">
            <summary>
            Expert: returns the rewriteMethod
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.WrappedQuery">
            <summary>
            Returns the wrapped query </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.SpanRewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite" -->
        <member name="M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.#ctor(System.Int32)">
            <summary>
            Create a TopTermsSpanBooleanQueryRewrite for
            at most <code>size</code> terms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.Size">
            <summary>
            return the maximum priority queue size </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery">
             <summary>
             Only return those matches that have a specific payload at
             the given position.
             <p/>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanNearQuery,System.Collections.Generic.ICollection{System.Byte[]})">
            <param name="match">          The underlying <seealso cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to check </param>
            <param name="payloadToMatch"> The <seealso cref="!:java.util.Collection"/> of payloads to match </param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>
            Removes matches which overlap with another SpanQuery or
            within a x tokens before or y tokens after another SpanQuery.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code> within
            <code>dist</code> tokens of <code>include</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32,System.Int32)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code> within
            <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Include">
            <summary>
            Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Exclude">
            <summary>
            Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>
            Matches the union of its clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>
            Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.AddClause(Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Adds a clause to this query </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanOrQuery.Clauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPayloadCheckQuery">
             <summary>
               Only return those matches that have a specific payload at
              the given position.
             <p/>
             Do not use this with an SpanQuery that contains a <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.  Instead, use
             <seealso cref="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery"/> since it properly handles the fact that payloads
             aren't ordered by <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.
            
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Collections.Generic.ICollection{System.Byte[]})">
            
             <param name="match"> The underlying <seealso cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to check </param>
             <param name="payloadToMatch"> The <seealso cref="!:java.util.Collection"/> of payloads to match </param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.TermSpans">
            <summary>
            Expert:
            Public for extension only
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>
            A Query that matches documents containing a term.
             this may be combined with other terms with a <seealso cref="T:Lucene.Net.Search.BooleanQuery"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Expert: constructs a TermQuery that will use the
             provided docFreq instead of looking up the docFreq
             against the searcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
            <summary>
            Expert: constructs a TermQuery that will use the
             provided docFreq instead of looking up the docFreq
             against the searcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermQuery.Term">
            <summary>
            Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.TermWeight.GetTermsEnum(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> positioned at this weights Term or null if
            the term does not exist in the given context
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TermRangeFilter" -->
        <member name="M:Lucene.Net.Search.TermRangeFilter.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <param name="fieldName"> The field this range applies to </param>
            <param name="lowerTerm"> The lower bound on this range </param>
            <param name="upperTerm"> The upper bound on this range </param>
            <param name="includeLower"> Does this range include the lower bound? </param>
            <param name="includeUpper"> Does this range include the upper bound? </param>
            <exception cref="!:IllegalArgumentException"> if both terms are null or if
             lowerTerm is null and includeLower is true (similar for upperTerm
             and includeUpper) </exception>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new TermRangeFilter using Strings for term text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.Less(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <code>fieldName</code> matching
            less than or equal to <code>upperTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.More(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <code>fieldName</code> matching
            greater than or equal to <code>lowerTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.LowerTerm">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.UpperTerm">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TermRangeQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermRangeQuery.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.TermRangeQuery.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new TermRangeQuery using Strings for term text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.LowerTerm">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.UpperTerm">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermRangeTermsEnum">
            <summary>
            Subclass of FilteredTermEnum for enumerating all terms that match the
            specified range parameters.
            <p>Term enumerations are always ordered by
            <seealso cref="!:#getComparator"/>.  Each term in the enumeration is
            greater than all that precede it.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
             <summary>
             Enumerates all terms greater/equal than <code>lowerTerm</code>
             but less/equal than <code>upperTerm</code>.
            
             If an endpoint is null, it is said to be "open". Either or both
             endpoints may be open.  Open endpoints may not be exclusive
             (you can't select all but the first or last term without
             explicitly specifying the term to exclude.)
             </summary>
             <param name="tenum">
                      TermsEnum to filter </param>
             <param name="lowerTerm">
                      The term text at the lower end of the range </param>
             <param name="upperTerm">
                      The term text at the upper end of the range </param>
             <param name="includeLower">
                      If true, the <code>lowerTerm</code> is included in the range. </param>
             <param name="includeUpper">
                      If true, the <code>upperTerm</code> is included in the range. </param>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>
            Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.DocsEnum,Lucene.Net.Search.Similarities.Similarity.SimScorer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.NextDoc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.TermScorer.ToString">
            <summary>
            Returns a string representation of this <code>TermScorer</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermStatistics">
            <summary>
            Contains statistics for a specific term
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermStatistics.Term">
            <summary>
            returns the term text </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermStatistics.DocFreq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermStatistics.TotalTermFreq" -->
        <member name="T:Lucene.Net.Search.TimeLimitingCollector">
            <summary>
            The <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector"/> is used to timeout search requests that
            take longer than the maximum allowed search time limit. After this time is
            exceeded, the search thread is stopped by throwing a
            <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.#ctor(Lucene.Net.Search.Collector,Lucene.Net.Util.Counter,System.Int64)">
            <summary>
            Create a TimeLimitedCollector wrapper over another <seealso cref="P:Lucene.Net.Search.TimeLimitingCollector.Collector"/> with a specified timeout. </summary>
            <param name="collector"> the wrapped <seealso cref="P:Lucene.Net.Search.TimeLimitingCollector.Collector"/> </param>
            <param name="clock"> the timer clock </param>
            <param name="ticksAllowed"> max time allowed for collecting
            hits after which <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/> is thrown </param>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline">
            <summary>
            Syntactic sugar for <seealso cref="!:#setBaseline(long)"/> using <seealso cref="!:Counter#get()"/>
            on the clock passed to the constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.Collect(System.Int32)">
            <summary>
            Calls <seealso cref="!:Collector#collect(int)"/> on the decorated <seealso cref="P:Lucene.Net.Search.TimeLimitingCollector.Collector"/>
            unless the allowed time has passed, in which case it throws an exception.
            </summary>
            <exception cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
                      if the time allowed has exceeded. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TimeLimitingCollector.Baseline" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TimeLimitingCollector.Greedy" -->
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.Collector">
            <summary>
            this is so the same timer can be used with a multi-phase search process such as grouping.
            We don't want to create a new TimeLimitingCollector for each phase because that would
            reset the timer for each phase.  Once time is up subsequent phases need to timeout quickly.
            </summary>
            <param name="collector"> The actual collector performing search functionality </param>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalCounter">
            <summary>
            Returns the global TimerThreads <seealso cref="T:Lucene.Net.Util.Counter"/>
            <p>
            Invoking this creates may create a new instance of <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <seealso cref="!:TimerThread#stopTimer()"/>.
            </p> </summary>
            <returns> the global TimerThreads <seealso cref="T:Lucene.Net.Util.Counter"/>
            @lucene.experimental </returns>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalTimerThread">
            <summary>
            Returns the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>.
            <p>
            Invoking this creates may create a new instance of <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <seealso cref="!:TimerThread#stopTimer()"/>.
            </p>
            </summary>
            <returns> the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>
            @lucene.experimental </returns>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
            <summary>
            Thrown when elapsed search time exceeds allowed search time. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeAllowed">
            <summary>
            Returns allowed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeElapsed">
            <summary>
            Returns elapsed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.LastDocCollected">
            <summary>
            Returns last doc (absolute doc id) that was collected when the search time exceeded. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread">
            <summary>
            Thread used to timeout search requests.
            Can be stopped completely with <seealso cref="!:TimerThread#stopTimer()"/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer">
            <summary>
            Stops the timer thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Milliseconds">
            <summary>
            Get the timer value in milliseconds.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Resolution" -->
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>
            Represents hits returned by {@link
            IndexSearcher#search(Query,Filter,int)} and {@link
            IndexSearcher#search(Query,int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.TotalHits">
            <summary>
            The total number of hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.ScoreDocs">
            <summary>
            The top hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.MaxScore_Renamed">
            <summary>
            Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[])">
            <summary>
            Constructs a TopDocs with a default maxScore=Float.NaN. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.TopDocs[])" -->
        <member name="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,System.Int32,Lucene.Net.Search.TopDocs[])">
            <summary>
            Same as <seealso cref="!:#merge(Sort, int, TopDocs[])"/> but also slices the result at the same time based
            on the provided start and size. The return TopDocs will always have a scoreDocs with length of at most size.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.MaxScore">
            <summary>
            Returns the maximum score value encountered. Note that in case
            scores are not tracked, this returns <seealso cref="!:Float#NaN"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopDocsCollector`1" -->
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.EMPTY_TOPDOCS">
            <summary>
            this is used in case topDocs() is called with illegal parameters, or there
             simply aren't (enough) results.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.Pq">
            <summary>
            The priority queue which holds the top documents. Note that different
            implementations of PriorityQueue give different meaning to 'top documents'.
            HitQueue for example aggregates the top scoring documents, while other PQ
            implementations may hold documents sorted by other criteria.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.TotalHits_Renamed">
            <summary>
            The total number of documents that the collector encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.PopulateResults(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Populates the results array with the ScoreDoc instances. this can be
            overridden in case a different ScoreDoc type should be returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.NewTopDocs(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Returns a <seealso cref="M:Lucene.Net.Search.TopDocsCollector`1.TopDocs"/> instance containing the given results. If
            <code>results</code> is null it means there are no results to return,
            either because there were 0 calls to collect() or because the arguments to
            topDocs were invalid.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.TopDocsSize">
            <summary>
            The number of valid PQ entries </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.TopDocs">
            <summary>
            Returns the top docs that were collected by this collector. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocsCollector`1.TopDocs(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocsCollector`1.TopDocs(System.Int32,System.Int32)" -->
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.TotalHits">
            <summary>
            The total number of documents that matched this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.Collector"/> that sorts by <seealso cref="T:Lucene.Net.Search.SortField"/> using
             <seealso cref="T:Lucene.Net.Search.FieldComparator"/>s.
             <p/>
             See the <seealso cref="!:#create(Lucene.Net.Search.Sort, int, boolean, boolean, boolean, boolean)"/> method
             for instantiating a TopFieldCollector.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.FieldDoc,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" -->
        <member name="T:Lucene.Net.Search.TopFieldDocs">
            <summary>
            Represents hits returned by {@link
            IndexSearcher#search(Query,Filter,int,Sort)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldDocs.Fields">
            <summary>
            The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[],System.Single)">
            <summary>
            Creates one of these objects. </summary>
            <param name="totalHits">  Total number of hits for the query. </param>
            <param name="scoreDocs">  The top hits for the query. </param>
            <param name="fields">     The sort criteria used to find the top hits. </param>
            <param name="maxScore">   The maximum score encountered. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopScoreDocCollector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,Lucene.Net.Search.ScoreDoc,System.Boolean)" -->
        <member name="T:Lucene.Net.Search.TotalHitCountCollector">
            <summary>
            Just counts the total number of hits.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TotalHitCountCollector.TotalHits">
            <summary>
            Returns how many hits matched the search. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardQuery" -->
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_STRING">
            <summary>
            String equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_CHAR">
            <summary>
            Char equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_ESCAPE">
            <summary>
            Escape character </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToAutomaton(Lucene.Net.Index.Term)">
            <summary>
            Convert Lucene wildcard syntax into an automaton.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.WildcardQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.AlreadyClosedException">
            <summary>
            this exception is thrown when there is an attempt to
            access something that has already been closed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BaseDirectory">
            <summary>
            Base implementation for a concrete <seealso cref="T:Lucene.Net.Store.Directory"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Directory">
             <summary>
             A Directory is a flat list of files.  Files may be written once, when they
             are created.  Once a file is created it may only be opened for read, or
             deleted.  Random access is permitted both when reading and writing.
            
             Java's i/o APIs not used directly, but rather all i/o is
             through this API.  this permits things such as: <ul>
             <li> implementation of RAM-based indices;</li>
             <li> implementation indices stored in a database, via JDBC;</li>
             <li> implementation of an index as a single file;</li>
             </ul>
            
             Directory locking is implemented by an instance of {@link
             LockFactory}, and can be changed for each Directory
             instance using <seealso cref="!:setLockFactory"/>.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory.
            </summary>
            <exception cref="T:Lucene.Net.Store.NoSuchDirectoryException"> if the directory is not prepared for any
                    write operations (such as <seealso cref="!:#createOutput(String, IOContext)"/>). </exception>
            <exception cref="T:System.IO.IOException"> in case of other IO errors </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists.
            </summary>
             @deprecated this method will be removed in 5.0
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. this method follows the
            following contract:
            <ul>
            <li>Throws <seealso cref="T:System.IO.FileNotFoundException"/> or <seealso cref="T:Lucene.Net.Index.NoSuchFileException"/>
            if the file does not exist.</li>
            <li>Returns a value &gt;=0 if the file exists, which specifies its length.</li>
            </ul>
            </summary>
            <param name="name"> the name of the file for which to return the length. </param>
            <exception cref="T:System.IO.IOException"> if there was an IO error while retrieving the file's
                    length. </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name.
               Returns a stream writing this file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Sync(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Ensure that any writes to these files are moved to
            stable storage.  Lucene uses this to properly commit
            changes to the index, to prevent a machine/OS crash
            from corrupting the index.<br/>
            <br/>
            NOTE: Clients may call this method for same files over
            and over again, so some impls might optimize for that.
            For other impls the operation can be a noop, for various
            reasons.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)" -->
        <member name="M:Lucene.Net.Store.Directory.OpenChecksumInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file, computing checksum as it reads </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>
            Construct a <seealso cref="T:Lucene.Net.Store.Lock"/>. </summary>
            <param name="name"> the name of the lock file </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="name"> name of the lock to be cleared. </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Dispose">
            <summary>
            Closes the store. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.Directory.Copy(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.Directory.CreateSlicer(System.String,Lucene.Net.Store.IOContext)" -->
        <member name="M:Lucene.Net.Store.Directory.EnsureOpen">
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if this Directory is closed </exception>
        </member>
        <member name="P:Lucene.Net.Store.Directory.LockFactory">
            <summary>
            Set the LockFactory that this Directory instance should
            use for its locking implementation.  Each * instance of
            LockFactory should only be used for one directory (ie,
            do not share a single instance across multiple
            Directories).
            </summary>
            <param name="lockFactory"> instance of <seealso cref="P:Lucene.Net.Store.Directory.LockFactory"/>. </param>
        </member>
        <member name="P:Lucene.Net.Store.Directory.LockID">
            <summary>
            Return a string identifier that uniquely differentiates
            this Directory instance from other Directory instances.
            this ID should be the same if two Directory instances
            (even in different JVMs and/or on different machines)
            are considered "the same index".  this is how locking
            "scopes" to the right index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Directory.IndexInputSlicer">
            <summary>
            Allows to create one or more sliced <seealso cref="T:Lucene.Net.Store.IndexInput"/> instances from a single
            file handle. Some <seealso cref="T:Lucene.Net.Store.Directory"/> implementations may be able to efficiently map slices of a file
            into memory when only certain parts of a file are required.
            @lucene.internal
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenSlice(System.String,System.Int64,System.Int64)">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Store.IndexInput"/> slice starting at the given offset with the given length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenFullSlice">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Store.IndexInput"/> slice starting at offset <i>0</i> with a
            length equal to the length of the underlying file </summary>
            @deprecated Only for reading CFS files from 3.x indexes.
        </member>
        <member name="T:Lucene.Net.Store.Directory.SlicedIndexInput">
            <summary>
            Implementation of an IndexInput that reads from a portion of
             a file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>
            Base implementation class for buffered <seealso cref="T:Lucene.Net.Store.IndexInput"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE">
            <summary>
            Default buffer size set to {@value #BUFFER_SIZE}. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.MERGE_BUFFER_SIZE">
            <summary>
            A buffer size for merges set to {@value #MERGE_BUFFER_SIZE}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.#ctor(System.String,System.Int32)">
            <summary>
            Inits BufferedIndexInput with a specific bufferSize </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current position
            in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="length"> the number of bytes to read </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.BufferedIndexInput.FlushBuffer(Lucene.Net.Store.IndexOutput,System.Int64)" -->
        <member name="M:Lucene.Net.Store.BufferedIndexInput.BufferSize(Lucene.Net.Store.IOContext)">
            <summary>
            Returns default buffer sizes for the given <seealso cref="T:Lucene.Net.Store.IOContext"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexInput.BufferSize_">
            <summary>
            Change the buffer size used by this IndexInput </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current
             position in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.SeekInternal(System.Int64)">
            <summary>
            Expert: implements seek.  Sets current position in this file, where
             the next <seealso cref="!:#readInternal(byte[],int,int)"/> will occur. </summary>
            <seealso> cref= #readInternal(byte[],int,int) </seealso>
        </member>
        <member name="F:Lucene.Net.Store.BaseDirectory._lockFactory">
            <summary>
            Holds the LockFactory instance (implements locking for
            this Directory instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BaseDirectory.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksum">
            <summary>
            Wraps another <seealso cref="!:Checksum"/> with an internal buffer
            to speed up checksum calculations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IChecksum">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedChecksum.DEFAULT_BUFFERSIZE">
            <summary>
            Default buffer size: 256 </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum)">
            <summary>
            Create a new BufferedChecksum with <seealso cref="!:#DEFAULT_BUFFERSIZE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum,System.Int32)">
            <summary>
            Create a new BufferedChecksum with the specified bufferSize </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksumIndexInput">
            <summary>
            Simple implementation of <seealso cref="T:Lucene.Net.Store.ChecksumIndexInput"/> that wraps
            another input and delegates calls.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ChecksumIndexInput">
            <summary>
            Extension of IndexInput, computing checksum as it goes.
            Callers can retrieve the checksum via <seealso cref="!:#getChecksum()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.#ctor(System.String)">
            <summary>
            resourceDescription should be a non-null, opaque string
             describing this resource; it's returned from
             <seealso cref="!:#toString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.Seek(System.Int64)">
             <summary>
             {@inheritDoc}
            
             <seealso cref="T:Lucene.Net.Store.ChecksumIndexInput"/> can only seek forward and seeks are expensive
             since they imply to read bytes in-between the current position and the
             target position in order to update the checksum.
             </summary>
        </member>
        <member name="P:Lucene.Net.Store.ChecksumIndexInput.Checksum">
            <summary>
            Returns the current checksum value </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksumIndexInput.#ctor(Lucene.Net.Store.IndexInput)">
            <summary>
            Creates a new BufferedChecksumIndexInput </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>
            Base implementation class for buffered <seealso cref="T:Lucene.Net.Store.IndexOutput"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.IndexOutput" -->
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>
            Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Dispose">
            <summary>
            Closes this stream to further operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Store.IndexOutput.FilePointer" -->
        <member name="P:Lucene.Net.Store.IndexOutput.Checksum">
            <summary>
            Returns the current checksum of bytes written so far </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Store.IndexOutput.Length" -->
        <member name="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE">
            <summary>
            The default buffer size in bytes ({@value #DEFAULT_BUFFER_SIZE}). </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the default buffer size
            ({@value #DEFAULT_BUFFER_SIZE} bytes see <seealso cref="!:#DEFAULT_BUFFER_SIZE"/>)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the given buffer size. </summary>
            <param name="bufferSize"> the buffer size in bytes used to buffer writes internally. </param>
            <exception cref="!:IllegalArgumentException"> if the given buffer size is less or equal to <tt>0</tt> </exception>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="offset"> the offset in the byte array </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexOutput.BufferSize">
             <summary>
             Returns size of the used output buffer in bytes.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataInput">
            <summary>
            DataInput backed by a byte array.
            <b>WARNING:</b> this class omits all low-level checks.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataOutput">
            <summary>
            DataOutput backed by a byte array.
            <b>WARNING:</b> this class omits most low-level checks,
            so be sure to test heavily with assertions enabled.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.ByteBufferIndexInput" -->
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.Slice(System.String,System.Int64,System.Int64)">
            <summary>
            Creates a slice of this index input, with the given description, offset, and length. The slice is seeked to the beginning.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.BuildSlice(Lucene.Net.Support.ByteBuffer[],System.Int64,System.Int64)">
            <summary>
            Returns a sliced view from a set of already-existing buffers:
             the last buffer's limit() will be correct, but
             you must deal with offset separately (the first buffer will not be adjusted)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.FreeBuffer(Lucene.Net.Support.ByteBuffer)">
            <summary>
            Called when the contents of a buffer will be no longer needed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.CompoundFileDirectory" -->
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            Create a new CompoundFileDirectory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ReadEntries(Lucene.Net.Store.Directory.IndexInputSlicer,Lucene.Net.Store.Directory,System.String)">
            <summary>
            Helper method that reads CFS entries from an input stream </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.DeleteFile(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="!:UnsupportedOperationException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.RenameFile(System.String,System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="!:UnsupportedOperationException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.MakeLock(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="!:UnsupportedOperationException"> always: not supported by CFS  </exception>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileDirectory.FileEntry">
            <summary>
            Offset/Length for a slice inside of a compound file </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.CompoundFileWriter" -->
        <member name="M:Lucene.Net.Store.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <exception cref="!:NullPointerException">
                      if <code>dir</code> or <code>name</code> is null </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.Dispose">
            <summary>
            Closes all resources and writes the entry table
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      if close() had been called before or if no file has been added to
                      this object </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.CopyFileEntry(Lucene.Net.Store.IndexOutput,Lucene.Net.Store.CompoundFileWriter.FileEntry)">
            <summary>
            Copy the contents of the file with specified extension into the provided
            output stream.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Directory">
            <summary>
            Returns the directory of the compound file. </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Name">
            <summary>
            Returns the name of the compound file. </summary>
        </member>
        <member name="F:Lucene.Net.Store.CompoundFileWriter.FileEntry.File">
            <summary>
            source file </summary>
        </member>
        <member name="F:Lucene.Net.Store.CompoundFileWriter.FileEntry.Offset">
            <summary>
            temporary holder for the start of this file's data section </summary>
        </member>
        <member name="F:Lucene.Net.Store.CompoundFileWriter.FileEntry.Dir">
            <summary>
            the directory which contains the file. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FileSwitchDirectory">
             <summary>
             Expert: A Directory instance that switches files between
             two other Directory instances.
            
             <p>Files with the specified extensions are placed in the
             primary directory; others are placed in the secondary
             directory.  The provided Set must not change once passed
             to this class, and must allow multiple threads to call
             contains at once.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.FileSwitchDirectory.GetExtension(System.String)">
            <summary>
            Utility method to return a file's extension. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.PrimaryDir">
            <summary>
            Return the primary directory </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.SecondaryDir">
            <summary>
            Return the secondary directory </summary>
        </member>
        <member name="T:Lucene.Net.Store.FilterDirectory">
            <summary>
            Directory implementation that delegates calls to another directory.
             this class can be used to add limitations on top of an existing
             <seealso cref="T:Lucene.Net.Store.Directory"/> implementation such as
             <seealso cref="!:RateLimitedDirectoryWrapper rate limiting"/> or to add additional
             sanity checks for tests. However, if you plan to write your own
             <seealso cref="T:Lucene.Net.Store.Directory"/> implementation, you should consider extending directly
             <seealso cref="T:Lucene.Net.Store.Directory"/> or <seealso cref="T:Lucene.Net.Store.BaseDirectory"/> rather than try to reuse
             functionality of existing <seealso cref="T:Lucene.Net.Store.Directory"/>s by extending this class.
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FilterDirectory.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FilterDirectory.Delegate">
            <summary>
            Return the wrapped <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FlushInfo">
            <summary>
            <p>A FlushInfo provides information required for a FLUSH context.
             It is used as part of an <seealso cref="T:Lucene.Net.Store.IOContext"/> in case of FLUSH context.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FlushInfo.#ctor(System.Int32,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.FSDirectory" -->
        <member name="F:Lucene.Net.Store.FSDirectory.DEFAULT_READ_CHUNK_SIZE">
            <summary>
            Default read chunk size: 8192 bytes (this is the size up to which the JDK
              does not allocate additional arrays while reading/writing) </summary>
              @deprecated this constant is no longer used since Lucene 4.5.
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new FSDirectory for the named location (ctor for subclasses). </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)" -->
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Just like <seealso cref="!:#open(File)"/>, but allows you to
             also specify a custom <seealso cref="P:Lucene.Net.Store.FSDirectory.LockFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ListAll(System.IO.DirectoryInfo)">
            <summary>
            Lists all files (not subdirectories) in the
             directory.  this method never returns null (throws
             <seealso cref="T:System.IO.IOException"/> instead).
            </summary>
             <exception cref="T:Lucene.Net.Store.NoSuchDirectoryException"> if the directory
              does not exist, or does exist but is not a
              directory. </exception>
             <exception cref="T:System.IO.IOException"> if list() returns null  </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.FSDirectory.ListAll" -->
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an IndexOutput for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Dispose">
            <summary>
            Closes the store to future operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>
            For debug output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Fsync(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.Directory">
            <returns> the underlying filesystem directory </returns>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.ReadChunkSize">
            <summary>
            this setting has no effect anymore. </summary>
            @deprecated this is no longer used since Lucene 4.5.
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory.FSIndexOutput">
            <summary>
            Writes output with <seealso cref="!:RandomAccessFile#write(byte[], int, int)"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.FSIndexOutput.CHUNK_SIZE">
            <summary>
            The maximum chunk size is 8192 bytes, because <seealso cref="!:RandomAccessFile"/> mallocs
            a native buffer outside of stack if the write buffer size is larger.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Seek(System.Int64)">
            <summary>
            Random-access methods </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSLockFactory">
            <summary>
            Base class for file system based locking implementation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockFactory" -->
        <member name="M:Lucene.Net.Store.LockFactory.MakeLock(System.String)">
            <summary>
            Return a new Lock instance identified by lockName. </summary>
            <param name="lockName"> name of the lock to be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="lockName"> name of the lock to be cleared. </param>
        </member>
        <member name="P:Lucene.Net.Store.LockFactory.LockPrefix">
            <summary>
            Set the prefix in use for all locks created in this
            LockFactory.  this is normally called once, when a
            Directory gets this LockFactory instance.  However, you
            can also call this (after this instance is assigned to
            a Directory) to override the prefix in use.  this
            is helpful if you're running Lucene on machines that
            have different mount points for the same shared
            directory.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSLockFactory.LockDir_Renamed">
            <summary>
            Directory for the lock files.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSLockFactory.LockDir">
            <summary>
            Set the lock directory. this method can be only called
            once to initialize the lock directory. It is used by <seealso cref="T:Lucene.Net.Store.FSDirectory"/>
            to set the lock directory to itself.
            Subclasses can also use this method to set the directory
            in the constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.InputStreamDataInput">
            <summary>
            A <seealso cref="T:Lucene.Net.Store.DataInput"/> wrapping a plain <seealso cref="!:InputStream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IOContext">
            <summary>
            IOContext holds additional details on the merge/search context. A IOContext
            object can never be initialized as null as passed as a parameter to either
            <seealso cref="!:Lucene.Net.Store.Directory#openInput(String, IOContext)"/> or
            <seealso cref="!:Lucene.Net.Store.Directory#createOutput(String, IOContext)"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.IOContext.Context">
            <summary>
            An object of a enumerator Context type
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IOContext.#ctor(Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            this constructor is used to initialize a <seealso cref="T:Lucene.Net.Store.IOContext"/> instance with a new value for the readOnce variable. </summary>
            <param name="ctxt"> <seealso cref="T:Lucene.Net.Store.IOContext"/> object whose information is used to create the new instance except the readOnce variable. </param>
            <param name="readOnce"> The new <seealso cref="T:Lucene.Net.Store.IOContext"/> object will use this value for readOnce.  </param>
        </member>
        <member name="T:Lucene.Net.Store.IOContext.UsageContext">
            <summary>
            Context is a enumerator which specifies the context in which the Directory
            is being used for.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Lock" -->
        <member name="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER">
            <summary>
            Pass this value to <seealso cref="!:#obtain(long)"/> to try
             forever to obtain the lock.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL">
            <summary>
            How long <seealso cref="!:#obtain(long)"/> waits, in milliseconds,
             in between attempts to acquire the lock.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>
            Attempts to obtain exclusive access and immediately return
             upon success or failure.  Use <seealso cref="!:#close"/> to
             release the lock. </summary>
            <returns> true iff exclusive access is obtained </returns>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>
            Attempts to obtain an exclusive lock within amount of
             time given. Polls once per <seealso cref="!:#LOCK_POLL_INTERVAL"/>
             (currently 1000) milliseconds until lockWaitTimeout is
             passed. </summary>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or {@link
                   #LOCK_OBTAIN_WAIT_FOREVER} to retry forever </param>
            <returns> true if lock was obtained </returns>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock wait times out </exception>
            <exception cref="!:IllegalArgumentException"> if lockWaitTimeout is
                    out of bounds </exception>
            <exception cref="T:System.IO.IOException"> if obtain() throws System.IO.IOException </exception>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Release">
            <summary>
            Releases exclusive access. </summary>
        </member>
        <member name="P:Lucene.Net.Store.Lock.FailureReason">
            <summary>
            If a lock obtain called, this failureReason may be set
            with the "root cause" Exception as to why the lock was
            not obtained.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.Lock.Locked">
            <summary>
            Returns true if the resource is currently locked.  Note that one must
            still call <seealso cref="!:#obtain()"/> before using the resource.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>
            Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>
            Constructs an executor that will grab the named lock. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.DoBody">
            <summary>
            Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.Run">
            <summary>
            Calls <seealso cref="!:#doBody"/> while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            <seealso cref="!:#doBody"/> exits. </summary>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock could not
            be obtained </exception>
            <exception cref="T:System.IO.IOException"> if <seealso cref="!:Lock#obtain"/> throws System.IO.IOException </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockObtainFailedException" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockReleaseFailedException" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockStressTest" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockVerifyServer" -->
        <member name="T:Lucene.Net.Store.MergeInfo">
            <summary>
            <p>A MergeInfo provides information required for a MERGE context.
             It is used as part of an <seealso cref="T:Lucene.Net.Store.IOContext"/> in case of MERGE context.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.MergeInfo.#ctor(System.Int32,System.Int64,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.MMapDirectory" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Store.MMapDirectory.DEFAULT_MAX_BUFF" -->
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new MMapDirectory for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new MMapDirectory for the named location and <seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)" -->
        <member name="F:Lucene.Net.Store.MMapDirectory.UNMAP_SUPPORTED">
            <summary>
            <code>true</code>, if this platform supports unmapping mmapped files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an IndexInput for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.Map(Lucene.Net.Store.MMapDirectory.MMapIndexInput,System.IO.FileStream,System.Int64,System.Int64)">
            <summary>
            Maps a file into a set of buffers </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Store.MMapDirectory.UseUnmap" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Store.MMapDirectory.MaxChunkSize" -->
        <member name="M:Lucene.Net.Store.MMapDirectory.MMapIndexInput.FreeBuffer(Lucene.Net.Support.ByteBuffer)">
            <summary>
            Try to unmap the buffer, this method silently fails if no support
            for that in the JVM. On Windows, this leads to the fact,
            that mmapped files cannot be modified or deleted.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.NativeFSLockFactory" -->
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor">
            <summary>
            Create a NativeFSLockFactory instance, with null (unset)
            lock directory. When you pass this factory to a <seealso cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.String)">
            <summary>
            Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDirName:
            </summary>
            <param name="lockDirName"> where lock files are created. </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDir:
            </summary>
            <param name="lockDir"> where lock files are created. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.NIOFSDirectory" -->
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new NIOFSDirectory for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new NIOFSDirectory for the named location and <seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an IndexInput for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput">
            <summary>
            Reads bytes with <seealso cref="!:FileChannel#read(ByteBuffer, long)"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.CHUNK_SIZE">
            <summary>
            The maximum chunk size for reads of 16384 bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.Channel">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.IsClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.Off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.End">
            <summary>
            end offset (start+length) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.NoLockFactory" -->
        <member name="T:Lucene.Net.Store.NoSuchDirectoryException">
            <summary>
            this exception is thrown when you try to list a
            non-existent directory.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.NRTCachingDirectory" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.NRTCachingDirectory.#ctor(Lucene.Net.Store.Directory,System.Double,System.Double)" -->
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.SizeInBytes">
            <summary>
            Returns how many bytes are being used by the
             RAMDirectory cache
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.Dispose">
            <summary>
            Close this directory, which flushes any cached files
             to the delegate and then closes the delegate.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.DoCacheWrite(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Subclass can override this to customize logic; return
             true if this file should be written to the RAMDirectory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.OutputStreamDataOutput">
            <summary>
            A <seealso cref="T:Lucene.Net.Store.DataOutput"/> wrapping a plain <seealso cref="!:OutputStream"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.RAMDirectory" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>
            Constructs an empty <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Store.IOContext)" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>
            Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.SizeInBytes">
            <summary>
            Return total size in bytes of all files in this directory. this is
            currently quantized to RAMOutputStream.BUFFER_SIZE.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name. Returns a stream writing this file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.NewRAMFile">
            <summary>
            Returns a new <seealso cref="T:Lucene.Net.Store.RAMFile"/> for storing data. this method can be
            overridden to return different <seealso cref="T:Lucene.Net.Store.RAMFile"/> impls, that e.g. override
            <seealso cref="!:RAMFile#newBuffer(int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Dispose">
            <summary>
            Closes the store to future operations, releasing associated memory. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMFile">
            <summary>
            Represents a file in RAM as a list of byte[] buffers.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)">
            <summary>
            Expert: allocate a new buffer.
            Subclasses can allocate differently. </summary>
            <param name="size"> size of allocated buffer. </param>
            <returns> allocated buffer. </returns>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
             <summary>
             A memory-resident <seealso cref="T:Lucene.Net.Store.IndexInput"/> implementation.
            
              @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
             <summary>
             A memory-resident <seealso cref="T:Lucene.Net.Store.IndexOutput"/> implementation.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>
            Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Copy the current contents of this buffer to output
             byte array
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>
            Resets this to an empty file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.SizeInBytes">
            <summary>
            Returns byte usage of all buffers. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.RateLimitedDirectoryWrapper" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},System.Nullable{Lucene.Net.Store.IOContext.UsageContext})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetRateLimiter(Lucene.Net.Store.RateLimiter,Lucene.Net.Store.IOContext.UsageContext)" -->
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.GetMaxWriteMBPerSec(Lucene.Net.Store.IOContext.UsageContext)">
            <summary>
            See <seealso cref="!:#setMaxWriteMBPerSec"/>.
            </summary>
            <exception cref="T:System.ArgumentException">
                      if context is <code>null</code> </exception>
            <exception cref="T:Lucene.Net.Store.AlreadyClosedException"> if the <seealso cref="T:Lucene.Net.Store.Directory"/> is already closed
            @lucene.experimental </exception>
        </member>
        <member name="T:Lucene.Net.Store.RateLimitedIndexOutput">
             <summary>
             A <seealso cref="!:RateLimiter rate limiting"/> <seealso cref="T:Lucene.Net.Store.IndexOutput"/>
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter">
            <summary>
            Abstract base class to rate limit IO.  Typically implementations are
             shared across multiple IndexInputs or IndexOutputs (for example
             those involved all merging).  Those IndexInputs and
             IndexOutputs would call <seealso cref="!:#pause"/> whenever they
             want to read bytes or write bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
             rate at or below the target.
             <p>
             Note: the implementation is thread-safe
             </p> </summary>
             <returns> the pause time in nano seconds
             </returns>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.MbPerSec">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter.SimpleRateLimiter">
            <summary>
            Simple class to rate limit IO.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.#ctor(System.Double)">
            <summary>
            mbPerSec is the MB/sec max IO rate </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
             rate at or below the target. NOTE: multiple threads
             may safely use this, however the implementation is
             not perfectly thread safe but likely in practice this
             is harmless (just means in some rare cases the rate
             might exceed the target).  It's best to call this
             with a biggish count, not one byte at a time. </summary>
             <returns> the pause time in nano seconds
             </returns>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.MbPerSec">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory">
            <summary>
            A straightforward implementation of <seealso cref="T:Lucene.Net.Store.FSDirectory"/>
             using java.io.RandomAccessFile.  However, this class has
             poor concurrent performance (multiple threads will
             bottleneck) as it synchronizes when multiple threads
             read from the same file.  It's usually better to use
             <seealso cref="T:Lucene.Net.Store.NIOFSDirectory"/> or <seealso cref="T:Lucene.Net.Store.MMapDirectory"/> instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new SimpleFSDirectory for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new SimpleFSDirectory for the named location and <seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an IndexInput for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput">
            <summary>
            Reads bytes with <seealso cref="!:RandomAccessFile#seek(long)"/> followed by
            <seealso cref="!:RandomAccessFile#read(byte[], int, int)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.CHUNK_SIZE">
            <summary>
            The maximum chunk size is 8192 bytes, because <seealso cref="!:RandomAccessFile"/> mallocs
            a native buffer outside of stack if the read buffer size is larger.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.File">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.IsClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.Off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.End">
            <summary>
            end offset (start+length) </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            IndexInput methods </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.SimpleFSLockFactory" -->
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor">
            <summary>
            Create a SimpleFSLockFactory instance, with null (unset)
            lock directory. When you pass this factory to a <seealso cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Instantiate using the provided directory (as a File instance). </summary>
            <param name="lockDir"> where lock files should be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.String)">
            <summary>
            Instantiate using the provided directory name (String). </summary>
            <param name="lockDirName"> where lock files should be created. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.SingleInstanceLockFactory" -->
        <member name="T:Lucene.Net.Store.TrackingDirectoryWrapper">
            <summary>
            A delegating Directory that records which files were
             written to and deleted.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.VerifyingLockFactory" -->
        <member name="M:Lucene.Net.Store.VerifyingLockFactory.#ctor(Lucene.Net.Store.LockFactory,System.IO.Stream,System.IO.Stream)">
            <param name="lf"> the LockFactory that we are testing </param>
            <param name="in"> the socket's input to <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/> </param>
            <param name="out"> the socket's output to <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/> </param>
        </member>
        <member name="T:Lucene.Net.Support.AppSettings">
             <summary>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Set(System.String,System.Int32)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Set(System.String,System.Int64)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Set(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Set(System.String,System.Boolean)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Get(System.String,System.Int32)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Get(System.String,System.Int64)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.AppSettings.Get(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="key"></param>
             <param name="defValue"></param>
             <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.AttributeImplItem">
            <summary>
            A simple wrapper to allow for the use of the GeneralKeyedCollection.  The
            wrapper is required as there can be several keys for an object depending
            on how many interfaces it implements.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.BitSetSupport">
            <summary>
            This class provides supporting methods of java.util.BitSet
            that are not present in System.Collections.BitArray.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.NextClearBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next un-set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.Cardinality(System.Collections.BitArray)">
            <summary>
            Returns the number of bits set to true in this BitSet.
            </summary>
            <param name="bits">The BitArray object.</param>
            <returns>The number of bits set to true in this BitSet.</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.Set(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to true.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.Set(System.Collections.BitArray,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The start of the range to set(inclusive)</param>
            <param name="toIndex">The end of the range to set(exclusive)</param>
            <param name="value">the value to set to the range</param>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.Clear(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to false.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to false.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitSetSupport.Clear(System.Collections.BitArray)">
            <summary>
            Sets all bits to false
            </summary>
            <param name="bits">The BitArray object.</param>
        </member>
        <member name="T:Lucene.Net.Support.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Character.ForDigit(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="digit"></param>
             <param name="radix"></param>
             <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2">
            <summary>
            A C# emulation of the <a href="http://download.oracle.com/javase/1,5.0/docs/api/java/util/HashMap.html">Java Hashmap</a>
            <para>
            A <see cref="T:System.Collections.Generic.Dictionary`2"/> is a close equivalent to the Java
            Hashmap.  One difference java implementation of the class is that
            the Hashmap supports both null keys and values, where the C# Dictionary
            only supports null values not keys.  Also, <c>V Get(TKey)</c>
            method in Java returns null if the key doesn't exist, instead of throwing
            an exception.  This implementation doesn't throw an exception when a key
            doesn't exist, it will return null.  This class is slower than using a
            <see cref="T:System.Collections.Generic.Dictionary`2"/>, because of extra checks that have to be
            done on each access, to check for null.
            </para>
            <para>
            <b>NOTE:</b> This class works best with nullable types.  default(T) is returned
            when a key doesn't exist in the collection (this being similar to how Java returns
            null).  Therefore, if the expected behavior of the java code is to execute code
            based on if the key exists, when the key is an integer type, it will return 0 instead of null.
            </para>
            <remaks>
            Consider also implementing IDictionary, IEnumerable, and ICollection
            like <see cref="T:System.Collections.Generic.Dictionary`2"/> does, so HashMap can be
            used in substituted in place for the same interfaces it implements.
            </remaks>
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of values in the dictionary</typeparam>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2.NullValueCollection">
            <summary>
            Wraps a dictionary and adds the value
            represented by the null key
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2.NullKeyCollection">
            <summary>
            Wraps a dictionary's collection, adding in a
            null key.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.SubList`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Creates a ranged view of the given <paramref name="list"/>.
            </summary>
            <param name="list">The original list to view.</param>
            <param name="fromIndex">The inclusive starting index.</param>
            <param name="toIndex">The exclusive ending index.</param>
        </member>
        <member name="M:Lucene.Net.Support.MathExtension.ToRadians(System.Double)">
            <summary>
            Convert to Radians.
            </summary>
            <param name="val">The value to convert to radians</param>
            <returns>The value in radians</returns>
        </member>
        <member name="T:Lucene.Net.Support.PriorityQueue`1">
            <summary>
            Priority queue based on binary heap,
            Elements with minimum priority dequeued first
            </summary>
            <typeparam name="T">Type of elements</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of priority queue with specified initial capacity and specified priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor">
            <summary>
            Initializes a new instance of priority queue with default initial capacity
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of priority queue with specified data
            </summary>
            <param name="data">data to be inserted into priority queue</param>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.MergeQueues(Lucene.Net.Support.PriorityQueue{`0},Lucene.Net.Support.PriorityQueue{`0})">
            <summary>
            Merges two priority queues and sets specified comparer for resultant priority queue
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <returns>resultant priority queue</returns>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues element into priority queue
            </summary>
            <param name="item">object to enqueue</param>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Dequeue">
            <summary>
            Dequeues element with minimum priority and return its priority and value as <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
            <returns>the dequeued element</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Peek">
            <summary>
            Returns priority and value of the element with minimun priority, without removing it from the queue
            </summary>
            <returns>priority and value of the element with minimum priority</returns>
            <remarks>
            Method throws <see cref="T:System.InvalidOperationException"/> if priority queue is empty
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Add(`0)">
            <summary>
            Enqueus element into priority queue
            </summary>
            <param name="item">element to add</param>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Contains(`0)">
            <summary>
            Determines whether the priority queue contains a specific element
            </summary>
            <param name="item">The object to locate in the priority queue</param>
            <returns><c>true</c> if item is found in the priority queue; otherwise, <c>false.</c> </returns>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the priority queue to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from the priority queue. The Array must have zero-based indexing. </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <remarks>
            It is not guaranteed that items will be copied in the sorted order.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.PriorityQueue`1.Remove(`0)" -->
        <member name="M:Lucene.Net.Support.PriorityQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>Enumerator</returns>
            <remarks>
            Returned enumerator does not iterate elements in sorted order.</remarks>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>Enumerator</returns>
            <remarks>
            Returned enumerator does not iterate elements in sorted order.</remarks>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.IsEmpty">
            <summary>
            Gets whether priority queue is empty
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.Count">
            <summary>
            Gets number of elements in the priority queue
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
            <remarks>
            For priority queue this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Support.IDisposableThreadLocalProfiler">
            <summary>
            For Debuging purposes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.CollectionsHelper">
            <summary>
            Support class used to handle Hashtable addition, which does a check
            first to make sure the added item is unique in the hash.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.CollectionsHelper.CollectionToString(System.Collections.ICollection)">
            <summary>
            Converts the specified collection to its string representation.
            </summary>
            <param name="c">The collection to convert to string.</param>
            <returns>A string representation of the specified collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.CollectionsHelper.CompareStringArrays(System.String[],System.String[])">
            <summary>
            Compares two string arrays for equality.
            </summary>
            <param name="l1">First string array list to compare</param>
            <param name="l2">Second string array list to compare</param>
            <returns>true if the strings are equal in both arrays, false otherwise</returns>
        </member>
        <member name="M:Lucene.Net.Support.CollectionsHelper.Fill(System.Array,System.Int32,System.Int32,System.Object)">
            <summary>
            Fills the array with an specific value from an specific index to an specific index.
            </summary>
            <param name="array">The array to be filled.</param>
            <param name="fromindex">The first index to be filled.</param>
            <param name="toindex">The last index to be filled.</param>
            <param name="val">The value to fill the array with.</param>
        </member>
        <member name="M:Lucene.Net.Support.CollectionsHelper.Fill(System.Array,System.Object)">
            <summary>
            Fills the array with an specific value.
            </summary>
            <param name="array">The array to be filled.</param>
            <param name="val">The value to fill the array with.</param>
        </member>
        <member name="M:Lucene.Net.Support.CollectionsHelper.Equals(System.Array,System.Array)">
            <summary>
            Compares the entire members of one array whith the other one.
            </summary>
            <param name="array1">The array to be compared.</param>
            <param name="array2">The array to be compared with.</param>
            <returns>Returns true if the two specified arrays of Objects are equal
            to one another. The two arrays are considered equal if both arrays
            contain the same number of elements, and all corresponding pairs of
            elements in the two arrays are equal. Two objects e1 and e2 are
            considered equal if (e1==null ? e2==null : e1.equals(e2)). In other
            words, the two arrays are equal if they contain the same elements in
            the same order. Also, two array references are considered equal if
            both are null.</returns>
        </member>
        <member name="T:Lucene.Net.Support.Compare">
            <summary>
            Summary description for TestSupportClass.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Compare.CompareTermArrays(Lucene.Net.Index.Term[],Lucene.Net.Index.Term[])">
            <summary>
            Compares two Term arrays for equality.
            </summary>
            <param name="t1">First Term array to compare</param>
            <param name="t2">Second Term array to compare</param>
            <returns>true if the Terms are equal in both arrays, false otherwise</returns>
        </member>
        <member name="T:Lucene.Net.Support.Double">
             <summary>
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Support.EquatableList`1">
            <summary>Represents a strongly typed list of objects that can be accessed by index.
            Provides methods to search, sort, and manipulate lists. Also provides functionality
            to compare lists against each other through an implementations of
            <see cref="T:System.IEquatable`1"/>.</summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor">
            <summary>Initializes a new instance of the
            <see cref="T:Lucene.Net.Support.EquatableList`1"/> class that is empty and has the
            default initial capacity.</summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new instance of the <see cref="T:Lucene.Net.Support.EquatableList`1"/>
            class that contains elements copied from the specified collection and has
            sufficient capacity to accommodate the number of elements copied.</summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Lucene.Net.Support.EquatableList`1"/>
            class that is empty and has the specified initial capacity.</summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.AddRange(System.Collections.ICollection)">
            <summary>Adds a range of objects represented by the <see cref="T:System.Collections.ICollection"/>
            implementation.</summary>
            <param name="c">The <see cref="T:System.Collections.ICollection"/>
            implementation to add to this list.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.EnumerableCountsEqual(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>Compares the counts of two <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            implementations.</summary>
            <remarks>This uses a trick in LINQ, sniffing types for implementations
            of interfaces that might supply shortcuts when trying to make comparisons.
            In this case, that is the <see cref="T:System.Collections.Generic.ICollection`1"/> and
            <see cref="T:System.Collections.ICollection"/> interfaces, either of which can provide a count
            which can be used in determining the equality of sequences (if they don't have
            the same count, then they can't be equal).</remarks>
            <param name="x">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> from the left hand side of the
            comparison to check the count of.</param>
            <param name="y">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> from the right hand side of the
            comparison to check the count of.</param>
            <returns>Null if the result is indeterminate.  This occurs when either <paramref name="x"/>
            or <paramref name="y"/> doesn't implement <see cref="T:System.Collections.ICollection"/> or <see cref="T:System.Collections.Generic.ICollection`1"/>.
            Otherwise, it will get the count from each and return true if they are equal, false otherwise.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>Compares the contents of a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            implementation to another one to determine equality.</summary>
            <remarks>Thinking of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation as
            a string with any number of characters, the algorithm checks
            each item in each list.  If any item of the list is not equal (or
            one list contains all the elements of another list), then that list
            element is compared to the other list element to see which
            list is greater.</remarks>
            <param name="x">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation
            that is considered the left hand side.</param>
            <param name="y">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation
            that is considered the right hand side.</param>
            <returns>True if the items are equal, false otherwise.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Equals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Compares this sequence to another <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            implementation, returning true if they are equal, false otherwise.</summary>
            <param name="other">The other <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation
            to compare against.</param>
            <returns>True if the sequence in <paramref name="other"/>
            is the same as this one.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Equals(System.Object)">
            <summary>Compares this object for equality against other.</summary>
            <param name="obj">The other object to compare this object against.</param>
            <returns>True if this object and <paramref name="obj"/> are equal, false
            otherwise.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.GetHashCode">
            <summary>Gets the hash code for the list.</summary>
            <returns>The hash code value.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>Gets the hash code for the list.</summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            implementation which will have all the contents hashed.</param>
            <returns>The hash code value.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Clone">
            <summary>Clones the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</summary>
            <remarks>This is a shallow clone.</remarks>
            <returns>A new shallow clone of this
            <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</returns>
        </member>
        <member name="T:Lucene.Net.Support.FileSupport">
            <summary>
            Represents the methods to support some operations over files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.FileSupport.GetFiles(System.IO.FileInfo)">
            <summary>
            Returns an array of abstract pathnames representing the files and directories of the specified path.
            </summary>
            <param name="path">The abstract pathname to list it childs.</param>
            <returns>An array of abstract pathnames childs of the path specified or null if the path is not a directory</returns>
        </member>
        <member name="M:Lucene.Net.Support.FileSupport.Sync(System.IO.FileStream)">
            <summary>
            Flushes the specified file stream. Ensures that all buffered
            data is actually written to the file system.
            </summary>
            <param name="fileStream">The file stream.</param>
        </member>
        <member name="T:Lucene.Net.Support.GeneralKeyedCollection`2">
            <summary>A collection of <typeparamref name="TItem"/> which can be
            looked up by instances of <typeparamref name="TKey"/>.</summary>
            <typeparam name="TItem">The type of the items contains in this
            collection.</typeparam>
            <typeparam name="TKey">The type of the keys that can be used to look
            up the items.</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.#ctor(System.Converter{`1,`0})">
            <summary>Creates a new instance of the
            <see cref="T:Lucene.Net.Support.GeneralKeyedCollection`2"/> class.</summary>
            <param name="converter">The <see cref="T:System.Converter`2"/> which will convert
            instances of <typeparamref name="TItem"/> to <typeparamref name="TKey"/>
            when the override of <see cref="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)"/> is called.</param>
        </member>
        <member name="F:Lucene.Net.Support.GeneralKeyedCollection`2.converter">
            <summary>The <see cref="T:System.Converter`2"/> which will convert
            instances of <typeparamref name="TItem"/> to <typeparamref name="TKey"/>
            when the override of <see cref="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)"/> is called.</summary>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)">
            <summary>Converts an item that is added to the collection to
            a key.</summary>
            <param name="item">The instance of <typeparamref name="TItem"/>
            to convert into an instance of <typeparamref name="TKey"/>.</param>
            <returns>The instance of <typeparamref name="TKey"/> which is the
            key for this item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.ContainsKey(`0)">
            <summary>Determines if a key for an item exists in this
            collection.</summary>
            <param name="key">The instance of <typeparamref name="TKey"/>
            to see if it exists in this collection.</param>
            <returns>True if the key exists in the collection, false otherwise.</returns>
        </member>
        <member name="T:Lucene.Net.Support.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Int64)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Single)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the index of the first bit that is set to true that occurs
            on or after the specified starting index. If no such bit exists
            then -1 is returned.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The index to start checking from (inclusive).</param>
            <returns>The index of the next set bit.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToInt64(System.String)">
            <summary>
            Converts a System.String number to long.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.OS">
            <summary>
            Provides platform infos.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.OS.IsUnix">
            <summary>
            Whether we run under a Unix platform.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.OS.IsWindows">
            <summary>
            Whether we run under a supported Windows platform.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Single">
             <summary>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Support.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
             <summary>
            
             </summary>
             <param name="s"></param>
             <param name="style"></param>
             <param name="provider"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Single.Parse(System.String,System.IFormatProvider)">
             <summary>
            
             </summary>
             <param name="s"></param>
             <param name="provider"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Single.Parse(System.String,System.Globalization.NumberStyles)">
             <summary>
            
             </summary>
             <param name="s"></param>
             <param name="style"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Single.Parse(System.String)">
             <summary>
            
             </summary>
             <param name="s"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Single.ToString(System.Single)">
             <summary>
            
             </summary>
             <param name="f"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Single.ToString(System.Single,System.String)">
             <summary>
            
             </summary>
             <param name="f"></param>
             <param name="format"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TextSupport.GetCharsFromString(System.String,System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Copies an array of chars obtained from a String into a specified array of chars
            </summary>
            <param name="sourceString">The String to get the chars from</param>
            <param name="sourceStart">Position of the String to start getting the chars</param>
            <param name="sourceEnd">Position of the String to end getting the chars</param>
            <param name="destinationArray">Array to return the chars</param>
            <param name="destinationStart">Position of the destination array of chars to start storing the chars</param>
            <returns>An array of chars</returns>
        </member>
        <member name="T:Lucene.Net.Support.ThreadLock">
            <summary>
            Abstract base class that provides a synchronization interface
            for derived lock types
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadLock.NullLock">
            <summary>
            A ThreadLock class that actually does no locking
            Used in ParallelMultiSearcher/MultiSearcher
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ThreadLock.MonitorLock">
            <summary>
            Wrapper class for the Monitor Enter/Exit methods
            using the <see cref="T:Lucene.Net.Support.ThreadLock"/> interface
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.WeakDictionary`2.WeakKey`1">
            <summary>
            A weak reference wrapper for the hashtable keys. Whenever a key\value pair
            is added to the hashtable, the key is wrapped using a WeakKey. WeakKey saves the
            value of the original object hashcode for fast comparison.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Accountable">
            <summary>
            An object whose RAM usage can be computed.
            
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Accountable.RamBytesUsed">
            <summary>
            Return the memory usage of this object in bytes. Negative values are illegal.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayInPlaceMergeSorter`1">
            <summary>
            An <seealso cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayInPlaceMergeSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <seealso cref="!:ArrayInPlaceMergeSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayIntroSorter`1">
            <summary>
            An <seealso cref="T:Lucene.Net.Util.IntroSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayIntroSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <seealso cref="!:ArrayInPlaceMergeSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayTimSorter`1">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.TimSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.TimSorter" -->
        <member name="M:Lucene.Net.Util.TimSorter.#ctor(System.Int32)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.TimSorter"/>. </summary>
            <param name="maxTempSlots"> the <a href="#maxTempSlots">maximum amount of extra memory to run merges</a> </param>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.MinRun(System.Int32)">
            <summary>
            Minimum run length for an array of length <code>length</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.NextRun">
            <summary>
            Compute the length of the next run, make the run sorted and return its
             length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Copy(System.Int32,System.Int32)">
            <summary>
            Copy data from slot <code>src</code> to slot <code>dest</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Save(System.Int32,System.Int32)">
            <summary>
            Save all elements between slots <code>i</code> and <code>i+len</code>
             into the temporary storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Restore(System.Int32,System.Int32)">
            <summary>
            Restore element <code>j</code> from the temporary storage into slot <code>i</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.CompareSaved(System.Int32,System.Int32)">
            <summary>
            Compare element <code>i</code> from the temporary storage with element
             <code>j</code> from the slice to sort, similarly to
             <seealso cref="!:#compare(int, int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayTimSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0},System.Int32)">
            <summary>
            Create a new <seealso cref="!:ArrayTimSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayUtil">
             <summary>
             Methods for manipulating arrays.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.ArrayUtil.MAX_ARRAY_LENGTH">
            <summary>
            Maximum length for an array; we set this to "a
             bit" below Integer.MAX_VALUE because the exact max
             allowed byte[] is JVM dependent, so we want to avoid
             a case where a large value worked during indexing on
             one JVM but failed later at search time with a
             different JVM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt(System.Char[])">
            <summary>
            Parses the string argument as if it was an int value and returns the
            result. Throws NumberFormatException if the string does not represent an
            int quantity.
            </summary>
            <param name="chars"> a string representation of an int quantity. </param>
            <returns> int the value represented by the argument </returns>
            <exception cref="!:NumberFormatException"> if the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt(System.Char[],System.Int32,System.Int32)">
            <summary>
            Parses a char array into an int. </summary>
            <param name="chars"> the character array </param>
            <param name="offset"> The offset into the array </param>
            <param name="len"> The length </param>
            <returns> the int </returns>
            <exception cref="!:NumberFormatException"> if it can't parse </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Parses the string argument as if it was an int value and returns the
            result. Throws NumberFormatException if the string does not represent an
            int quantity. The second argument specifies the radix to use when parsing
            the value.
            </summary>
            <param name="chars"> a string representation of an int quantity. </param>
            <param name="radix"> the base to use for conversion. </param>
            <returns> int the value represented by the argument </returns>
            <exception cref="!:NumberFormatException"> if the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Oversize(System.Int32,System.Int32)">
             <summary>
             Returns an array size &gt;= minTargetSize, generally
              over-allocating exponentially to achieve amortized
              linear-time cost as the array grows.
            
              NOTE: this was originally borrowed from Python 2.4.2
              listobject.c sources (attribution in LICENSE.txt), but
              has now been substantially changed based on
              discussions from java-dev thread with subject "Dynamic
              array reallocation algorithms", started on Jan 12
              2010.
             </summary>
             <param name="minTargetSize"> Minimum required value to be returned. </param>
             <param name="bytesPerElement"> Bytes used by each element of
             the array.  See constants in <seealso cref="T:Lucene.Net.Util.RamUsageEstimator"/>.
            
             @lucene.internal </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns hash of chars in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns hash of bytes in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Char[],System.Int32,System.Char[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.ArrayUtil.naturalComparator``1">
            <summary>
            Get the natural <seealso cref="!:Comparator"/> for the provided object class. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>
            Swap values stored in slots <code>i</code> and <code>j</code> </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <seealso cref="!:Comparator"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <seealso cref="!:Comparator"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <seealso cref="!:Comparator"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <seealso cref="!:Comparator"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.AttributeImpl" -->
        <member name="M:Lucene.Net.Util.AttributeImpl.Clear">
            <summary>
            Clears the values in this AttributeImpl and resets it to its 
            default value. If this implementation implements more than one Attribute interface
            it clears all.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeImpl.ReflectAsString(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeImpl.ReflectWith(Lucene.Net.Util.IAttributeReflector)" -->
        <member name="M:Lucene.Net.Util.AttributeImpl.CopyTo(Lucene.Net.Util.AttributeImpl)">
            <summary>
            Copies the values from this Attribute into the passed-in
            target attribute. The target implementation must support all the
            Attributes this implementation supports.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeImpl.Clone">
            <summary>
            Shallow clone. Subclasses must override this if they 
            need to clone any members deeply,
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.Automaton" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Automaton.Automaton.MINIMIZE_HOPCROFT" -->
        <member name="F:Lucene.Net.Util.Automaton.Automaton.Minimization_Renamed">
            <summary>
            Selects minimization algorithm (default: <code>MINIMIZE_HOPCROFT</code>). </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.Initial">
            <summary>
            Initial state of this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.deterministic">
            <summary>
            If true, then this automaton is definitely deterministic (i.e., there are
            no choices for any run, but a run may crash).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.info">
            <summary>
            Extra data associated with this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.singleton">
            <summary>
            Singleton string. Null if not applicable. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.Minimize_always">
            <summary>
            Minimize always flag. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.Allow_mutation">
            <summary>
            Selects whether operations may modify the input automata (default:
            <code>false</code>).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.Automaton.#ctor(Lucene.Net.Util.Automaton.State)" -->
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then all automata
            operations may modify automata given as input; otherwise, operations will
            always leave input automata languages unmodified. By default, the flag is
            not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
            <returns> previous value of the flag </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Totalize">
            <summary>
            Adds transitions to explicit crash state to ensure that transition function
            is total.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.Automaton.RestoreInvariant" -->
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Reduce">
            <summary>
            Reduces this automaton. An automaton is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.RemoveDeadTransitions">
            <summary>
            Removes transitions to dead states and calls <seealso cref="!:#reduce()"/>.
            (A state is "dead" if no accept state is
            reachable from it.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ExpandSingleton">
            <summary>
            Expands singleton representation to normal representation. Does nothing if
            not in singleton representation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToDot">
            <summary>
            Returns <a href="http://www.research.att.com/sw/tools/graphviz/"
            target="_top">Graphviz Dot</a> representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpanded">
            <summary>
            Returns a clone of this automaton, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpandedIfRequired">
            <summary>
            Returns a clone of this automaton unless <code>allow_mutation</code> is
            set, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Clone">
            <summary>
            Returns a clone of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneIfRequired">
            <summary>
            Returns a clone of this automaton, or this automaton itself if
            <code>allow_mutation</code> flag is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#concatenate(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <seealso cref="!:BasicOperations#concatenate(List)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Optional">
            <summary>
            See <seealso cref="!:BasicOperations#optional(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32)">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton, int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32,System.Int32)">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton, int, int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Complement">
            <summary>
            See <seealso cref="!:BasicOperations#complement(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minus(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#minus(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Intersection(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#intersection(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SubsetOf(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#subsetOf(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#union(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <seealso cref="!:BasicOperations#union(Collection)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Determinize">
            <summary>
            See <seealso cref="!:BasicOperations#determinize(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minimize(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:MinimizationOperations#minimize(Automaton)"/>. Returns the
            automaton being given as argument.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Minimization">
            <summary>
            Selects minimization algorithm (default: <code>MINIMIZE_HOPCROFT</code>).
            </summary>
            <param name="algorithm"> minimization algorithm </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.MinimizeAlways">
            <summary>
            Sets or resets minimize always flag. If this flag is set, then
            <seealso cref="!:MinimizationOperations#minimize(Automaton)"/> will automatically be
            invoked after all operations that otherwise may produce non-minimal
            automata. By default, the flag is not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.AllowMutate">
            <summary>
            Returns the state of the allow mutate flag. If this flag is set, then all
            automata operations may modify automata given as input; otherwise,
            operations will always leave input automata languages unmodified. By
            default, the flag is not set.
            </summary>
            <returns> current value of the flag </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Singleton">
            <summary>
            Returns the singleton string for this automaton. An automaton that accepts
            exactly one string <i>may</i> be represented in singleton mode. In that
            case, this method may be used to obtain the string.
            </summary>
            <returns> string, null if this automaton is not in singleton mode. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.InitialState">
            <summary>
            Gets initial state.
            </summary>
            <returns> state </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Deterministic">
            <summary>
            Returns deterministic flag for this automaton.
            </summary>
            <returns> true if the automaton is definitely deterministic, false if the
                    automaton may be nondeterministic </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Info">
            <summary>
            Associates extra information with this automaton.
            </summary>
            <param name="info"> extra information </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.AcceptStates">
            <summary>
            Returns the set of reachable accept states.
            </summary>
            <returns> set of <seealso cref="T:Lucene.Net.Util.Automaton.State"/> objects </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.StartPoints">
            <summary>
            Returns sorted array of all interval start points.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.LiveStates">
            <summary>
            Returns the set of live states. A state is "live" if an accept state is
            reachable from it.
            </summary>
            <returns> set of <seealso cref="T:Lucene.Net.Util.Automaton.State"/> objects </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.SortedTransitions">
            <summary>
            Returns a sorted array of transitions for each state (and sets state
            numbers).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.NumberOfStates">
            <summary>
            Returns the number of states in this automaton.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.NumberOfTransitions">
            <summary>
            Returns the number of transitions in this automaton. this number is counted
            as the total number of edges, where one edge may be a character interval.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.EmptyString">
            <summary>
            See <seealso cref="!:BasicOperations#isEmptyString(Automaton)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicAutomata">
             <summary>
             Construction of basic automata.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmpty">
            <summary>
            Returns a new (deterministic) automaton with the empty language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmptyString">
            <summary>
            Returns a new (deterministic) automaton that accepts only the empty string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyString">
            <summary>
            Returns a new (deterministic) automaton that accepts all strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyChar">
            <summary>
            Returns a new (deterministic) automaton that accepts any single codepoint.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeChar(System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint of
            the given value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeCharRange(System.Int32,System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint whose
            value is in the given interval (including both end points).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AnyOfRightLength(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of length
            x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtLeast(System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at least
            x.substring(n) and length x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtMost(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at most
            x.substring(n) and length x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.Between(System.String,System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value between
            x.substring(n) and y.substring(n) and of length x.substring(n).length()
            (which must be equal to y.substring(n).length()).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeInterval(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new automaton that accepts strings representing decimal
            non-negative integers in the given interval.
            </summary>
            <param name="min"> minimal value of interval </param>
            <param name="max"> maximal value of interval (both end points are included in the
                     interval) </param>
            <param name="digits"> if &gt;0, use fixed number of digits (strings must be prefixed
                     by 0's to obtain the right length) - otherwise, the number of
                     digits is not fixed </param>
            <exception cref="!:IllegalArgumentException"> if min&gt;max or if numbers in the
                         interval cannot be expressed with the given fixed number of
                         digits </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeString(System.String)">
            <summary>
            Returns a new (deterministic) automaton that accepts the single given
            string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeStringUnion(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns a new (deterministic and minimal) automaton that accepts the union
            of the given collection of <seealso cref="T:Lucene.Net.Util.BytesRef"/>s representing UTF-8 encoded
            strings.
            </summary>
            <param name="utf8Strings">
                     The input strings, UTF-8 encoded. The collection must be in sorted
                     order.
            </param>
            <returns> An <seealso cref="T:Lucene.Net.Util.Automaton.Automaton"/> accepting all input strings. The resulting
                    automaton is codepoint based (full unicode codepoints on
                    transitions). </returns>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicOperations">
             <summary>
             Basic automata operations.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Optional(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Complement(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Minus(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Intersection(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.SameLanguage(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if these two automata accept exactly the
             same language.  this is a costly computation!  Note
             also that a1 and a2 will be determinized as a side
             effect.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.SubsetOf(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Union(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Determinize(Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.AddEpsilons(Lucene.Net.Util.Automaton.Automaton,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.StatePair})">
            <summary>
            Adds epsilon transitions to the given automaton. this method adds extra
            character interval transitions that are equivalent to the given set of
            epsilon transitions.
            </summary>
            <param name="pairs"> collection of <seealso cref="T:Lucene.Net.Util.Automaton.StatePair"/> objects representing pairs of
                     source/destination states where epsilon transitions should be
                     added </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmptyString(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts the empty string and nothing
            else.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmpty(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts no strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsTotal(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts all strings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Run(Lucene.Net.Util.Automaton.Automaton,System.String)" -->
        <member name="T:Lucene.Net.Util.Automaton.ByteRunAutomaton">
            <summary>
            Automaton representation for matching UTF-8 byte[].
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.RunAutomaton">
             <summary>
             Finite-state automaton with fast run operation.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.IsAccept(System.Int32)">
            <summary>
            Returns acceptance status for given state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.GetCharClass(System.Int32)">
            <summary>
            Gets character class of given codepoint
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Boolean)">
            <summary>
            Constructs a new <code>RunAutomaton</code> from a deterministic
            <code>Automaton</code>.
            </summary>
            <param name="a"> an automaton </param>
            <param name="maxInterval"></param>
            <param name="tableize"></param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.Step(System.Int32,System.Int32)">
            <summary>
            Returns the state obtained by reading the given char from the given state.
            Returns -1 if not obtaining any such state. (If the original
            <code>Automaton</code> had no dead states, -1 is returned here if and only
            if a dead state is entered in an equivalent automaton with a total
            transition function.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.Size">
            <summary>
            Returns number of states in automaton.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.InitialState">
            <summary>
            Returns initial state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.CharIntervals">
            <summary>
            Returns array of codepoint class interval start points. The array should
            not be modified by the caller.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Boolean)">
            <summary>
            expert: if utf8 is true, the input is already byte-based </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.Run(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns true if the given byte array is accepted by this automaton
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CharacterRunAutomaton">
            <summary>
            Automaton representation for matching char[].
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.String)">
            <summary>
            Returns true if the given string is accepted by this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns true if the given string is accepted by this automaton
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton">
             <summary>
             Immutable class holding compiled details for a given
             Automaton.  The Automaton is deterministic, must not have
             dead states but is not necessarily minimal.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.Term">
            <summary>
            For <seealso cref="!:AUTOMATON_TYPE#PREFIX"/>, this is the prefix term;
            for <seealso cref="!:AUTOMATON_TYPE#SINGLE"/> this is the singleton term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.RunAutomaton">
            <summary>
            Matcher for quickly determining if a byte[] is accepted.
            only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.SortedTransitions">
            <summary>
            Two dimensional array of transitions, indexed by state
            number for traversal. The state numbering is consistent with
            <seealso cref="!:#runAutomaton"/>.
            Only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.CommonSuffixRef">
            <summary>
            Shared common suffix accepted by the automaton. Only valid
            for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>, and only when the
            automaton accepts an infinite language.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.Finite">
            <summary>
            Indicates if the automaton accepts a finite set of strings.
            Null if this was not computed.
            Only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.CompiledAutomaton.Floor(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)" -->
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE">
            <summary>
            Automata are compiled into different internal forms for the
            most efficient execution depending upon the language they accept.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NONE">
            <summary>
            Automaton that accepts no strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.ALL">
            <summary>
            Automaton that accepts all possible strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.SINGLE">
            <summary>
            Automaton that accepts only a single fixed string. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.PREFIX">
            <summary>
            Automaton that matches all Strings with a constant prefix. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL">
            <summary>
            Catch-all for any other automata. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder" -->
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.StateRegistry">
            <summary>
            A "registry" for state interning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Root">
            <summary>
            Root automaton state.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Previous_Renamed">
            <summary>
            Previous sequence added to the automaton in <seealso cref="!:#add(CharsRef)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Comparator">
            <summary>
            A comparator used for enforcing sorted UTF8 order, used in assertions only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Add(Lucene.Net.Util.CharsRef)">
            <summary>
            Add another character sequence to this automaton. The sequence must be
            lexicographically larger or equal compared to any previous sequences added
            to this automaton (the input must be sorted).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Complete">
            <summary>
            Finalize the automaton and return the root state. No more strings can be
            added to the builder after this call.
            </summary>
            <returns> Root automaton state. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Convert(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Support.IdentityHashMap{Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Util.Automaton.State})">
            <summary>
            Internal recursive traversal for conversion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Build(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Build a minimal, deterministic automaton from a sorted list of <seealso cref="T:Lucene.Net.Util.BytesRef"/> representing
            strings in UTF-8. These strings must be binary-sorted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.SetPrevious(Lucene.Net.Util.CharsRef)">
            <summary>
            Copy <code>current</code> into an internal buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.ReplaceOrRegister(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace last child of <code>state</code> with an already registered state
            or stateRegistry the last child state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.AddSuffix(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Support.ICharSequence,System.Int32)">
            <summary>
            Add a suffix of <code>current</code> starting at <code>fromIndex</code>
            (inclusive) to state <code>state</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State">
            <summary>
            DFSA state with <code>char</code> labels on transitions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_LABELS">
            <summary>
            An empty set of labels. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_STATES">
            <summary>
            An empty set of states. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.Labels">
            <summary>
            Labels of outgoing transitions. Indexed identically to <seealso cref="!:#states"/>.
            Labels must be sorted lexicographically.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.States">
            <summary>
            States reachable from outgoing transitions. Indexed identically to
            <seealso cref="!:#labels"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.Is_final">
            <summary>
            <code>true</code> if this state corresponds to the end of at least one
            input sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetState(System.Int32)">
            <summary>
            Returns the target state of a transition leaving this state and labeled
            with <code>label</code>. If no such transition exists, returns
            <code>null</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.Equals(System.Object)" -->
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetHashCode">
            <summary>
            Compute the hash code of the <i>current</i> status of this state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.HasChildren">
            <summary>
            Return <code>true</code> if this state has any children (outgoing
            transitions).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NewState(System.Int32)">
            <summary>
            Create a new outgoing transition labeled <code>label</code> and return
            the newly created target state for this transition.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild">
            <summary>
            Return the most recent transitions's target state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild(System.Int32)">
            <summary>
            Return the associated state if the most recent transition is labeled with
            <code>label</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReplaceLastChild(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace the last added outgoing transition's target state with the given
            state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReferenceEquals(System.Object[],System.Object[])">
            <summary>
            Compare two lists of objects for reference-equality.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1 </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.LevenshteinAutomata" -->
        <member name="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new LevenshteinAutomata for some input String.
            Optionally count transpositions as a primitive edit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Expert: specify a custom maximum possible symbol
            (alphaMax); default is Character.MAX_CODE_POINT.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ToAutomaton(System.Int32)" -->
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.GetVector(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the characteristic vector <code>X(x, V)</code>
            where V is <code>substring(pos, end)</code>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription" -->
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Size">
            <summary>
            Return the number of states needed to compute a Levenshtein DFA
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.IsAccept(System.Int32)">
            <summary>
            Returns true if the <code>state</code> in any Levenshtein DFA is an accept state (final state).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.GetPosition(System.Int32)">
            <summary>
            Returns the position in the input word for a given <code>state</code>.
            this is the minimal boundary for the state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Transition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the state number for a transition from the given <code>state</code>,
            assuming <code>position</code> and characteristic vector <code>vector</code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1,
               with transpositions as primitive edits
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2,
               with transpositions as primitive edits
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.MinimizationOperations">
             <summary>
             Operations for minimizing automata.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.MinimizationOperations.Minimize(Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.MinimizationOperations.MinimizeHopcroft(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Minimizes the given automaton using Hopcroft's algorithm.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.RegExp" -->
        <member name="F:Lucene.Net.Util.Automaton.RegExp.INTERSECTION">
            <summary>
            Syntax flag, enables intersection (<tt>&amp;</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.COMPLEMENT">
            <summary>
            Syntax flag, enables complement (<tt>~</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.EMPTY">
            <summary>
            Syntax flag, enables empty language (<tt>#</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.ANYSTRING">
            <summary>
            Syntax flag, enables anystring (<tt>@</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.AUTOMATON">
            <summary>
            Syntax flag, enables named automata (<tt>&lt;</tt>identifier<tt>&gt;</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.INTERVAL">
            <summary>
            Syntax flag, enables numerical intervals (
            <tt>&lt;<i>n</i>-<i>m</i>&gt;</tt>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.ALL">
            <summary>
            Syntax flag, enables all optional regexp syntax.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExp.NONE">
            <summary>
            Syntax flag, enables no optional regexp syntax.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String)">
            <summary>
            Constructs new <code>RegExp</code> from a string. Same as
            <code>RegExp(s, ALL)</code>.
            </summary>
            <param name="s"> regexp string </param>
            <exception cref="!:IllegalArgumentException"> if an error occured while parsing the
                         regular expression </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String,System.Int32)">
            <summary>
            Constructs new <code>RegExp</code> from a string.
            </summary>
            <param name="s"> regexp string </param>
            <param name="syntax_flags"> boolean 'or' of optional syntax constructs to be
                     enabled </param>
            <exception cref="!:IllegalArgumentException"> if an error occured while parsing the
                         regular expression </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. Same
            as <code>toAutomaton(null)</code> (empty automaton map).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(Lucene.Net.Util.Automaton.AutomatonProvider)">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automaton_provider"> provider of automata for named identifiers </param>
            <exception cref="!:IllegalArgumentException"> if this regular expression uses a named
                         identifier that is not available from the automaton provider </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automata"> a map from automaton identifiers to automata (of type
                     <code>Automaton</code>). </param>
            <exception cref="!:IllegalArgumentException"> if this regular expression uses a named
                         identifier that does not occur in the automaton map </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then automata
            construction uses mutable automata, which is slightly faster but not thread
            safe. By default, the flag is not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
            <returns> previous value of the flag </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToString">
            <summary>
            Constructs string from parsed regular expression.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RegExp.Identifiers">
            <summary>
            Returns set of automaton identifiers that occur in this regular expression.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SpecialOperations">
             <summary>
             Special automata operations.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.FindIndex(System.Int32,System.Int32[])">
            <summary>
            Finds the largest entry whose value is less than or equal to c, or 0 if
            there is no such entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the language of this automaton is finite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.State,System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Checks whether there is a loop containing s. (this is sufficient since
            there are never transitions to dead states.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonPrefix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a prefix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> common prefix </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonSuffix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a suffix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> common suffix </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.Reverse(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Reverses the language of the given (non-singleton) automaton while returning
            the set of new initial states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.Automaton,System.Int32)">
            <summary>
            Returns the set of accepted strings, assuming that at most
            <code>limit</code> strings are accepted. If more than <code>limit</code>
            strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then
            the limit is infinite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.State,System.Collections.Generic.HashSet{Lucene.Net.Util.Automaton.State},System.Collections.Generic.HashSet{Lucene.Net.Util.IntsRef},Lucene.Net.Util.IntsRef,System.Int32)">
            <summary>
            Returns the strings that can be produced from the given state, or
            false if more than <code>limit</code> strings are found.
            <code>limit</code>&lt;0 means "infinite".
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.State">
             <summary>
             <tt>Automaton</tt> state.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.#ctor">
            <summary>
            Constructs a new state. Initially, the new state is a reject state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.ResetTransitions">
            <summary>
            Resets transition set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.AddTransition(Lucene.Net.Util.Automaton.Transition)">
            <summary>
            Adds an outgoing transition.
            </summary>
            <param name="t"> transition </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.State.Step(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.State.Step(System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State})" -->
        <member name="M:Lucene.Net.Util.Automaton.State.AddEpsilon(Lucene.Net.Util.Automaton.State)">
            <summary>
            Virtually adds an epsilon transition to the target
             {@code to} state.  this is implemented by copying all
             transitions from {@code to} to this state, and if {@code
             to} is an accept state then set accept for this state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.TrimTransitionsArray">
            <summary>
            Downsizes transitionArray to numTransitions </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.Reduce">
            <summary>
            Reduces this state. A state is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.SortTransitions(System.Collections.Generic.IComparer{Lucene.Net.Util.Automaton.Transition})">
            <summary>
            Sorts transitions array in-place. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.ToString">
            <summary>
            Returns string describing this state. Normally invoked via
            <seealso cref="!:Automaton#toString()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.CompareTo(Lucene.Net.Util.Automaton.State)">
            <summary>
            Compares this object with the specified object for order. States are
            ordered by the time of construction.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.State.Transitions">
            <summary>
            Returns the set of outgoing transitions. Subsequent changes are reflected
            in the automaton.
            </summary>
            <returns> transition set </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.State.Accept">
            <summary>
            Sets acceptance for this state.
            </summary>
            <param name="accept"> if true, this state is an accept state </param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.Automaton.State.Number" -->
        <member name="T:Lucene.Net.Util.Automaton.StatePair">
             <summary>
             Pair of states.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.#ctor(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new state pair.
            </summary>
            <param name="s1"> first state </param>
            <param name="s2"> second state </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> object to compare with </param>
            <returns> true if <tt>obj</tt> represents the same pair of states as this
                    pair </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.GetHashCode">
            <summary>
            Returns hash code.
            </summary>
            <returns> hash code </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.FirstState">
            <summary>
            Returns first component of this pair.
            </summary>
            <returns> first state </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.SecondState">
            <summary>
            Returns second component of this pair.
            </summary>
            <returns> second state </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.Transition" -->
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new singleton interval transition.
            </summary>
            <param name="c"> transition codepoint </param>
            <param name="to"> destination state </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new transition. Both end points are included in the interval.
            </summary>
            <param name="min"> transition interval minimum </param>
            <param name="max"> transition interval maximum </param>
            <param name="to"> destination state </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> object to compare with </param>
            <returns> true if <tt>obj</tt> is a transition with same character interval
                    and destination state as this transition. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.GetHashCode">
            <summary>
            Returns hash code. The hash code is based on the character interval (not
            the destination state).
            </summary>
            <returns> hash code </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Clone">
            <summary>
            Clones this transition.
            </summary>
            <returns> clone with same character interval and destination state </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.ToString">
            <summary>
            Returns a string describing this state. Normally invoked via
            <seealso cref="!:Automaton#toString()"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Min">
            <summary>
            Returns minimum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Max">
            <summary>
            Returns maximum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Dest">
            <summary>
            Returns destination of this transition. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.UTF32ToUTF8">
            <summary>
            Converts UTF-32 automata to the equivalent UTF-8 representation.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.UTF32ToUTF8.Convert(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Converts an incoming utf32 automaton to an equivalent
             utf8 one.  The incoming automaton need not be
             deterministic.  Note that the returned automaton will
             not in general be deterministic, so you must
             determinize it if that's needed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits_MatchAllBits">
            <summary>
            Bits impl of the specified length with all bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits_MatchNoBits">
            <summary>
            Bits impl of the specified length with no bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BitUtil">
            <summary>
             A variety of high efficiency bit twiddling routines.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.BitUtil.BIT_LISTS" -->
        <member name="M:Lucene.Net.Util.BitUtil.BitCount(System.Byte)">
            <summary>
            Return the number of bits sets in b. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BitUtil.BitList(System.Byte)" -->
        <member name="M:Lucene.Net.Util.BitUtil.Pop_array(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the number of set bits in an array of longs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_intersect(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the two sets after an intersection.
             Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_union(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the union of two sets.
             Neither array is modified.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BitUtil.Pop_andnot(System.Int64[],System.Int64[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.BitUtil.Pop_xor(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of A ^ B
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int32)">
            <summary>
            returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int64)">
            <summary>
            returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.BroadWord" -->
        <member name="F:Lucene.Net.Util.BroadWord.L8_L">
            <summary>
            Lk denotes the constant whose ones are in position 0, k, 2k, . . .
             These contain the low bit of each group of k bits.
             The suffix _L indicates the long implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.BitCount(System.Int64)">
            <summary>
            Bit count of a long.
            Only here to compare the implementation with <seealso cref="!:#select(long,int)"/>,
            normally <seealso cref="!:Long#bitCount"/> is preferable. </summary>
            <returns> The total number of 1 bits in x. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)">
            <summary>
            Select a 1-bit from a long. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BroadWord.SmallerUpTo7_8(System.Int64,System.Int64)" -->
        <member name="M:Lucene.Net.Util.BroadWord.Smalleru_8(System.Int64,System.Int64)">
            <summary>
            An unsigned bytewise smaller &lt;<sub><small>8</small></sub> operator.
            this uses the following numbers of basic long operations: 3 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H8_L"/> positions corresponding to each input unsigned byte pair that compares smaller. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.NotEquals0_8(System.Int64)">
            <summary>
            An unsigned bytewise not equals 0 operator.
            this uses the following numbers of basic long operations: 2 or, 1 and, 1 minus. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H8_L"/> positions corresponding to each unsigned byte that does not equal 0. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.SmallerUpto15_16(System.Int64,System.Int64)">
            <summary>
            A bytewise smaller &lt;<sub><small>16</small></sub> operator.
            this uses the following numbers of basic long operations: 1 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H16_L"/> positions corresponding to each input signed short pair that compares smaller. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.BroadWord.H8_L" -->
        <member name="M:Lucene.Net.Util.BroadWord.SelectNaive(System.Int64,System.Int32)">
            <summary>
            Naive implementation of <seealso cref="!:#select(long,int)"/>, using <seealso cref="!:Long#numberOfTrailingZeros"/> repetitively.
            Works relatively fast for low ranks. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool">
             <summary>
             Class that Posting and PostingVector use to write byte
             streams into shared fixed-size byte[] arrays.  The idea
             is to allocate slices of increasing lengths For
             example, the first slice is 5 bytes, the next slice is
             14, etc.  We start by writing our bytes into the first
             5 bytes.  When we hit the end of the slice, we allocate
             the next slice and then write the address of the new
             slice into the last 4 bytes of the previous slice (the
             "forwarding address").
            
             Each slice is filled with 0's initially, and we mark
             the end with a non-zero byte.  this way the methods
             that are writing into the slice don't need to record
             its length and instead allocate a new slice once they
             hit a non-zero byte.
            
             @lucene.internal
            
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.Buffers">
            <summary>
            array of buffers currently used in the pool. Buffers are allocated if
            needed don't modify this outside of this class.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.BufferUpto">
            <summary>
            index into the buffers array pointing to the current buffer used as the head </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.ByteUpto">
            <summary>
            Where we are in head buffer </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.Buffer">
            <summary>
            Current head buffer
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.ByteOffset">
            <summary>
            Current head offset </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer and fills all
            buffers with <tt>0</tt> bytes before they reused or passed to
            <seealso cref="!:Allocator#recycleByteBlocks(byte[][], int, int)"/>. Calling
            <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. Calling
            <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset. </summary>
            <param name="zeroFillBuffers"> if <code>true</code> the buffers are filled with <tt>0</tt>.
                   this should be set to <code>true</code> if this pool is used with slices. </param>
            <param name="reuseFirst"> if <code>true</code> the first buffer will be reused and calling
                   <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset iff the
                   block pool was used before ie. <seealso cref="!:ByteBlockPool#nextBuffer()"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. this method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <seealso cref="!:ByteBlockPool#reset()"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NewSlice(System.Int32)">
            <summary>
            Allocates a new slice with the given size.</summary>
            <seealso>ByteBlockPool#FIRST_LEVEL_SIZE</seealso>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <seealso cref="!:ByteBlockPool#LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for byte slices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.ByteBlockPool.FIRST_LEVEL_SIZE" -->
        <member name="M:Lucene.Net.Util.ByteBlockPool.AllocSlice(System.Byte[],System.Int32)">
            <summary>
            Creates a new byte slice with the given starting size and
            returns the slices offset in the pool.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends the bytes in the provided <seealso cref="T:Lucene.Net.Util.BytesRef"/> at
            the current position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.ReadBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes bytes out of the pool starting at the given offset with the given
            length into the given byte array at offset <tt>off</tt>.
            <p>Note: this method allows to copy across block boundaries.</p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing byte
             blocks.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectTrackingAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles, but
             tracks how much total RAM is in use.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.BytesRef" -->
        <member name="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES">
            <summary>
            An empty byte array for convenience </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor">
            <summary>
            Create a BytesRef with <seealso cref="!:#EMPTY_BYTES"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference bytes w/o making a copy.
            bytes should not be null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[])">
            <summary>
            this instance will directly reference bytes w/o making a copy.
            bytes should not be null
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Int32)">
            <summary>
            Create a BytesRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(Lucene.Net.Util.CharsRef)">
            <summary>
            Initialize the byte[] from the UTF8 bytes
            for the provided String.
            </summary>
            <param name="text"> this must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.String)">
            <summary>
            Initialize the byte[] from the UTF8 bytes
            for the provided String.
            </summary>
            <param name="text"> this must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(Lucene.Net.Util.CharsRef)">
            <summary>
            Copies the UTF8 bytes for this string.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(System.String)">
            <summary>
            Copies the UTF8 bytes for this string.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.BytesEquals(Lucene.Net.Util.BytesRef)">
            <summary>
            Expert: compares the bytes against another BytesRef,
            returning true if the bytes are equal.
            </summary>
            <param name="other"> Another BytesRef, should not be null.
            @lucene.internal </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.Clone" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.GetHashCode" -->
        <member name="M:Lucene.Net.Util.BytesRef.Utf8ToString">
            <summary>
            Interprets stored bytes as UTF8 bytes, returning the
             resulting string
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.ToString">
            <summary>
            Returns hex encoded bytes, eg [0x6c 0x75 0x63 0x65 0x6e 0x65] </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.CopyBytes(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.Append(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.BytesRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CompareTo(System.Object)">
            <summary>
            Unsigned byte order comparison </summary>
        </member>
        <member name="F:Lucene.Net.Util.BytesRef.Utf8SortedAsUTF16SortOrder">
            @deprecated this comparator is only a transition mechanism
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.DeepCopyOf(Lucene.Net.Util.BytesRef)" -->
        <member name="P:Lucene.Net.Util.BytesRef.Bytes">
            <summary>
            The contents of the BytesRef. Should never be {@code null}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Offset">
            <summary>
            Offset of first valid byte.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Length">
            <summary>
            Length of used bytes.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUTF16Comparer">
            @deprecated this comparator is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Valid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRef.UTF8SortedAsUTF16Comparator">
            @deprecated this comparator is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.BytesRefArray">
             <summary>
             A simple append only random-access <seealso cref="T:Lucene.Net.Util.BytesRef"/> array that stores full
             copies of the appended bytes in a <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/>.
            
            
             <b>Note: this class is not Thread-Safe!</b>
            
             @lucene.internal
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.#ctor(Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> with a counter to track allocated bytes
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Clear">
            <summary>
            Clears this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends a copy of the given <seealso cref="T:Lucene.Net.Util.BytesRef"/> to this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/>. </summary>
            <param name="bytes"> the bytes to append </param>
            <returns> the index of the appended bytes </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Size">
            <summary>
            Returns the current size of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </summary>
            <returns> the current size of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Get(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Returns the <i>n'th</i> element of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </summary>
            <param name="spare"> a spare <seealso cref="T:Lucene.Net.Util.BytesRef"/> instance </param>
            <param name="index"> the elements index to retrieve </param>
            <returns> the <i>n'th</i> element of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Iterator">
            <summary>
            sugar for <seealso cref="!:#iterator(Comparator)"/> with a <code>null</code> comparator
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Iterator(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            <p>
            Returns a <seealso cref="T:Lucene.Net.Util.BytesRefIterator"/> with point in time semantics. The
            iterator provides access to all so far appended <seealso cref="T:Lucene.Net.Util.BytesRef"/> instances.
            </p>
            <p>
            If a non <code>null</code> <seealso cref="!:Comparator"/> is provided the iterator will
            iterate the byte values in the order specified by the comparator. Otherwise
            the order is the same as the values were appended.
            </p>
            <p>
            this is a non-destructive operation.
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.CharsRef">
            <summary>
            Represents char[], as a slice (offset + Length) into an existing char[].
            The <seealso cref="!:#chars"/> member should never be null; use
            <seealso cref="!:#EMPTY_CHARS"/> if necessary.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.EMPTY_CHARS">
            <summary>
            An empty character array for convenience </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized an empty array zero-Length
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with an array of the given
            capacity
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given array, offset and
            Length
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.String)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given Strings character
            array
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.CharsRef.Clone" -->
        <member name="M:Lucene.Net.Util.CharsRef.CompareTo(Lucene.Net.Util.CharsRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(Lucene.Net.Util.CharsRef)">
            <summary>
            Copies the given <seealso cref="T:Lucene.Net.Util.CharsRef"/> referenced content into this instance.
            </summary>
            <param name="other">
                     the <seealso cref="T:Lucene.Net.Util.CharsRef"/> to copy </param>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the given array into this CharsRef.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends the given array to this CharsRef
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.Utf16SortedAsUTF8SortOrder">
            @deprecated this comparator is only a transition mechanism
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.CharsRef.DeepCopyOf(Lucene.Net.Util.CharsRef)" -->
        <member name="P:Lucene.Net.Util.CharsRef.Chars">
            <summary>
            The contents of the CharsRef. Should never be {@code null}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Offset">
            <summary>
            Offset of first valid character. </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Length">
            <summary>
            Length of used characters. </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.UTF16SortedAsUTF8Comparer">
            @deprecated this comparator is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Valid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.CharsRef.UTF16SortedAsUTF8Comparator">
            @deprecated this comparator is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.CollectionUtil">
             <summary>
             Methods for manipulating (sorting) collections.
             Sort methods work directly on the supplied lists and don't copy to/from arrays
             before/after. For medium size collections as used in the Lucene indexer that is
             much more efficient.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given random access <seealso cref="!:List"/> using the <seealso cref="!:Comparator"/>.
            The list must implement <seealso cref="!:RandomAccess"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. </summary>
            <exception cref="!:IllegalArgumentException"> if list is e.g. a linked list without random access. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given random access <seealso cref="!:List"/> in natural order.
            The list must implement <seealso cref="!:RandomAccess"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. </summary>
            <exception cref="!:IllegalArgumentException"> if list is e.g. a linked list without random access. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given random access <seealso cref="!:List"/> using the <seealso cref="!:Comparator"/>.
            The list must implement <seealso cref="!:RandomAccess"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small lists. </summary>
            <exception cref="!:IllegalArgumentException"> if list is e.g. a linked list without random access. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given random access <seealso cref="!:List"/> in natural order.
            The list must implement <seealso cref="!:RandomAccess"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small lists. </summary>
            <exception cref="!:IllegalArgumentException"> if list is e.g. a linked list without random access. </exception>
        </member>
        <member name="T:Lucene.Net.Util.CommandLineUtil">
             <summary>
             Class containing some useful methods used by command line tools
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.String,System.IO.DirectoryInfo)">
            <summary>
            Creates a specific FSDirectory instance starting from its class name </summary>
            <param name="clazzName"> The name of the FSDirectory class to load </param>
            <param name="file"> The file to be used as parameter constructor </param>
            <returns> the new FSDirectory instance </returns>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadDirectoryClass(System.String)">
            <summary>
            Loads a specific Directory implementation </summary>
            <param name="clazzName"> The name of the Directory class to load </param>
            <returns> The Directory class loaded </returns>
            <exception cref="!:ClassNotFoundException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadFSDirectoryClass(System.String)">
            <summary>
            Loads a specific FSDirectory implementation </summary>
            <param name="clazzName"> The name of the FSDirectory class to load </param>
            <returns> The FSDirectory class loaded </returns>
            <exception cref="!:ClassNotFoundException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.Type,System.IO.DirectoryInfo)">
            <summary>
            Creates a new specific FSDirectory instance </summary>
            <param name="clazz"> The class of the object to be created </param>
            <param name="file"> The file to be used as parameter constructor </param>
            <returns> The new FSDirectory instance </returns>
            <exception cref="!:NoSuchMethodException"> If the Directory does not have a constructor that takes <code>File</code>. </exception>
            <exception cref="!:InstantiationException"> If the class is abstract or an interface. </exception>
            <exception cref="!:IllegalAccessException"> If the constructor does not have public visibility. </exception>
            <exception cref="!:InvocationTargetException"> If the constructor throws an exception </exception>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
             <summary>
             Some useful constants.
            
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.JAVA_VERSION">
            <summary>
            The value of <tt>System.getProperty("java.version")</tt>. * </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.OS_NAME">
            <summary>
            The value of <tt>System.getProperty("os.name")</tt>. * </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>
            True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>
            True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>
            True iff running on SunOS. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.MAC_OS_X">
            <summary>
            True iff running on Mac OS X </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.FREE_BSD">
            <summary>
            True iff running on FreeBSD </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.LUCENE_MAIN_VERSION" -->
        <member name="F:Lucene.Net.Util.Constants.LUCENE_VERSION">
            <summary>
            this is the Lucene version for display purposes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Constants.MainVersionWithoutAlphaBeta">
            <summary>
            Returns a LUCENE_MAIN_VERSION without any ALPHA/BETA qualifier
            Used by test only!
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Counter">
             <summary>
             Simple counter class
            
             @lucene.internal
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.AddAndGet(System.Int64)">
            <summary>
            Adds the given delta to the counters current value
            </summary>
            <param name="delta">
                     the delta to add </param>
            <returns> the counters updated value </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.Get">
            <summary>
            Returns the counters current value
            </summary>
            <returns> the counters current value </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter">
            <summary>
            Returns a new counter. The returned counter is not thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter(System.Boolean)">
            <summary>
            Returns a new counter.
            </summary>
            <param name="threadSafe">
                     <code>true</code> if the returned counter can be used by multiple
                     threads concurrently. </param>
            <returns> a new counter. </returns>
        </member>
        <member name="T:Lucene.Net.Util.DocIdBitSet">
            <summary>
            Simple DocIdSet and DocIdSetIterator backed by a BitSet </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.Cacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.BitSet">
            <summary>
            Returns the underlying BitSet.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache`2">
             <summary>
             Simple concurrent LRU cache, using a "double barrel"
             approach where two ConcurrentHashMaps record entries.
            
             <p>At any given time, one hash is primary and the other
             is secondary.  <seealso cref="!:#get"/> first checks primary, and if
             that's a miss, checks secondary.  If secondary has the
             entry, it's promoted to primary (<b>NOTE</b>: the key is
             cloned at this point).  Once primary is full, the
             secondary is cleared and the two are swapped.</p>
            
             <p>this is not as space efficient as other possible
             concurrent approaches (see LUCENE-2075): to achieve
             perfect LRU(N) it requires 2*N storage.  But, this
             approach is relatively simple and seems in practice to
             not grow unbounded in size when under hideously high
             load.</p>
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache`2.CloneableKey">
            <summary>
            Object providing clone(); the key class must subclass this. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FieldCacheSanityChecker" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.IFieldCache)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.FieldCache.CacheEntry[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.Check(Lucene.Net.Search.FieldCache.CacheEntry[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckValueMismatch(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32},System.Collections.Generic.ISet{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSubreaders(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32})" -->
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.GetAllDescendantReaderKeys(System.Object)">
            <summary>
            Checks if the seed is an IndexReader, and if so will walk
            the hierarchy of subReaders building up a list of the objects
            returned by {@code seed.getCoreCacheKey()}
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.RamUsageEstimator">
            <summary>
            If set, estimate size for all CacheEntry objects will be calculateed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.ReaderField">
            <summary>
            Simple pair object for using "readerKey + fieldName" a Map key
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity">
            <summary>
            Simple container for a collection of related CacheEntry objects that
            in conjunction with each other represent some "insane" usage of the
            FieldCache.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.ToString">
            <summary>
            Multi-Line representation of this Insanity object, starting with
            the Type and Msg, followed by each CacheEntry.toString() on it's
            own line prefaced by a tab character
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Type">
            <summary>
            Type of insane behavior this object represents
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Msg">
            <summary>
            Description of hte insane behavior
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.CacheEntries">
            <summary>
            CacheEntry objects which suggest a problem
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType" -->
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.SUBREADER">
            <summary>
            Indicates an overlap in cache usage on a given field
            in sub/super readers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.VALUEMISMATCH">
            <summary>
            <p>
            Indicates entries have the same reader+fieldname but
            different cached values.  this can happen if different datatypes,
            or parsers are used -- and while it's not necessarily a bug
            it's typically an indication of a possible problem.
            </p>
            <p>
            <b>NOTE:</b> Only the reader, fieldname, and cached value are actually
            tested -- if two cache entries have different parsers or datatypes but
            the cached values are the same Object (== not just equal()) this method
            does not consider that a red flag.  this allows for subtle variations
            in the way a Parser is specified (null vs DEFAULT_LONG_PARSER, etc...)
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.EXPECTED">
            <summary>
            Indicates an expected bit of "insanity".  this may be useful for
            clients that wish to preserve/log information about insane usage
            but indicate that it was expected.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FilterIterator`1" -->
        <member name="M:Lucene.Net.Util.FilterIterator`1.PredicateFunction(`0)">
            <summary>
            returns true, if this element should be returned by <seealso cref="!:#next()"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet">
             <summary>
             BitSet of fixed length (numBits), backed by accessible (<seealso cref="!:#getBits"/>)
             long[], accessed with an int index, implementing <seealso cref="M:Lucene.Net.Util.FixedBitSet.GetBits"/> and
             <seealso cref="T:Lucene.Net.Search.DocIdSet"/>. If you need to manage more than 2.1B bits, use
             <seealso cref="T:Lucene.Net.Util.LongBitSet"/>.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FixedBitSet.EnsureCapacity(Lucene.Net.Util.FixedBitSet,System.Int32)" -->
        <member name="M:Lucene.Net.Util.FixedBitSet.Bits2words(System.Int32)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.IntersectionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.UnionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets. Neither
            set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNotCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b" or
            "intersection(a, not(b))". Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
             long in the backing bits array, and the result is not
             internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the last set bit before or on the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place OR of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place XOR of the bits provided by the iterator. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Intersects(Lucene.Net.Util.FixedBitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND NOT of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Flip(System.Int32,System.Int32)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Set(System.Int32,System.Int32)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="P:Lucene.Net.Util.FixedBitSet.Cacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.FixedBitSet.Bits">
            <summary>
            Expert. </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> which iterates over set bits in a
            <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            Creates an iterator over the given <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Creates an iterator over the given array of bits. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ByteSequenceOutputs">
             <summary>
             An FST <seealso cref="!:Outputs"/> implementation where each output
             is a sequence of bytes.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Outputs`1">
             <summary>
             Represents the outputs for an FST, providing the basic
             algebra required for building and traversing the FST.
            
             <p>Note that any operation that returns NO_OUTPUT must
             return the same singleton object from {@link
             #getNoOutput}.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Common(`0,`0)">
            <summary>
            Eg common("foobar", "food") -> "foo" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Subtract(`0,`0)">
            <summary>
            Eg subtract("foobar", "foo") -> "bar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Add(`0,`0)">
            <summary>
            Eg add("foo", "bar") -> "foobar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an output value into a <seealso cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.WriteFinalOutput(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an final node output value into a {@link
             DataOutput}.  By default this just calls {@link #write(Object,
             DataOutput)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Read(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with {@link
             #write(Object, DataOutput)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.ReadFinalOutput(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with {@link
             #writeFinalOutput(Object, DataOutput)}.  By default this
             just calls <seealso cref="!:#read(DataInput)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Outputs`1.NoOutput">
            <summary>
            NOTE: this output is compared with == so you must
             ensure that all methods return the single object if
             it's really no output
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum`1">
             <summary>
             Enumerates all input (BytesRef) + output pairs in an
              FST.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FSTEnum`1">
             <summary>
             Can next() and advance() through the terms in an FST
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
             doFloor is true, advance positions to the biggest
             term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.RewindPrefix">
            <summary>
            Rewinds enum state to match the shared prefix between
             current term and target term
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekCeil">
            <summary>
            Seeks to smallest term that's >= target. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekFloor" -->
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekExact">
            <summary>
            Seeks to exactly target term. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
             doFloor is true, advance positions to the biggest
             term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to smallest term that's >= target. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekFloor(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to exactly this term, returning null if the term
             doesn't exist.  this is faster than using {@link
             #seekFloor} or <seealso cref="!:#seekCeil"/> because it
             short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.InputOutput`1">
            <summary>
            Holds a single input (BytesRef) + output pair. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.#ctor(Lucene.Net.Store.DataInput,System.Int64,System.Int32)">
            <summary>
            Pulls bytes from the provided IndexInput. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.BytesStore.WriteByte(System.Int32,System.Byte)" -->
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Absolute writeBytes without changing the current
             position.  Note: this cannot "grow" the bytes, so you
             must only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.CopyBytes(System.Int64,System.Int64,System.Int32)">
            <summary>
            Absolute copy bytes self to self, without changing the
             position. Note: this cannot "grow" the bytes, so must
             only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteInt(System.Int64,System.Int32)">
            <summary>
            Writes an int at the absolute position without
             changing the current pointer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Reverse(System.Int64,System.Int64)">
            <summary>
            Reverse from srcPos, inclusive, to destPos, inclusive. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Truncate(System.Int64)">
            <summary>
            Pos must be less than the max position written so far!
             Ie, you cannot "grow" the file with this!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Writes all of our bytes to the target <seealso cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.BytesReader">
            <summary>
            Reads bytes stored in an FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST">
            <summary>
            .NET Port: This new base class is to mimic Java's ability to use nested types without specifying
            a type parameter. i.e. FST.BytesReader instead of FST&lt;BytesRef&gt;.BytesReader
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_SHALLOW_DISTANCE">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_SHALLOW">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_DEEP">
            <summary>
            <see cref="T:Lucene.Net.Util.Fst.Builder`1.UnCompiledNode`1"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_INT_NUM_BYTES_PER_ARC">
            <summary>
            Changed numBytesPerArc for array'd case from byte to int.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_SHORT_BYTE2_LABELS">
            <summary>
            Write BYTE2 labels as 2-byte short, not vInt.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_PACKED">
            <summary>
            Added optional packed format.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_VINT_TARGET">
            <summary>
            Changed from int to vInt for encoding arc targets.
            Also changed maxBytesPerArc from int to vInt in the array case.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.BytesReader">
            <summary>
            Reads bytes stored in an FST.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.BytesReader.Reversed">
            <summary>
            Returns true if this reader uses reversed bytes
            under-the-hood.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.BytesReader.SkipBytes(System.Int32)">
            <summary>
            Skips bytes.
            </summary>
            <param name="count"></param>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.BytesReader.Position">
            <summary>
            Current read position
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.INPUT_TYPE">
            <summary>
            Specifies allowed range of each int input label for this FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.Arc`1">
            <summary>
            Represents a single arc.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.Arc`1.CopyFrom(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Return this
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.Target">
            <summary>
            To node (ord or address)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.CharSequenceOutputs">
             <summary>
             An FST <seealso cref="!:Outputs"/> implementation where each output
             is a sequence of characters.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ForwardBytesReader">
            <summary>
            Reads from a single byte[]. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Fst.FST`1" -->
        <member name="F:Lucene.Net.Util.Fst.FST`1.END_LABEL">
            <summary>
            If arc has this label then that arc is final/accepted </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Load a previously saved FST. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0},System.Int32)">
            <summary>
            Load a previously saved FST; maxBlockBits allows you to
             control the size of the byte[] pages used to hold the FST bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.SizeInBytes">
            <summary>
            Returns bytes used to represent the FST </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Save(System.IO.FileInfo)">
            <summary>
            Writes an automaton to a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Read``1(System.IO.FileInfo,Lucene.Net.Util.Fst.Outputs{``0})">
            <summary>
            Reads an automaton from a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.TargetHasArcs(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            returns true if the node at this address has any
             outgoing arcs
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetFirstArc(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Fills virtual 'start' arc, ie, an empty incoming arc to
             the FST's start node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadLastTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follows the <code>follow</code> arc and reads the last
             arc of its target; this changes the provided
             <code>arc</code> (2nd arg) in-place and returns it.
            </summary>
            <returns> Returns the second argument
            (<code>arc</code>).  </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadFirstTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follow the <code>follow</code> arc and read the first arc of its target;
            this changes the provided <code>arc</code> (2nd arg) in-place and returns
            it.
            </summary>
            <returns> Returns the second argument (<code>arc</code>). </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.IsExpandedTarget(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Checks if <code>arc</code>'s target state is in expanded (or vector) format.
            </summary>
            <returns> Returns <code>true</code> if <code>arc</code> points to a state in an
            expanded array format. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            In-place read; returns the arc. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArcLabel(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Peeks at next arc's label; does not alter arc.  Do
             not call this if arc.isLast()!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextRealArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Never returns null, but you should never call this if
             arc.isLast() is true.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.FindTargetArc(System.Int32,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Finds an arc leaving the incoming arc, replacing the arc in place.
             this returns null if the arc was not found, else the incoming arc.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.FST`1.ShouldExpand(Lucene.Net.Util.Fst.Builder{`0}.UnCompiledNode{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.FST`1.Pack(System.Int32,System.Int32,System.Single)" -->
        <member name="P:Lucene.Net.Util.Fst.FST`1.BytesReader">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/> for this FST, positioned at
             position 0.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.IntSequenceOutputs">
             <summary>
             An FST <seealso cref="!:Outputs"/> implementation where each output
             is a sequence of ints.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.IntsRefFSTEnum`1">
             <summary>
             Enumerates all input (IntsRef) + output pairs in an
              FST.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.IntsRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
             doFloor is true, advance positions to the biggest
             term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.IntsRefFSTEnum`1.SeekCeil(Lucene.Net.Util.IntsRef)">
            <summary>
            Seeks to smallest term that's >= target. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.IntsRefFSTEnum`1.SeekFloor(Lucene.Net.Util.IntsRef)" -->
        <member name="M:Lucene.Net.Util.Fst.IntsRefFSTEnum`1.SeekExact(Lucene.Net.Util.IntsRef)">
            <summary>
            Seeks to exactly this term, returning null if the term
             doesn't exist.  this is faster than using {@link
             #seekFloor} or <seealso cref="!:#seekCeil"/> because it
             short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.IntsRefFSTEnum`1.InputOutput`1">
            <summary>
            Holds a single input (IntsRef) + output pair. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.NoOutputs">
             <summary>
             A null FST <seealso cref="!:Outputs"/> implementation; use this if
             you just want to build an FSA.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2">
             <summary>
             An FST <seealso cref="!:Outputs"/> implementation, holding two other outputs.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.PairOutputs`2.NewPair(`0,`1)">
            <summary>
            Create a new Pair </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2.Pair">
            <summary>
            Holds a single pair of two outputs. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PositiveIntOutputs">
             <summary>
             An FST <seealso cref="!:Outputs"/> implementation where each output
             is a non-negative long value.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ReverseBytesReader">
            <summary>
            Reads in reverse from a single byte[]. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util">
             <summary>
             Static helper methods.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.IntsRef)">
            <summary>
            Looks up the output for this input, or null if the
             input is not accepted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.BytesRef)">
            <summary>
            Looks up the output for this input, or null if the
             input is not accepted
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64)" -->
        <member name="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64,Lucene.Net.Util.Fst.FST.BytesReader,Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.IntsRef)">
            <summary>
            Expert: like <seealso cref="!:Util#getByOutput(FST, long)"/> except reusing
            BytesReader, initial and scratch Arc, and result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.shortestPaths``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Boolean)">
            <summary>
            Starting from node, find the top N min cost
             completions to a final node.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Fst.Util.toDot``1(Lucene.Net.Util.Fst.FST{``0},System.IO.TextWriter,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Util.Fst.Util.EmitDotState(System.IO.TextWriter,System.String,System.String,System.String,System.String)">
            <summary>
            Emit a single state in the <code>dot</code> language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.PrintableLabel(System.Int32)">
            <summary>
            Ensures an arc's label is indeed printable (dot uses US-ASCII).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF16(System.String,Lucene.Net.Util.IntsRef)">
            <summary>
            Just maps each UTF16 unit (char) to the ints in an
             IntsRef.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.String,Lucene.Net.Util.IntsRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
             CharSequence and places them in the provided scratch
             IntsRef, which must not be null, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.IntsRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
             char[] and places them in the provided scratch
             IntsRef, which must not be null, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToIntsRef(Lucene.Net.Util.BytesRef,Lucene.Net.Util.IntsRef)">
            <summary>
            Just takes unsigned byte values from the BytesRef and
             converts into an IntsRef.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToBytesRef(Lucene.Net.Util.IntsRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Just converts IntsRef to BytesRef; you must ensure the
             int values fit into a byte.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.readCeilArc``1(System.Int32,Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Reads the first arc greater or equal that the given label into the provided
            arc in place and returns it iff found, otherwise return <code>null</code>.
            </summary>
            <param name="label"> the label to ceil on </param>
            <param name="fst"> the fst to operate on </param>
            <param name="follow"> the arc to follow reading the label from </param>
            <param name="arc"> the arc to read into in place </param>
            <param name="in"> the fst's <seealso cref="!:BytesReader"/> </param>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.FSTPath`1">
             <summary>
             Represents a path in TopNSearcher.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.FSTPath`1.#ctor(`0,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.IntsRef)">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TieBreakByInputComparator`1">
            <summary>
            Compares first by the provided comparator, and then
             tie breaks by path.input.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1">
            <summary>
            Utility class to find top N shortest paths from start
             point(s).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.#ctor(Lucene.Net.Util.Fst.FST{`0},System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an unbounded TopNSearcher </summary>
            <param name="fst"> the <seealso cref="T:Lucene.Net.Util.Fst.FST"/> to search on </param>
            <param name="topN"> the number of top scoring entries to retrieve </param>
            <param name="maxQueueDepth"> the maximum size of the queue of possible top entries </param>
            <param name="comparator"> the comparator to select the top N </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.AddStartPaths(Lucene.Net.Util.Fst.FST.Arc{`0},`0,System.Boolean,Lucene.Net.Util.IntsRef)">
            <summary>
            Adds all leaving arcs, including 'finished' arc, if
             the node is final, from this node into the queue.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.Result`1">
            <summary>
            Holds a single input (IntsRef) + output, returned by
             <seealso cref="!:#shortestPaths shortestPaths()"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopResults`1">
            <summary>
            Holds the results for a top N search using <seealso cref="!:TopNSearcher"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.Util.TopResults`1.IsComplete">
            <summary>
            <code>true</code> iff this is a complete result ie. if
            the specified queue size was large enough to find the complete list of results. this might
            be <code>false</code> if the <seealso cref="!:TopNSearcher"/> rejected too many results.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.Util.TopResults`1.TopN">
            <summary>
            The top results
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.GrowableByteArrayDataOutput">
            <summary>
            A <seealso cref="T:Lucene.Net.Store.DataOutput"/> that can be used to build a byte[].
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.GrowableByteArrayDataOutput.Bytes">
            <summary>
            The bytes </summary>
        </member>
        <member name="F:Lucene.Net.Util.GrowableByteArrayDataOutput.Length">
            <summary>
            The length </summary>
        </member>
        <member name="M:Lucene.Net.Util.GrowableByteArrayDataOutput.#ctor(System.Int32)">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Util.GrowableByteArrayDataOutput"/> with the given initial capacity. </summary>
        </member>
        <member name="T:Lucene.Net.Util.IndexableBinaryStringTools">
             <summary>
             Provides support for converting byte sequences to Strings and back again.
             The resulting Strings preserve the original byte sequences' sort order.
             <p/>
             The Strings are constructed using a Base 8000h encoding of the original
             binary data - each char of an encoded String represents a 15-bit chunk
             from the byte sequence.  Base 8000h was chosen because it allows for all
             lower 15 bits of char to be used without restriction; the surrogate range
             [U+D8000-U+DFFF] does not represent valid chars, and would require
             complicated handling to avoid them and allow use of char's high bit.
             <p/>
             Although unset bits are used as padding in the final char, the original
             byte sequence could contain trailing bytes with no set bits (null bytes):
             padding is indistinguishable from valid information.  To overcome this
             problem, a char is appended, indicating the number of encoded bytes in the
             final content char.
             <p/>
            
             @lucene.experimental </summary>
             @deprecated Implement <seealso cref="T:Lucene.Net.Analysis.Tokenattributes.ITermToBytesRefAttribute"/> and store bytes directly
             instead. this class will be removed in Lucene 5.0
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns the number of chars required to encode the given bytes.
            </summary>
            <param name="inputArray"> byte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of bytes in inputArray </param>
            <returns> The number of chars required to encode the number of bytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetDecodedLength(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the number of bytes required to decode the given char sequence.
            </summary>
            <param name="encoded"> char sequence to be decoded </param>
            <param name="offset"> initial offset </param>
            <param name="length"> number of characters </param>
            <returns> The number of bytes required to decode the given char sequence </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Encode(System.SByte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Encodes the input byte sequence into the output char sequence.  Before
            calling this method, ensure that the output array has sufficient
            capacity by calling <seealso cref="!:#getEncodedLength(byte[], int, int)"/>.
            </summary>
            <param name="inputArray"> byte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of bytes in inputArray </param>
            <param name="outputArray"> char sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be getEncodedLength </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Decode(System.Char[],System.Int32,System.Int32,System.SByte[],System.Int32,System.Int32)">
            <summary>
            Decodes the input char sequence into the output byte sequence. Before
            calling this method, ensure that the output array has sufficient capacity
            by calling <seealso cref="!:#getDecodedLength(char[], int, int)"/>.
            </summary>
            <param name="inputArray"> char sequence to be decoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of chars in inputArray </param>
            <param name="outputArray"> byte sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be
                   getDecodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.InfoStream" -->
        <member name="F:Lucene.Net.Util.InfoStream.NO_OUTPUT">
            <summary>
            Instance of InfoStream that does no logging at all. </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Message(System.String,System.String)">
            <summary>
            prints a message </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.IsEnabled(System.String)">
            <summary>
            returns true if messages are enabled and should be posted to <seealso cref="!:#message"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.InfoStream.Default" -->
        <member name="T:Lucene.Net.Util.IntsRef">
             <summary>
             Represents int[], as a slice (offset + length) into an
              existing int[].  The <seealso cref="!:#ints"/> member should never be null; use
              <seealso cref="!:#EMPTY_INTS"/> if necessary.
            
              @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntsRef.EMPTY_INTS">
            <summary>
            An empty integer array for convenience </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntsRef.Ints">
            <summary>
            The contents of the IntsRef. Should never be {@code null}. </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntsRef.Offset">
            <summary>
            Offset of first valid integer. </summary>
        </member>
        <member name="F:Lucene.Net.Util.IntsRef.Length">
            <summary>
            Length of used ints. </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntsRef.#ctor">
            <summary>
            Create a IntsRef with <seealso cref="!:#EMPTY_INTS"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntsRef.#ctor(System.Int32)">
            <summary>
            Create a IntsRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntsRef.#ctor(System.Int32[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference ints w/o making a copy.
            ints should not be null.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntsRef.Clone" -->
        <member name="M:Lucene.Net.Util.IntsRef.CompareTo(Lucene.Net.Util.IntsRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntsRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IntsRef.DeepCopyOf(Lucene.Net.Util.IntsRef)" -->
        <member name="P:Lucene.Net.Util.IntsRef.Valid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IOUtils">
            <summary>
            this class emulates the new Java 7 "Try-With-Resources" statement.
            Remove once Lucene is on Java 7.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IOUtils.CHARSET_UTF_8">
            <summary>
            UTF-8 <seealso cref="!:Charset"/> instance to prevent repeated
            <seealso cref="!:Charset#forName(String)"/> lookups </summary>
            @deprecated Use <seealso cref="!:StandardCharsets#UTF_8"/> instead.
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.IOUtils.UTF_8" -->
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.IDisposable[])">
            <summary>
            <p>Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions. Some of the <tt>IDisposable</tt>s
            may be null, they are ignored. After everything is closed, method either throws <tt>priorException</tt>,
            if one is supplied, or the first of suppressed exceptions, or completes normally.</p>
            <p>Sample usage:<br/>
            <pre class="prettyprint">
            IDisposable resource1 = null, resource2 = null, resource3 = null;
            ExpectedException priorE = null;
            try {
              resource1 = ...; resource2 = ...; resource3 = ...; // Acquisition may throw ExpectedException
              ..do..stuff.. // May throw ExpectedException
            } catch (ExpectedException e) {
              priorE = e;
            } finally {
              closeWhileHandlingException(priorE, resource1, resource2, resource3);
            }
            </pre>
            </p> </summary>
            <param name="priorException">  <tt>null</tt> or an exception that will be rethrown after method completion </param>
            <param name="objects">         objects to call <tt>close()</tt> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions. </summary>
            <seealso> cref= #closeWhileHandlingException(Exception, IDisposable...)  </seealso>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Close(System.IDisposable[])">
            <summary>
            Closes all given <tt>IDisposable</tt>s.  Some of the
            <tt>IDisposable</tt>s may be null; they are
            ignored.  After everything is closed, the method either
            throws the first exception it hit while closing, or
            completes normally if there were no exceptions.
            </summary>
            <param name="objects">
                     objects to call <tt>close()</tt> on </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.Close(System.Collections.Generic.IEnumerable{System.IDisposable})" -->
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.IDisposable[])">
            <summary>
            Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions.
            Some of the <tt>IDisposable</tt>s may be null, they are ignored.
            </summary>
            <param name="objects">
                     objects to call <tt>close()</tt> on </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException``1(System.Collections.Generic.IEnumerable{``0})" -->
        <member name="M:Lucene.Net.Util.IOUtils.AddSuppressed(System.Exception,System.Exception)">
            <summary>
            Since there's no C# equivalent of Java's Exception.AddSuppressed, we add the
            suppressed exceptions to a data field. </summary>
            <param name="exception"> this exception should get the suppressed one added </param>
            <param name="suppressed"> the suppressed exception </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.Stream,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.FileInfo,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.Type,System.String,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.DeleteFilesIgnoringExceptions(Lucene.Net.Store.Directory,System.String[])" -->
        <member name="M:Lucene.Net.Util.IOUtils.Copy(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Copy one file's contents to another file. The target will be overwritten
            if it exists. The source must exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrow(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            {@code Throwable} and rethrows either {@code
            IOException} or an unchecked exception.  If the
            argument is null then this method does nothing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrowUnchecked(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            {@code Throwable} and rethrows it as an unchecked exception.
            If the argument is null then this method does nothing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Fsync(System.String,System.Boolean)">
            <summary>
            Ensure that any writes to the given file is written to the storage device that contains it. </summary>
            <param name="fileToSync"> the file to fsync </param>
            <param name="isDir"> if true, the given file is a directory (we open for read and ignore IOExceptions,
             because not all file systems and operating systems allow to fsync on a directory) </param>
        </member>
        <member name="T:Lucene.Net.Util.LongBitSet">
             <summary>
             BitSet of fixed length (numBits), backed by accessible (<seealso cref="!:#getBits"/>)
             long[], accessed with a long index. Use it only if you intend to store more
             than 2.1B bits, otherwise you should use <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.LongBitSet.EnsureCapacity(Lucene.Net.Util.LongBitSet,System.Int64)" -->
        <member name="M:Lucene.Net.Util.LongBitSet.Bits2words(System.Int64)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Length">
            <summary>
            Returns the number of bits stored in this bitset. </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
             long in the backing bits array, and the result is not
             internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the last set bit before or on the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Or(Lucene.Net.Util.LongBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Xor(Lucene.Net.Util.LongBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Intersects(Lucene.Net.Util.LongBitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.And(Lucene.Net.Util.LongBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.AndNot(Lucene.Net.Util.LongBitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.LongBitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="P:Lucene.Net.Util.LongBitSet.Bits">
            <summary>
            Expert. </summary>
        </member>
        <member name="T:Lucene.Net.Util.LongsRef">
             <summary>
             Represents long[], as a slice (offset + length) into an
              existing long[].  The <seealso cref="!:#longs"/> member should never be null; use
              <seealso cref="!:#EMPTY_LONGS"/> if necessary.
            
              @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.LongsRef.EMPTY_LONGS">
            <summary>
            An empty long array for convenience </summary>
        </member>
        <member name="F:Lucene.Net.Util.LongsRef.Longs">
            <summary>
            The contents of the LongsRef. Should never be {@code null}. </summary>
        </member>
        <member name="F:Lucene.Net.Util.LongsRef.Offset">
            <summary>
            Offset of first valid long. </summary>
        </member>
        <member name="F:Lucene.Net.Util.LongsRef.Length">
            <summary>
            Length of used longs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongsRef.#ctor">
            <summary>
            Create a LongsRef with <seealso cref="!:#EMPTY_LONGS"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongsRef.#ctor(System.Int32)">
            <summary>
            Create a LongsRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongsRef.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference longs w/o making a copy.
            longs should not be null
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.LongsRef.Clone" -->
        <member name="M:Lucene.Net.Util.LongsRef.CompareTo(Lucene.Net.Util.LongsRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.LongsRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.LongsRef.DeepCopyOf(Lucene.Net.Util.LongsRef)" -->
        <member name="P:Lucene.Net.Util.LongsRef.Valid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.MapOfSets`2">
            <summary>
            Helper class for keeping Lists of Objects associated with keys. <b>WARNING: this CLASS IS NOT THREAD SAFE</b>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.#ctor(System.Collections.Generic.IDictionary{`0,System.Collections.Generic.HashSet{`1}})">
            <param name="m"> the backing store for this object </param>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.Put(`0,`1)">
            <summary>
            Adds val to the Set associated with key in the Map.  If key is not
            already in the map, a new Set will first be created. </summary>
            <returns> the size of the Set associated with key once val is added to it. </returns>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.PutAll(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds multiple vals to the Set associated with key in the Map.
            If key is not
            already in the map, a new Set will first be created. </summary>
            <returns> the size of the Set associated with key once val is added to it. </returns>
        </member>
        <member name="P:Lucene.Net.Util.MapOfSets`2.Map">
            <returns> direct access to the map backing this object. </returns>
        </member>
        <member name="T:Lucene.Net.Util.MathUtil">
            <summary>
            Math static utility methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Log(System.Int64,System.Int32)" -->
        <member name="M:Lucene.Net.Util.MathUtil.Log(System.Double,System.Double)">
            <summary>
            Calculates logarithm in a given base with doubles.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Gcd(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Asinh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Acosh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Atanh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.MergedIterator`1" -->
        <member name="T:Lucene.Net.Util.Mutable.MutableValue">
             <summary>
             Base class for all mutable values.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueBool">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>boolean</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDate">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <seealso cref="!:Date"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueLong">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>long</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDouble">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>double</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueFloat">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>float</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueInt">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>int</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueStr">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <seealso cref="!:String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NamedThreadFactory">
            <summary>
            A default <seealso cref="T:Lucene.Net.Support.ThreadFactory"/> implementation that accepts the name prefix
            of the created threads as a constructor argument. Otherwise, this factory
            yields the same semantics as the thread factory returned by
            <seealso cref="!:Executors#defaultThreadFactory()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedThreadFactory.#ctor(System.String)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.NamedThreadFactory"/> instance
            </summary>
            <param name="threadNamePrefix"> the name prefix assigned to each thread created. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NamedThreadFactory.NewThread(Lucene.Net.Support.IThreadRunnable)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.OfflineSorter" -->
        <member name="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter">
            <summary>
            Utility class to emit length-prefixed byte[] entries to an output stream for sorting.
            Complementary to <seealso cref="!:ByteSequencesReader"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(System.String)">
            <summary>
            Constructs a ByteSequencesWriter to the provided File </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Constructs a ByteSequencesWriter to the provided DataOutput </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Dispose">
            <summary>
            Closes the provided <seealso cref="T:Lucene.Net.Store.DataOutput"/> if it is <seealso cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.OpenBitSet" -->
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64)">
            <summary>
            Constructs an OpenBitSet large enough to hold {@code numBits}. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor">
            <summary>
            Constructor: allocates enough space for 64 bits. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64[],System.Int32)" -->
        <member name="M:Lucene.Net.Util.OpenBitSet.Capacity">
            <summary>
            Returns the current capacity in bits (1 greater than the index of the last bit) </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Size">
            <summary>
            Returns the current capacity of this set.  Included for
            compatibility.  this is *not* equal to <seealso cref="!:#cardinality"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int32)">
            <summary>
            Returns true or false for the specified bit index. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int32)">
            <summary>
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int64)">
            <summary>
            Returns true or false for the specified bit index
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int64)">
            <summary>
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBit(System.Int32)">
            <summary>
            returns 1 if the bit is set, 0 if not.
            The index should be less than the OpenBitSet size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64)">
            <summary>
            sets a bit, expanding the set size if necessary </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int32)">
            <summary>
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int64)">
            <summary>
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits, expanding the set size if necessary
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int32)">
            <summary>
            clears a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int64)">
            <summary>
            clears a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64)">
            <summary>
            clears a bit, allowing access beyond the current set size without changing the size. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int32)">
            <summary>
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int64)">
            <summary>
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int32)">
            <summary>
            flips a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int64)">
            <summary>
            flips a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64)">
            <summary>
            flips a bit, expanding the set size if necessary </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int32)">
            <summary>
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int64)">
            <summary>
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits, expanding the set size if necessary
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Cardinality">
            <returns> the number of set bits </returns>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.IntersectionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.UnionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.AndNotCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b"
            or "intersection(a, not(b))".
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.XorCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the exclusive-or of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting downwards at
             the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting downwards at
             the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersect(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Union(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Remove(Lucene.Net.Util.OpenBitSet)">
            <summary>
            Remove all elements set in other. this = this AND_NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Xor(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersects(Lucene.Net.Util.OpenBitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacityWords(System.Int32)">
            <summary>
            Expand the long[] with the size given as a number of words (64 bit longs). </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacity(System.Int64)">
            <summary>
            Ensure that the long[] is big enough to hold numBits, expanding it if
            necessary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.TrimTrailingZeros">
            <summary>
            Lowers numWords, the number of words in use,
            by checking for trailing zero words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Bits2words(System.Int64)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Cacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Empty">
            <summary>
            Returns true if there are no set bits </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Bits">
            <summary>
            Expert: returns the long[] storing the bits </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.NumWords">
            <summary>
            Expert: gets the number of longs in the array that are in use </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetDISI">
            <summary>
            OpenBitSet with added methods to bulk-update the bits
             from a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(Lucene.Net.Search.DocIdSetIterator,System.Int32)">
            <summary>
            Construct an OpenBitSetDISI with its bits set
            from the doc ids of the given DocIdSetIterator.
            Also give a maximum size one larger than the largest doc id for which a
            bit may ever be set on this OpenBitSetDISI.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(System.Int32)">
            <summary>
            Construct an OpenBitSetDISI with no bits set, and a given maximum size
            one larger than the largest doc id for which a bit may ever be set
            on this OpenBitSetDISI.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceOr(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace OR with the doc ids from a given DocIdSetIterator,
            setting the bit for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceAnd(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace AND with the doc ids from a given DocIdSetIterator,
            leaving only the bits set for which the doc ids are in common.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace NOT with the doc ids from a given DocIdSetIterator,
            clearing all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceXor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace XOR with the doc ids from a given DocIdSetIterator,
            flipping all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetIterator">
            <summary>
            An iterator to iterate over set bits in an OpenBitSet.
            this is faster than nextSetBit() for iterating over the complete set of bits,
            especially when the density of the bits set is high.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OpenBitSetIterator.NextDoc" -->
        <member name="T:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer">
            <summary>
            Common functionality shared by <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer"/> and <seealso cref="T:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Size">
            <summary>
            Get the number of values that have been added to the buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Add(System.Int64)">
            <summary>
            Append a value to this buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Get(System.Int64,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <code>len</code> longs starting
            from <code>index</code> into <code>arr[off:off+len]</code> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.RamBytesUsed">
            <summary>
            Return the number of bytes used by this instance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Freeze">
            <summary>
            Pack all pending values in this buffer. Subsequent calls to <seealso cref="!:#add(long)"/> will fail. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Iterator.HasNext">
            <summary>
            Whether or not there are remaining values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingLongBuffer.Iterator.Next">
            <summary>
            Return the next long in the buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a multiple of <tt>64</tt> </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Reset(Lucene.Net.Store.DataOutput)">
            <summary>
            Reset this writer to wrap <code>out</code>. The block size remains unchanged. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Add(System.Int64)">
            <summary>
            Append a new long. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Finish">
            <summary>
            Flush all buffered data to disk. this instance is not usable anymore
             after this method has been called until <seealso cref="!:#reset(DataOutput)"/> has
             been called.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Ord">
            <summary>
            Return the number of values which have been added. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AbstractPagedMutable`1">
            <summary>
            Base implementation for <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/> and <seealso cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Size">
            <summary>
            The number of values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Set(System.Int64,System.Int64)">
            <summary>
            Set value at <code>index</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.RamBytesUsed">
            <summary>
            Return the number of bytes used by this object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Resize(System.Int64)">
            <summary>
            Create a new copy of size <code>newSize</code> based on the content of
             this buffer. this method is much more efficient than creating a new
             instance and copying values one by one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow(System.Int64)">
            <summary>
            Similar to <seealso cref="!:ArrayUtil#grow(long[], int)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow">
            <summary>
            Similar to <seealso cref="!:ArrayUtil#grow(long[])"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer">
             <summary>
             Utility class to buffer a list of signed longs in memory. this class only
             supports appending and is optimized for the case where values are close to
             each other.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer"/> </summary>
            <param name="initialPageCount">        the initial number of pages </param>
            <param name="pageSize">                the size of a single page </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInts#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingPackedLongBuffer">
             <summary>
             Utility class to buffer a list of signed longs in memory. this class only
             supports appending and is optimized for non-negative numbers with a uniform distribution over a fixed (limited) range
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedLongBuffer.#ctor(System.Int32,System.Int32,System.Single)">
             <summary>
            <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedLongBuffer"/> </summary>
             <param name="initialPageCount">        the initial number of pages </param>
             <param name="pageSize">                the size of a single page </param>
             <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedLongBuffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedLongBuffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInts#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedLongBuffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedLongBuffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BlockPackedReader">
            <summary>
            Provides random access to a stream written with <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.BlockPackedReaderIterator" -->
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a block, must be equal to the
                             block size of the <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/> which has
                             been used to write the stream </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Reset(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Reset the current reader to wrap a stream of <code>valueCount</code>
            values contained in <code>in</code>. The block size remains unchanged.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Skip(System.Int64)">
            <summary>
            Skip exactly <code>count</code> values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next">
            <summary>
            Read the next value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next(System.Int32)">
            <summary>
            Read between <tt>1</tt> and <code>count</code> values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Ord">
            <summary>
            Return the offset of the next value to read. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.BlockPackedWriter" -->
        <member name="M:Lucene.Net.Util.Packed.BlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a power of 2 </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperation">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Decoder">
            <summary>
            A decoder for packed integers.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PackedInts" -->
        <member name="F:Lucene.Net.Util.Packed.PackedInts.FASTEST">
            <summary>
            At most 700% memory overhead, always select a direct implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInts.FAST">
            <summary>
            At most 50% memory overhead, always select a reasonably fast implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInts.DEFAULT">
            <summary>
            At most 20% memory overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInts.COMPACT">
            <summary>
            No memory overhead at all, but the returned implementation may be slow.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInts.DEFAULT_BUFFER_SIZE">
            <summary>
            Default amount of memory to use for bulk operations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.CheckVersion(System.Int32)">
            <summary>
            Check the validity of a version number.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.FastestFormatAndBits(System.Int32,System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.GetDecoder(Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32)">
            <summary>
            Get a <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.Decoder"/>.
            </summary>
            <param name="format">         the format used to store packed ints </param>
            <param name="version">        the compatibility version </param>
            <param name="bitsPerValue">   the number of bits per value </param>
            <returns> a decoder </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.GetEncoder(Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32)">
            <summary>
            Get an <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.Encoder"/>.
            </summary>
            <param name="format">         the format used to store packed ints </param>
            <param name="version">        the compatibility version </param>
            <param name="bitsPerValue">   the number of bits per value </param>
            <returns> an encoder </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInts.Header)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.GetReader(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.Reader"/> from a stream.
            </summary>
            <param name="in">           the stream to read data from </param>
            <returns>             a Reader </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error
            @lucene.internal </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetReaderIteratorNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.GetReaderIterator(Lucene.Net.Store.DataInput,System.Int32)">
            <summary>
            Retrieve PackedInts as a <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.ReaderIterator"/> </summary>
            <param name="in"> positioned at the beginning of a stored packed int structure. </param>
            <param name="mem"> how much memory the iterator is allowed to use to read-ahead (likely to speed up iteration) </param>
            <returns> an iterator to access the values </returns>
            <exception cref="!:IOException"> if the structure could not be retrieved.
            @lucene.internal </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInts.Header)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetDirectReader(Lucene.Net.Store.IndexInput)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetMutable(System.Int32,System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.GetMutable(System.Int32,System.Int32,Lucene.Net.Util.Packed.PackedInts.Format)">
            <summary>
            Same as <seealso cref="!:#getMutable(int, int, float)"/> with a pre-computed number
             of bits per value and format.
             @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInts.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.GetWriter(Lucene.Net.Store.DataOutput,System.Int32,System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.BitsRequired(System.Int64)">
            <summary>
            Returns how many bits are required to hold values up
             to and including maxValue </summary>
            <param name="maxValue"> the maximum value that should be representable. </param>
            <returns> the amount of bits needed to represent values from 0 to maxValue.
            @lucene.internal </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.MaxValue(System.Int32)">
            <summary>
            Calculates the maximum unsigned long that can be expressed with the given
            number of bits. </summary>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
            <returns> the maximum value for the given bits.
            @lucene.internal </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Copy(Lucene.Net.Util.Packed.PackedInts.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInts.Mutable,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy <code>src[srcPos:srcPos+len]</code> into
            <code>dest[destPos:destPos+len]</code> using at most <code>mem</code>
            bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Copy(Lucene.Net.Util.Packed.PackedInts.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInts.Mutable,System.Int32,System.Int32,System.Int64[])">
            <summary>
            Same as <seealso cref="!:#copy(Reader, int, Mutable, int, int, int)"/> but using a pre-allocated buffer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.ReadHeader(Lucene.Net.Store.DataInput)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInts.CheckBlockSize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check that the block size is a power of 2, in the right bounds, and return
             its log in base 2.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.NumBlocks(System.Int64,System.Int32)">
            <summary>
            Return the number of blocks required to store <code>size</code> values on
             <code>blockSize</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.PackedFormat">
            <summary>
            Returns the overhead ratio (<code>overhead per value / bits per value</code>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.FormatAndBits">
            <summary>
            Simple class that holds a format and a number of bits per value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Decoder">
            <summary>
            A decoder for packed integers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.LongBlockCount">
            <summary>
            The minimum number of long blocks to encode in a single iteration, when
            using long encoding.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.LongValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#longBlockCount()"/> long
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.ByteBlockCount">
            <summary>
            The minimum number of byte blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#byteBlockCount()"/> byte
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.Decode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.Decode(System.Byte[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>8 * iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.Decode(System.Int64[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Decoder.Decode(System.Byte[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <code>8 * iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Encoder">
            <summary>
            An encoder for packed integers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.LongBlockCount">
            <summary>
            The minimum number of long blocks to encode in a single iteration, when
            using long encoding.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.LongValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#longBlockCount()"/> long
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.ByteBlockCount">
            <summary>
            The minimum number of byte blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#byteBlockCount()"/> byte
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.Encode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.Encode(System.Int64[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>8 * iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.Encode(System.Int32[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Encoder.Encode(System.Int32[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>8 * iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Reader">
            <summary>
            A read-only random access array of positive integers.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Reader.Get(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <code>len</code> longs starting
            from <code>index</code> into <code>arr[off:off+len]</code> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Reader.Size">
            <returns> the number of values. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Reader.RamBytesUsed">
            <summary>
            Return the in-memory size in bytes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInts.Reader.HasArray" -->
        <member name="P:Lucene.Net.Util.Packed.PackedInts.Reader.BitsPerValue">
            <returns> the number of bits used to store any given value.
                    Note: this does not imply that memory usage is
                    {@code bitsPerValue * #values} as implementations are free to
                    use non-space-optimal packing of bits. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.Packed.PackedInts.Reader.Array" -->
        <member name="T:Lucene.Net.Util.Packed.PackedInts.ReaderIterator">
            <summary>
            Run-once iterator interface, to decode previously saved PackedInts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.ReaderIterator.Next">
            <summary>
            Returns next value </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.ReaderIterator.Next(System.Int32)">
            <summary>
            Returns at least 1 and at most <code>count</code> next values,
            the returned ref MUST NOT be modified
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.ReaderIterator.Size">
            <summary>
            Returns number of values </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.ReaderIterator.Ord">
            <summary>
            Returns the current position </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInts.ReaderIterator.BitsPerValue">
            <summary>
            Returns number of bits per value </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Mutable">
            <summary>
            A packed integer array that can be modified.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Mutable.Set(System.Int32,System.Int64)">
            <summary>
            Set the value at the given index in the array. </summary>
            <param name="index"> where the value should be positioned. </param>
            <param name="value"> a value conforming to the constraints set by the array. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Mutable.Set(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk set: set at least one and at most <code>len</code> longs starting
            at <code>off</code> in <code>arr</code> into this mutable, starting at
            <code>index</code>. Returns the actual number of values that have been
            set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Mutable.Fill(System.Int32,System.Int32,System.Int64)">
            <summary>
            Fill the mutable from <code>fromIndex</code> (inclusive) to
            <code>toIndex</code> (exclusive) with <code>val</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Mutable.Clear">
            <summary>
            Sets all values to 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Mutable.Save(Lucene.Net.Store.DataOutput)">
            <summary>
            Save this mutable into <code>out</code>. Instantiating a reader from
            the generated data will return a reader with the same number of bits
            per value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInts.Mutable.Format">
            <summary>
            The underlying format. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.ReaderImpl">
            <summary>
            A simple base for Readers that keeps track of valueCount and bitsPerValue.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.NullReader">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.Reader"/> which has all its values equal to 0 (bitsPerValue = 0). </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.NullReader.#ctor(System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Writer">
            <summary>
            A write-once Writer.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Writer.Add(System.Int64)">
            <summary>
            Add a value to the stream. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Writer.BitsPerValue">
            <summary>
            The number of bits per value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Writer.Finish">
            <summary>
            Perform end-of-stream operations. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInts.Writer.Ord">
            <summary>
            Returns the current ord in the stream (number of values that have been
            written so far minus one).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInts.Writer.Format">
            <summary>
            The format used to serialize values. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInts.Header">
            <summary>
            Header identifying the structure of a packed integer array. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperation.ComputeIterations(System.Int32,System.Int32)">
             <summary>
             For every number of bits per value, there is a minimum number of
             blocks (b) / values (v) you need to write in order to reach the next block
             boundary:
              - 16 bits per value -> b=2, v=1
              - 24 bits per value -> b=3, v=1
              - 50 bits per value -> b=25, v=4
              - 63 bits per value -> b=63, v=8
              - ...
            
             A bulk read consists in copying <code>iterations*v</code> values that are
             contained in <code>iterations*b</code> blocks into a <code>long[]</code>
             (higher values of <code>iterations</code> are likely to yield a better
             throughput) => this requires n * (b + 8v) bytes of memory.
            
             this method computes <code>iterations</code> as
             <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked">
            <summary>
            Non-specialized <seealso cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <seealso cref="!:PackedInts.Format#PACKED"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked1">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked10">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked11">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked12">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked13">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked14">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked15">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked16">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked17">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked18">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked19">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked2">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked20">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked21">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked22">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked23">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked24">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked3">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked4">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked5">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked6">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked7">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked8">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked9">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock">
            <summary>
            Non-specialized <seealso cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <seealso cref="!:PackedInts.Format#PACKED_SINGLE_BLOCK"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct16">
            <summary>
            Direct wrapping of 16-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct32">
            <summary>
            Direct wrapping of 32-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct64">
            <summary>
            Direct wrapping of 64-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct8">
            <summary>
            Direct wrapping of 8-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDecoder">
            <summary>
            A decoder for an <seealso cref="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.#ctor(Lucene.Net.Util.Packed.EliasFanoEncoder)">
            <summary>
            Construct a decoder for a given <seealso cref="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder"/>.
            The decoding index is set to just before the first encoded value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NumEncoded">
            <summary>
            The number of values encoded by the encoder. </summary>
            <returns> The number of values encoded by the encoder. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentIndex">
            <summary>
            The current decoding index.
            The first value encoded by <seealso cref="!:EliasFanoEncoder#encodeNext"/> has index 0.
            Only valid directly after
            <seealso cref="!:#nextValue"/>, <seealso cref="!:#advanceToValue"/>,
            <seealso cref="!:#previousValue"/>, or <seealso cref="!:#backToValue"/>
            returned another value than <seealso cref="!:#NO_MORE_VALUES"/>,
            or <seealso cref="!:#advanceToIndex"/> returned true. </summary>
            <returns> The decoding index of the last decoded value, or as last set by <seealso cref="!:#advanceToIndex"/>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentValue" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentHighValue">
             <returns> The high value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.UnPackValue(System.Int64[],System.Int32,System.Int64,System.Int64)">
            <summary>
            See also <seealso cref="!:EliasFanoEncoder#packValue"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLowValue">
             <returns> The low value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CombineHighLowValues(System.Int64,System.Int64)">
             <returns> The given highValue shifted left by the number of low bits from by the EliasFanoSequence,
                      logically OR-ed with the given lowValue. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeSequence">
            <summary>
            Set the decoding index to just before the first encoded value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterCurrentHighBit">
            <summary>
            Increment efIndex and setBitForIndex and
            shift curHighLong so that it does not contain the high bits before setBitForIndex. </summary>
            <returns> true iff efIndex still smaller than numEncoded. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighLong">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
             Increment setBitForIndex to the next high long and set curHighLong accordingly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighValue">
            <summary>
            setBitForIndex and efIndex have just been incremented, scan to the next high set bit
             by incrementing setBitForIndex, and by setting curHighLong accordingly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextHighValue">
            <summary>
            setBitForIndex and efIndex have just been incremented, scan to the next high set bit
             by incrementing setBitForIndex, and by setting curHighLong accordingly. </summary>
             <returns> the next encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextValue">
            <summary>
            If another value is available after the current decoding index, return this value and
            and increase the decoding index by 1. Otherwise return <seealso cref="!:#NO_MORE_VALUES"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToValue(System.Int64)" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterSequence">
            <summary>
            Set the decoding index to just after the last encoded value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeCurrentHighBit">
            <summary>
            Decrement efindex and setBitForIndex and
            shift curHighLong so that it does not contain the high bits after setBitForIndex. </summary>
            <returns> true iff efindex still >= 0 </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToPreviousHighLong">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
             Decrement setBitForIndex to the previous high long and set curHighLong accordingly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousHighValue">
            <summary>
            setBitForIndex and efIndex have just been decremented, scan to the previous high set bit
             by decrementing setBitForIndex and by setting curHighLong accordingly. </summary>
             <returns> the previous encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousValue">
            <summary>
            If another value is available before the current decoding index, return this value
            and decrease the decoding index by 1. Otherwise return <seealso cref="!:#NO_MORE_VALUES"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToHighValue(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToValue(System.Int64)" -->
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder">
            <returns> The Elias-Fano encoder that is decoded. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentRightShift">
            <returns> the number of bits in a long after (setBitForIndex modulo Long.SIZE) </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLeftShift">
            <returns> the number of bits in a long before (setBitForIndex modulo Long.SIZE) </returns>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet">
            <summary>
            A DocIdSet in Elias-Fano encoding.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct an EliasFanoDocIdSet. For efficient encoding, the parameters should be chosen as low as possible. </summary>
            <param name="numValues"> At least the number of document ids that will be encoded. </param>
            <param name="upperBound">  At least the highest document id that will be encoded. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.SufficientlySmallerThanBitSet(System.Int64,System.Int64)">
            <summary>
            Provide an indication that is better to use an <seealso cref="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet"/> than a <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>
             to encode document identifiers. </summary>
             <param name="numValues"> The number of document identifiers that is to be encoded. Should be non negative. </param>
             <param name="upperBound"> The maximum possible value for a document identifier. Should be at least <code>numValues</code>. </param>
             <returns> See <seealso cref="!:EliasFanoEncoder#sufficientlySmallerThanBitSet(long, long)"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.EncodeFromDisi(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Encode the document ids from a DocIdSetIterator. </summary>
             <param name="disi"> this DocIdSetIterator should provide document ids that are consistent
                         with <code>numValues</code> and <code>upperBound</code> as provided to the constructor.   </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.GetIterator">
            <summary>
            Provides a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access encoded document ids.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDocIdSet.Cacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
            <returns> <code>true</code> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.EliasFanoEncoder" -->
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.DEFAULT_INDEX_INTERVAL">
            <summary>
            The default index interval for zero upper bits. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.UpperZeroBitPositionIndex">
            <summary>
            upperZeroBitPositionIndex[i] (filled using packValue) will contain the bit position
             just after the zero bit ((i+1) * indexInterval) in the upper bits.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64,System.Int64)" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64)">
            <summary>
            Construct an Elias-Fano encoder using <seealso cref="!:#DEFAULT_INDEX_INTERVAL"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.SufficientlySmallerThanBitSet(System.Int64,System.Int64)" -->
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.Decoder">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Util.Packed.EliasFanoDecoder"/> to access the encoded values.
            Perform all calls to <seealso cref="!:#encodeNext"/> before calling <seealso cref="!:#getDecoder"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.LowerBits">
            <summary>
            Expert. The low bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.UpperBits">
            <summary>
            Expert. The high bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.IndexBits">
            <summary>
            Expert. The index bits. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.GrowableWriter" -->
        <member name="M:Lucene.Net.Util.Packed.GrowableWriter.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="startBitsPerValue">       the initial number of bits per value, may grow depending on the data </param>
            <param name="valueCount">              the number of values </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer">
             <summary>
             Utility class to buffer signed longs in memory, which is optimized for the
             case where the sequence is monotonic, although it can encode any sequence of
             arbitrary longs. It only supports appending.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="initialPageCount">        the initial number of pages </param>
            <param name="pageSize">                the size of a single page </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInts#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedLongBuffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicBlockPackedReader">
            <summary>
            Provides random access to a stream written with
            <seealso cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.Size">
            <summary>
            Returns the number of values </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.RamBytesUsed">
            <summary>
            Returns the approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter" -->
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a power of 2 </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed16ThreeBlocks">
            <summary>
            Packs integers into 3 shorts (48 bits per value).
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.Packed64" -->
        <member name="F:Lucene.Net.Util.Packed.Packed64.Blocks">
            <summary>
            Values are stores contiguously in the blocks array.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.MaskRight">
            <summary>
            A right-aligned mask of width BitsPerValue used by <seealso cref="!:#get(int)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.BpvMinusBlockSize">
            <summary>
            Optimization: Saves one lookup in <seealso cref="!:#get(int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an array with the internal structures adjusted for the given
            limits and initialized to 0. </summary>
            <param name="valueCount">   the number of elements. </param>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,Lucene.Net.Store.DataInput,System.Int32,System.Int32)">
            <summary>
            Creates an array with content retrieved from the given DataInput. </summary>
            <param name="in">       a DataInput, positioned at the start of Packed64-content. </param>
            <param name="valueCount">  the number of elements. </param>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
            <exception cref="!:java.io.IOException"> if the values for the backing array could not
                                        be retrieved. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.Get(System.Int32)">
            <param name="index"> the position of the value. </param>
            <returns> the value at the given index. </returns>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed64SingleBlock">
            <summary>
            this class is similar to <seealso cref="T:Lucene.Net.Util.Packed.Packed64"/> except that it trades space for
            speed by ensuring that a single block needs to be read/written in order to
            read/write a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed8ThreeBlocks">
            <summary>
            Packs integers into 3 bytes (24 bits per value).
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PackedDataInput" -->
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Create a new instance that wraps <code>in</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.ReadLong(System.Int32)">
            <summary>
            Read the next long using exactly <code>bitsPerValue</code> bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.SkipToNextByte">
            <summary>
            If there are pending bits (at most 7), they will be ignored and the next
            value will be read starting at the next byte.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PackedDataOutput" -->
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new instance that wraps <code>out</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.WriteLong(System.Int64,System.Int32)">
            <summary>
            Write a value using exactly <code>bitsPerValue</code> bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.Flush">
            <summary>
            Flush pending bits to the underlying <seealso cref="T:Lucene.Net.Store.DataOutput"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PagedGrowableWriter" -->
        <member name="M:Lucene.Net.Util.Packed.PagedGrowableWriter.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/> instance.
            </summary>
            <param name="size"> the number of values to store. </param>
            <param name="pageSize"> the number of values per page </param>
            <param name="startBitsPerValue"> the initial number of bits per value </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PagedMutable">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/>. this class slices data into fixed-size blocks
            which have the same number of bits per value. It can be a useful replacement
            for <seealso cref="T:Lucene.Net.Util.Packed.PackedInts.Mutable"/> to store more than 2B values.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PagedMutable.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/> instance.
            </summary>
            <param name="size"> the number of values to store. </param>
            <param name="pageSize"> the number of values per page </param>
            <param name="bitsPerValue"> the number of bits per value </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.PagedBytes">
             <summary>
             Represents a logical byte[] as a series of pages.  You
              can write-once into the logical byte[] (append only),
              using copy, and then retrieve slices (BytesRef) into it
              using fill.
            
             @lucene.internal
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.#ctor(System.Int32)">
            <summary>
            1&lt;&lt;blockBits must be bigger than biggest single
             BytesRef slice that will be pulled
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Read this many bytes from in </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.PagedBytes.Freeze(System.Boolean)">
            <summary>
            Commits final byte[], trimming it if necessary and if trim=true </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.RamBytesUsed">
            <summary>
            Return approx RAM usage in bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(Lucene.Net.Util.BytesRef)">
            <summary>
            Copy bytes in, writing the length as a 1 or 2 byte
             vInt prefix.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.DataInput">
            <summary>
            Returns a DataInput to read values from this
             PagedBytes instance.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.DataOutput">
            <summary>
            Returns a DataOutput that you may use to write into
             this PagedBytes instance.  If you do this, you should
             not call the other writing methods (eg, copy);
             results are undefined.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.PagedBytes.Reader" -->
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.FillSlice(Lucene.Net.Util.BytesRef,System.Int64,System.Int32)">
             <summary>
             Gets a slice out of <seealso cref="T:Lucene.Net.Util.PagedBytes"/> starting at <i>start</i> with a
             given length. Iff the slice spans across a block border this method will
             allocate sufficient resources and copy the paged data.
             <p>
             Slices spanning more than two blocks are not supported.
             </p>
             @lucene.internal
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.Fill(Lucene.Net.Util.BytesRef,System.Int64)">
             <summary>
             Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.
             <p>
             <b>Note:</b> this method does not support slices spanning across block
             borders.
             </p>
            
             @lucene.internal
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.Position">
            <summary>
            Returns the current byte position. </summary>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.PagedBytesDataOutput.Position">
            <summary>
            Return the current byte position. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet">
            <summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on pfor-delta encoding.
            <p>this implementation is inspired from LinkedIn's Kamikaze
            (http://data.linkedin.com/opensource/kamikaze) and Daniel Lemire's JavaFastPFOR
            (https://github.com/lemire/JavaFastPFOR).</p>
            <p>On the contrary to the original PFOR paper, exceptions are encoded with
            FOR instead of Simple16.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <seealso cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this instance. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet.Builder">
            <summary>
            A builder for <seealso cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Every <code>indexInterval</code>-th block will
            be stored in the index. Set to <seealso cref="!:Integer#MAX_VALUE"/> to disable indexing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Convenience method to add the content of a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to this builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Build">
            <summary>
            Build the <seealso cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/> instance. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PrintStreamInfoStream">
             <summary>
             InfoStream implementation over a <seealso cref="!:PrintStream"/>
             such as <code>System.out</code>.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.QueryBuilder" -->
        <member name="M:Lucene.Net.Util.QueryBuilder.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new QueryBuilder using the given analyzer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String,Lucene.Net.Search.BooleanClause.Occur)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateMinShouldMatchQuery(System.String,System.String,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateFieldQuery(Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.BooleanClause.Occur,System.String,System.String,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewBooleanQuery(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewTermQuery(Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewPhraseQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewMultiPhraseQuery" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.QueryBuilder.Analyzer" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.QueryBuilder.EnablePositionIncrements" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.RamUsageEstimator" -->
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_KB">
            <summary>
            One kilobyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.JVM_INFO_STRING">
            <summary>
            JVM info string for debugging and reports. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_MB">
            <summary>
            One megabyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_GB">
            <summary>
            One gigabyte bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.#ctor">
            <summary>
            No instantiation. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_REF">
            <summary>
            Number of bytes this jvm uses to represent an object reference.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_HEADER">
            <summary>
            Number of bytes to represent an object header (no fields, no alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_ARRAY_HEADER">
            <summary>
            Number of bytes to represent an array header (no content, but with alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT">
            <summary>
            A constant specifying the object alignment boundary inside the JVM. Objects will
            always take a full multiple of this constant, possibly wasting some space.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.PrimitiveSizes">
            <summary>
            Sizes of primitive classes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.TheUnsafe">
            <summary>
            A handle to <code>sun.misc.Unsafe</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.AlignObjectSize(System.Int64)">
            <summary>
            Aligns an object size to be the next multiple of <seealso cref="!:#NUM_BYTES_OBJECT_ALIGNMENT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.SByte[])">
            <summary>
            Returns the size in bytes of the byte[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Boolean[])">
            <summary>
            Returns the size in bytes of the boolean[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Char[])">
            <summary>
            Returns the size in bytes of the char[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int16[])">
            <summary>
            Returns the size in bytes of the short[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int32[])">
            <summary>
            Returns the size in bytes of the int[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Single[])">
            <summary>
            Returns the size in bytes of the float[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int64[])">
            <summary>
            Returns the size in bytes of the long[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Double[])">
            <summary>
            Returns the size in bytes of the double[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)">
             <summary>
             Estimates the RAM usage by the given object. It will
             walk the object tree and sum up all referenced objects.
            
             <p><b>Resource Usage:</b> this method internally uses a set of
             every object seen during traversals so it does allocate memory
             (it isn't side-effect free). After the method exits, this memory
             should be GCed.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOf(System.Object)">
             <summary>
             Estimates a "shallow" memory usage of the given object. For arrays, this will be the
             memory taken by array storage (no subreferences will be followed). For objects, this
             will be the memory taken by the fields.
            
             JVM object alignments are also applied.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfInstance(System.Type)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfArray(System.Array)">
            <summary>
            Return shallow size of any <code>array</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.CreateCacheEntry(System.Type)">
            <summary>
            Create a cached information about shallow size and reference fields for
            a given class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.AdjustForField(System.Int64,System.Reflection.FieldInfo)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64)">
            <summary>
            Returns <code>size</code> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64,System.IFormatProvider)">
            <summary>
            Returns <code>size</code> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.HumanSizeOf(System.Object)" -->
        <member name="T:Lucene.Net.Util.RamUsageEstimator.ClassCache">
            <summary>
            Cached information about a given class.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1">
             <summary>
             An identity hash set implemented using open addressing. No null keys are allowed.
            
             TODO: If this is useful outside this class, make it public - needs some work
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.DEFAULT_LOAD_FACTOR">
            <summary>
            Default load factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.MIN_CAPACITY">
            <summary>
            Minimum capacity for the set.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Keys">
            <summary>
            All of set entries. Always of power of two length.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Assigned">
            <summary>
            Cached number of assigned slots.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.LoadFactor">
            <summary>
            The load factor for this set (fraction of allocated or deleted slots before
            the buffers must be rehashed or reallocated).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.ResizeThreshold">
            <summary>
            Cached capacity threshold at which we must resize the buffers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor">
            <summary>
            Creates a hash set with the default capacity of 16.
            load factor of {@value #DEFAULT_LOAD_FACTOR}. `
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32)">
            <summary>
            Creates a hash set with the given capacity, load factor of
            {@value #DEFAULT_LOAD_FACTOR}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32,System.Single)">
            <summary>
            Creates a hash set with the given capacity and load factor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Add(`0)">
            <summary>
            Adds a reference to the set. Null keys are not allowed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Contains(`0)">
            <summary>
            Checks if the set contains a given ref.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Rehash(System.Object)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.ExpandAndRehash">
            <summary>
            Expand the internal storage buffers (capacity) or rehash current keys and
            values if there are a lot of deleted slots.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.AllocateBuffers(System.Int32)">
            <summary>
            Allocate internal buffers for a given capacity.
            </summary>
            <param name="capacity">
                     New capacity (must be a power of two). </param>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.NextCapacity(System.Int32)">
            <summary>
            Return the next possible capacity, counting from the current buffers' size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.RoundCapacity(System.Int32)">
            <summary>
            Round the capacity to the next allowed value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingByteBlockAllocator">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> implementation that recycles unused byte
            blocks in a buffer and reuses them in subsequent calls to
            <seealso cref="!:#getByteBlock()"/>.
            <p>
            Note: this class is not thread-safe
            </p>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered byte block </param>
            <param name="bytesUsed">
                     <seealso cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered byte block </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor">
             <summary>
             Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/> with a block size of
             <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>, upper buffered docs limit of
             <seealso cref="!:#DEFAULT_BUFFERED_BLOCKS"/> ({@value #DEFAULT_BUFFERED_BLOCKS}).
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.NumBufferedBlocks">
            <returns> the number of currently buffered blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.BytesUsed">
            <returns> the number of bytes currently allocated by this <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.MaxBufferedBlocks">
            <returns> the maximum number of buffered byte blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of byte blocks from the buffer if possible.
            </summary>
            <param name="num">
                     the number of byte blocks to remove </param>
            <returns> the number of actually removed buffers </returns>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingIntBlockAllocator">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.IntBlockPool.Allocator"/> implementation that recycles unused int
            blocks in a buffer and reuses them in subsequent calls to
            <seealso cref="!:#getIntBlock()"/>.
            <p>
            Note: this class is not thread-safe
            </p>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingIntBlockAllocator"/>
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered int block </param>
            <param name="bytesUsed">
                     <seealso cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingIntBlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     the size of each block returned by this allocator </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered int blocks </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.#ctor">
             <summary>
             Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingIntBlockAllocator"/> with a block size of
             <seealso cref="!:IntBlockPool#INT_BLOCK_SIZE"/>, upper buffered docs limit of
             <seealso cref="!:#DEFAULT_BUFFERED_BLOCKS"/> ({@value #DEFAULT_BUFFERED_BLOCKS}).
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.NumBufferedBlocks">
            <returns> the number of currently buffered blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.BytesUsed">
            <returns> the number of bytes currently allocated by this <seealso cref="T:Lucene.Net.Util.IntBlockPool.Allocator"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.MaxBufferedBlocks">
            <returns> the maximum number of buffered byte blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingIntBlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of int blocks from the buffer if possible.
            </summary>
            <param name="num">
                     the number of int blocks to remove </param>
            <returns> the number of actually removed buffers </returns>
        </member>
        <member name="T:Lucene.Net.Util.SentinelIntSet">
             <summary>
             A native int hash-based set where one value is reserved to mean "EMPTY" internally. The space overhead is fairly low
             as there is only one power-of-two sized int[] to hold the values.  The set is re-hashed when adding a value that
             would make it &gt;= 75% full.  Consider extending and over-riding <seealso cref="!:#hash(int)"/> if the values might be poor
             hash keys; Lucene docids should be fine.
             The internal fields are exposed publicly to enable more efficient use at the expense of better O-O principles.
             <p/>
             To iterate over the integers held in this set, simply use code like this:
             <pre class="prettyprint">
             SentinelIntSet set = ...
             for (int v : set.keys) {
               if (v == set.emptyVal)
                 continue;
               //use v...
             }</pre>
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.SentinelIntSet.Keys">
            <summary>
            A power-of-2 over-sized array holding the integers in the set along with empty values. </summary>
        </member>
        <member name="F:Lucene.Net.Util.SentinelIntSet.RehashCount">
            <summary>
            the count at which a rehash should be done </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.#ctor(System.Int32,System.Int32)">
            
             <param name="size">  The minimum number of elements this set should be able to hold without rehashing
                          (i.e. the slots are guaranteed not to change) </param>
             <param name="emptyVal"> The integer value to use for EMPTY </param>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Hash(System.Int32)">
            <summary>
            (internal) Return the hash for the key. The default implementation just returns the key,
            which is not appropriate for general purpose use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Size">
            <summary>
            The number of integers in this set. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.GetSlot(System.Int32)">
            <summary>
            (internal) Returns the slot for this key </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Find(System.Int32)">
            <summary>
            (internal) Returns the slot for this key, or -slot-1 if not found </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Exists(System.Int32)">
            <summary>
            Does this set contain the specified integer? </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Put(System.Int32)">
            <summary>
            Puts this integer (key) in the set, and returns the slot index it was added to.
            It rehashes if adding it would make the set more than 75% full.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelIntSet.Rehash">
            <summary>
            (internal) Rehashes by doubling {@code int[] key} and filling with the old values. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SetOnce`1">
             <summary>
             A convenient class which offers a semi-immutable object wrapper
             implementation which allows one to set the value of an object exactly once,
             and retrieve it many times. If <seealso cref="!:#set(Object)"/> is called more than once,
             <seealso cref="T:Lucene.Net.Util.SetOnce`1.AlreadySetException"/> is thrown and the operation
             will fail.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.#ctor">
            <summary>
            A default constructor which does not set the internal object, and allows
            setting it by calling <seealso cref="!:#set(Object)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SetOnce`1.#ctor(`0)" -->
        <member name="M:Lucene.Net.Util.SetOnce`1.Set(`0)">
            <summary>
            Sets the given object. If the object has already been set, an exception is thrown. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.Get">
            <summary>
            Returns the object set by <seealso cref="!:#set(Object)"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SetOnce`1.AlreadySetException">
            <summary>
            Thrown when <seealso cref="!:SetOnce#set(Object)"/> is called more than once. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SloppyMath">
            <summary>
            Math functions that trade off accuracy for speed. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.Haversin(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance in kilometers between two points
            specified in decimal degrees (latitude/longitude). </summary>
            <param name="lat1"> Latitude of the first point. </param>
            <param name="lon1"> Longitude of the first point. </param>
            <param name="lat2"> Latitude of the second point. </param>
            <param name="lon2"> Longitude of the second point. </param>
            <returns> distance in kilometers. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SloppyMath.Cos(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SloppyMath.Asin(System.Double)" -->
        <member name="M:Lucene.Net.Util.SloppyMath.EarthDiameter(System.Double)">
            <summary>
            Return an approximate value of the diameter of the earth at the given latitude, in kilometers. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.#cctor">
            <summary>
            Initializes look-up tables. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SmallFloat">
             <summary>
             Floating point numbers smaller than 32 bits.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallFloat.#ctor">
            <summary>
            No instance </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte(System.Single,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.ByteToFloat(System.SByte,System.Int32,System.Int32)">
            <summary>
            Converts an 8 bit float to a 32 bit float. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte315(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte315ToFloat(System.SByte)">
            <summary>
            byteToFloat(b, mantissaBits=3, zeroExponent=15) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte52(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte52ToFloat(System.SByte)">
            <summary>
            byteToFloat(b, mantissaBits=5, zeroExponent=2) </summary>
        </member>
        <member name="T:Lucene.Net.Util.SPIClassIterator`1">
             <summary>
             Helper class for loading SPI classes from classpath (META-INF files).
             this is a light impl of <seealso cref="!:java.util.ServiceLoader"/> but is guaranteed to
             be bug-free regarding classpath order and does not instantiate or initialize
             the classes found.
            
             @lucene.internal
             </summary>
            
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
             <summary>
             Methods for manipulating strings.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.BytesDifference(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Compares two <seealso cref="T:Lucene.Net.Util.BytesRef"/>, element by element, and returns the
            number of elements common to both arrays.
            </summary>
            <param name="left"> The first <seealso cref="T:Lucene.Net.Util.BytesRef"/> to compare </param>
            <param name="right"> The second <seealso cref="T:Lucene.Net.Util.BytesRef"/> to compare </param>
            <returns> The number of common elements. </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StartsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <code>true</code> iff the ref starts with the given prefix.
            Otherwise <code>false</code>.
            </summary>
            <param name="ref">
                     the <seealso cref="T:Lucene.Net.Util.BytesRef"/> to test </param>
            <param name="prefix">
                     the expected prefix </param>
            <returns> Returns <code>true</code> iff the ref starts with the given prefix.
                    Otherwise <code>false</code>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.EndsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <code>true</code> iff the ref ends with the given suffix. Otherwise
            <code>false</code>.
            </summary>
            <param name="ref">
                     the <seealso cref="T:Lucene.Net.Util.BytesRef"/> to test </param>
            <param name="suffix">
                     the expected suffix </param>
            <returns> Returns <code>true</code> iff the ref ends with the given suffix.
                    Otherwise <code>false</code>. </returns>
        </member>
        <member name="F:Lucene.Net.Util.StringHelper.good_fast_hash_seed">
            <summary>
            Pass this as the seed to <seealso cref="!:#murmurhash3_x86_32"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.Murmurhash3_x86_32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the MurmurHash3_x86_32 hash.
            Original source/tests at https://github.com/yonik/java_util/
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.StringHelper.VersionComparator">
            <returns> a Comparator over versioned strings such as X.YY.Z
            @lucene.internal </returns>
        </member>
        <member name="T:Lucene.Net.Util.ToStringUtils">
            <summary>
            Helper methods to ease implementing <seealso cref="!:Object#toString()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Boost(System.Single)">
            <summary>
            for printing boost only if not 1.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.UnicodeUtil">
             <summary>
             Class to encode java's UTF16 char[] into UTF8 byte[]
             without always allocating a new byte[] as
             String.getBytes(StandardCharsets.UTF_8) does.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_SHIFT_">
            <summary>
            Shift value for lead surrogate to form a supplementary character. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MASK_">
            <summary>
            Mask to retrieve the significant value from a trail surrogate. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MIN_VALUE">
            <summary>
            Trail surrogate minimum value </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_MIN_VALUE">
            <summary>
            Lead surrogate minimum value </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.SUPPLEMENTARY_MIN_VALUE">
            <summary>
            The minimum value for Supplementary code points </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.UnicodeUtil.BIG_TERM" -->
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(Lucene.Net.Util.CharsRef,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from a char[] source, starting at
             offset for length chars. After encoding, result.offset will always be 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from this String, starting at offset
             for length characters. After encoding, result.offset will always be 0.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.CodePointCount(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF32(Lucene.Net.Util.BytesRef,Lucene.Net.Util.IntsRef)" -->
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_OFFSET_">
            <summary>
            Value that all lead surrogate starts with </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.NewString(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Cover JDK 1.5 API. Create a String from an array of codePoints.
            </summary>
            <param name="codePoints"> The code array </param>
            <param name="offset"> The start of the text in the code point array </param>
            <param name="count"> The number of code points </param>
            <returns> a String representing the code points between offset and count </returns>
            <exception cref="!:IllegalArgumentException"> If an invalid code point is encountered </exception>
            <exception cref="!:IndexOutOfBoundsException"> If the offset or count are out of bounds. </exception>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.ToCharArray(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Generates char array that represents the provided input code points
            </summary>
            <param name="codePoints"> The code array </param>
            <param name="offset"> The start of the text in the code point array </param>
            <param name="count"> The number of code points </param>
            <returns> a char array representing the code points between offset and count </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.CharsRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(Lucene.Net.Util.BytesRef,Lucene.Net.Util.CharsRef)" -->
        <member name="T:Lucene.Net.Util.LuceneVersion">
             <summary>
             Use by certain classes to match version compatibility
             across releases of Lucene.
            
             <p><b>WARNING</b>: When changing the version parameter
             that you supply to components in Lucene, do not simply
             change the version at search-time, but instead also adjust
             your indexing code to match, and re-index.</p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_30">
            <summary>
            Match settings and bugs in Lucene's 3.0 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_31">
            <summary>
            Match settings and bugs in Lucene's 3.1 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_32">
            <summary>
            Match settings and bugs in Lucene's 3.2 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_33">
            <summary>
            Match settings and bugs in Lucene's 3.3 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_34">
            <summary>
            Match settings and bugs in Lucene's 3.4 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_35">
            <summary>
            Match settings and bugs in Lucene's 3.5 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_36">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_40">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.1) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_41">
            <summary>
            Match settings and bugs in Lucene's 4.1 release. </summary>
            @deprecated (4.2) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_42">
            <summary>
            Match settings and bugs in Lucene's 4.2 release. </summary>
            @deprecated (4.3) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_43">
            <summary>
            Match settings and bugs in Lucene's 4.3 release. </summary>
            @deprecated (4.4) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_44">
            <summary>
            Match settings and bugs in Lucene's 4.4 release. </summary>
            @deprecated (4.5) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_45">
            <summary>
            Match settings and bugs in Lucene's 4.5 release. </summary>
            @deprecated (4.6) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_46">
            <summary>
            Match settings and bugs in Lucene's 4.6 release. </summary>
            @deprecated (4.7) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_47">
            <summary>
            Match settings and bugs in Lucene's 4.7 release. </summary>
            @deprecated (4.8) Use latest
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.LuceneVersion.LUCENE_48" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.LuceneVersion.LUCENE_CURRENT" -->
        <member name="T:Lucene.Net.Util.VirtualMethod`1">
             <summary>
             A utility for keeping backwards compatibility on previously abstract methods
             (or similar replacements).
             <p>Before the replacement method can be made abstract, the old method must kept deprecated.
             If somebody still overrides the deprecated method in a non-final class,
             you must keep track, of this and maybe delegate to the old method in the subclass.
             The cost of reflection is minimized by the following usage of this class:</p>
             <p>Define <strong>static final</strong> fields in the base class ({@code BaseClass}),
             where the old and new method are declared:</p>
             <pre class="prettyprint">
              static final VirtualMethod&lt;BaseClass&gt; newMethod =
               new VirtualMethod&lt;BaseClass&gt;(BaseClass.class, "newName", parameters...);
              static final VirtualMethod&lt;BaseClass&gt; oldMethod =
               new VirtualMethod&lt;BaseClass&gt;(BaseClass.class, "oldName", parameters...);
             </pre>
             <p>this enforces the singleton status of these objects, as the maintenance of the cache would be too costly else.
             If you try to create a second instance of for the same method/{@code baseClass} combination, an exception is thrown.</p>
             <p>To detect if e.g. the old method was overridden by a more far subclass on the inheritance path to the current
             instance's class, use a <strong>non-static</strong> field:</p>
             <pre class="prettyprint">
              final boolean isDeprecatedMethodOverridden =
               oldMethod.getImplementationDistance(this.getClass()) &gt; newMethod.getImplementationDistance(this.getClass());
            
              <em>// alternatively (more readable):</em>
              final boolean isDeprecatedMethodOverridden =
               VirtualMethod.compareImplementationDistance(this.getClass(), oldMethod, newMethod) &gt; 0
             </pre>
             <p><seealso cref="!:getImplementationDistance"/> returns the distance of the subclass that overrides this method.
             The one with the larger distance should be used preferable.
             this way also more complicated method rename scenarios can be handled
             (think of 2.9 {@code TokenStream} deprecations).</p>
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod`1.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Creates a new instance for the given {@code baseClass} and method declaration. </summary>
            <exception cref="!:UnsupportedOperationException"> if you create a second instance of the same
             {@code baseClass} and method declaration combination. this enforces the singleton status. </exception>
            <exception cref="!:IllegalArgumentException"> if {@code baseClass} does not declare the given method. </exception>
        </member>
        <member name="M:Lucene.Net.Util.VirtualMethod`1.GetImplementationDistance(System.Type)">
            <summary>
            Returns the distance from the {@code baseClass} in which this method is overridden/implemented
            in the inheritance path between {@code baseClass} and the given subclass {@code subclazz}. </summary>
            <returns> 0 iff not overridden, else the distance to the base class </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.VirtualMethod`1.IsOverriddenAsOf(System.Type)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.VirtualMethod`1.compareImplementationDistance``1(System.Type,Lucene.Net.Util.VirtualMethod{``0},Lucene.Net.Util.VirtualMethod{``0})" -->
        <member name="T:Lucene.Net.Util.WAH8DocIdSet">
            <summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on word-aligned hybrid encoding on
            words of 8 bits.
            <p>this implementation doesn't support random-access but has a fast
            <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> which can advance in logarithmic time thanks to
            an index.</p>
            <p>The compression scheme is simplistic and should work well with sparse and
            very dense doc id sets while being only slightly larger than a
            <seealso cref="T:Lucene.Net.Util.FixedBitSet"/> for incompressible sets (overhead&lt;2% in the worst
            case) in spite of the index.</p>
            <p><b>Format</b>: The format is byte-aligned. An 8-bits word is either clean,
            meaning composed only of zeros or ones, or dirty, meaning that it contains
            between 1 and 7 bits set. The idea is to encode sequences of clean words
            using run-length encoding and to leave sequences of dirty words as-is.</p>
            <table>
              <tr><th>Token</th><th>Clean length+</th><th>Dirty length+</th><th>Dirty words</th></tr>
              <tr><td>1 byte</td><td>0-n bytes</td><td>0-n bytes</td><td>0-n bytes</td></tr>
            </table>
            <ul>
              <li><b>Token</b> encodes whether clean means full of zeros or ones in the
            first bit, the number of clean words minus 2 on the next 3 bits and the
            number of dirty words on the last 4 bits. The higher-order bit is a
            continuation bit, meaning that the number is incomplete and needs additional
            bytes to be read.</li>
              <li><b>Clean length+</b>: If clean length has its higher-order bit set,
            you need to read a <seealso cref="!:DataInput#readVInt() vint"/>, shift it by 3 bits on
            the left side and add it to the 3 bits which have been read in the token.</li>
              <li><b>Dirty length+</b> works the same way as <b>Clean length+</b> but
            on 4 bits and for the length of dirty words.</li>
              <li><b>Dirty words</b> are the dirty words, there are <b>Dirty length</b>
            of them.</li>
            </ul>
            <p>this format cannot encode sequences of less than 2 clean words and 0 dirty
            word. The reason is that if you find a single clean word, you should rather
            encode it as a dirty word. this takes the same space as starting a new
            sequence (since you need one byte for the token) but will be lighter to
            decode. There is however an exception for the first sequence. Since the first
            sequence may start directly with a dirty word, the clean length is encoded
            directly, without subtracting 2.</p>
            <p>There is an additional restriction on the format: the sequence of dirty
            words is not allowed to contain two consecutive clean words. this restriction
            exists to make sure no space is wasted and to make sure iterators can read
            the next doc ID by reading at most 2 dirty words.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.WAH8DocIdSet.DEFAULT_INDEX_INTERVAL">
            <summary>
            Default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <seealso cref="!:#intersect(Collection, int)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the intersection of the provided sets. this method is much faster than
            computing the intersection manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <seealso cref="!:#union(Collection, int)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the union of the provided sets. this method is much faster than
            computing the union manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <seealso cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this class in bytes. </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.WordBuilder">
            <summary>
            Word-based builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Smaller index intervals improve performance of
             <seealso cref="!:DocIdSetIterator#advance(int)"/> but make the <seealso cref="T:Lucene.Net.Search.DocIdSet"/>
             larger. An index interval <code>i</code> makes the index add an overhead
             which is at most <code>4/i</code>, but likely much less.The default index
             interval is <code>8</code>, meaning the index has an overhead of at most
             50%. To disable indexing, you can pass <seealso cref="!:Integer#MAX_VALUE"/> as an
             index interval.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.Build">
            <summary>
            Build a new <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.Builder">
            <summary>
            A builder for <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.#ctor">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Add the content of the provided <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.WeakIdentityMap`2" -->
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.newHashMap">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a non-synchronized <seealso cref="!:HashMap"/>.
            The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewHashMap(System.Boolean)">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a non-synchronized <seealso cref="!:HashMap"/>. </summary>
            <param name="reapOnRead"> controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>. </param>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewConcurrentHashMap">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a <seealso cref="!:ConcurrentHashMap"/>.
            The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewConcurrentHashMap(System.Boolean)">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a <seealso cref="!:ConcurrentHashMap"/>. </summary>
            <param name="reapOnRead"> controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>. </param>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.#ctor(System.Collections.Generic.IDictionary{Lucene.Net.Util.WeakIdentityMap{`0,`1}.IdentityWeakReference,`1},System.Boolean)">
            <summary>
            Private only constructor, to create use the static factory methods. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Clear">
            <summary>
            Removes all of the mappings from this map. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.ContainsKey(System.Object)">
            <summary>
            Returns {@code true} if this map contains a mapping for the specified key. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Get(System.Object)">
            <summary>
            Returns the value to which the specified key is mapped. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Put(`0,`1)">
            <summary>
            Associates the specified value with the specified key in this map.
            If the map previously contained a mapping for this key, the old value
            is replaced.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Remove(System.Object)">
            <summary>
            Removes the mapping for a key from this weak hash map if it is present.
            Returns the value to which this map previously associated the key,
            or {@code null} if the map contained no mapping for the key.
            A return value of {@code null} does not necessarily indicate that
            the map contained.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Size">
            <summary>
            Returns the number of key-value mappings in this map. this result is a snapshot,
            and may not reflect unprocessed entries that will be removed before next
            attempted access because they are no longer referenced.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.ValueIterator">
            <summary>
            Returns an iterator over all values of this map.
            this iterator may return values whose key is already
            garbage collected while iterator is consumed,
            especially if {@code reapOnRead} is {@code false}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.WeakIdentityMap`2.Reap" -->
        <member name="P:Lucene.Net.Util.WeakIdentityMap`2.Empty">
            <summary>
            Returns {@code true} if this map contains no key-value mappings. </summary>
        </member>
    </members>
</doc>
